<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Nothing is true,every is permitted.">
<meta property="og:type" content="website">
<meta property="og:title" content="NOTHING">
<meta property="og:url" content="http://uwuneng.com/page/3/index.html">
<meta property="og:site_name" content="NOTHING">
<meta property="og:description" content="Nothing is true,every is permitted.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NOTHING">
<meta name="twitter:description" content="Nothing is true,every is permitted.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://uwuneng.com/page/3/"/>





  <title>NOTHING</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NOTHING</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">NOTHING IS EVERYTHING.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/05/29/iOS 作为Central蓝牙连接外围（下）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/29/iOS 作为Central蓝牙连接外围（下）/" itemprop="url">iOS 作为Central蓝牙连接外围（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-29T20:48:00+08:00">
                2016-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/wower/" itemprop="url" rel="index">
                    <span itemprop="name">wower</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary: 仍然是公司蓝牙卡项目，搞了两周，现在大致搞定，作一个总结；首先要把上篇遗留下来的蓝牙外围设备写数据等问题解决下…</p>
<p>仍然是公司蓝牙卡项目，搞了两周，现在大致搞定，作一个总结；首先要把上篇遗留下来的蓝牙外围设备写数据等问题解决下…</p>
<h2 id="解决蓝牙写数据等问题"><a href="#解决蓝牙写数据等问题" class="headerlink" title="解决蓝牙写数据等问题"></a>解决蓝牙写数据等问题</h2><h3 id="更正读数据的一个问题"><a href="#更正读数据的一个问题" class="headerlink" title="更正读数据的一个问题"></a>更正读数据的一个问题</h3><p>更正一个问题，就是读数据时notify和read的两个回调，本人实测回调notification只是在之后回调一次，而不论读数据采用以上哪种，updataValue方法总是会执行，而且有时还不只是一次；</p>
<p>总结：</p>
<p>1.read方法时，回调updataValue；nofify时，notification回调一次后，updataValue再开始调，且不只一次；</p>
<p>2.接收 characteristic 数据的方式有两种：</p>
<p>在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。<br>用 setNotifyValue:forCharacteristic: 方法订阅，当有数据发送时，可以直接在回调中接收。</p>
<h3 id="向-characteristic-写数据"><a href="#向-characteristic-写数据" class="headerlink" title="向 characteristic 写数据"></a>向 characteristic 写数据</h3><p>写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[peripheral writeValue:dataToWrite forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];</span><br></pre></td></tr></table></figure>
<p>上面的那个type参数是表示是否需要在写入后进行回调，这里的意思是需要回调，那么将在下面这个函数回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didWriteValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(NSError *)error &#123;</span><br><span class="line"> </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;Error writing characteristic value: %@&quot;, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读写补充"><a href="#读写补充" class="headerlink" title="读写补充"></a>读写补充</h3><p>在不用和 peripheral 通信的时候，应当将连接断开，这也对节能有好处。在以下两种情况下，连接应该被断开：</p>
<p>当 characteristic 不再发送数据时。（可以通过 isNotifying 属性来判断）<br>你已经接收到了你所需要的所有数据时。<br>以上两种情况，都需要先结束订阅，然后断开连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[peripheral setNotifyValue:NO forCharacteristic:characteristic];</span><br><span class="line">[myCentralManager cancelPeripheralConnection:peripheral];</span><br></pre></td></tr></table></figure>
<p><strong>cancelPeripheralConnection:</strong> 是非阻塞性的，如果在 peripheral 挂起的状态去尝试断开连接，那么这个断开操作可能执行，也可能不会。因为可能还有其他的 central 连着它，所以取消连接并不代表底层连接也断开。从 app 的层面来讲，在 peripheral 决定断开的时候，会调用 <strong>CBCentralManagerDelegate</strong>  的 <strong>centralManager:didDisconnectPeripheral:error:</strong> 方法。</p>
<p>另外关于蓝牙重连等的相关东西，这里就不一一说了，有兴趣的还是到本文参考文章中去找答案吧！再次感谢广大的代码工作者们！</p>
<hr>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="关于结构方面的"><a href="#关于结构方面的" class="headerlink" title="关于结构方面的"></a>关于结构方面的</h2><p>这一点呢是个人习惯的问题，我们一般在工作中会接手到一些别人做了一半的任务，只有部分功能被实现的很好，那么这时就需要大量改动代码了。个人的建议是，不要在原来的模块中做修改，而是添加一个中间层，新实现的功能封装在新的类中，等到所有功能全部实现，再进行项目整合，因为这个时候对项目基本上能算作是了解，重构的时候也相对容易些。</p>
<p>第二点是关于iOS block与delegate选择上的意见，上面一点中说的中间层最好选用block，因为在逻辑上真的是很好理解，而且不容易出错，少写很多代码；而代理的话适合暴露出去，被其他人使用，这样调用你代码的人会在结构上相对好把握，自由度要大些。</p>
<p>PS:既然说到了block，我们补充一点，如果你想让自己的block失效，ARC下只要让他的指针置空就可以了，当然如果你只是对它进行了第二次赋值，那么之前指针所指向的block块是没有被失效的。</p>
<h2 id="说说写代码的一些"><a href="#说说写代码的一些" class="headerlink" title="说说写代码的一些"></a>说说写代码的一些</h2><p>1.就像本项目中用到的蓝牙，这些都是不需要在主线程中做的事情，诸如此类的相关还有网络连接，喇叭，话筒等（），将它们扔在后台线程中，任务完成之后回到主线程中修改UI;</p>
<p>2.一些超时操作，我们需要的把它也扔在后台线程中，你可以用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">            _scanTimer = [NSTimer scheduledTimerWithTimeInterval:seconds target:self selector:@selector(scanTimeoutHandler:) userInfo:nil repeats:NO];</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(scanTimeoutHandler:) withObject:nil afterDelay:seconds inModes:@[NSDefaultRunLoopMode]];</span><br></pre></td></tr></table></figure>
<p>或者直接把它加到你的一个runloop中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>否则它一直占用着当前的线程会给你带来很大的困扰；</p>
<p>3.NSStream Socket网络编程</p>
<p>NSStream很简单，用到的东西并不是很多就可以做一个简单的socket；NSStreamDelegate,NSInputStream,NSOutStream，一个代理和两个对象，连接的时候像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)connectToHostUseStreamWithIP:(NSString *)host port:(int)port data:(NSData *)data&#123;</span><br><span class="line">    // 1.建立连接</span><br><span class="line">    // 定义C语言输入输出流</span><br><span class="line">    CFReadStreamRef readStream;</span><br><span class="line">    CFWriteStreamRef writeStream;</span><br><span class="line">    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);</span><br><span class="line">    </span><br><span class="line">    // 把C语言的输入输出流转化成OC对象</span><br><span class="line">    _inputStream = (__bridge NSInputStream *)(readStream);</span><br><span class="line">    _outputStream = (__bridge NSOutputStream *)(writeStream);</span><br><span class="line">    </span><br><span class="line">    // 设置代理</span><br><span class="line">    _inputStream.delegate = self;</span><br><span class="line">    _outputStream.delegate = self;</span><br><span class="line">    </span><br><span class="line">    // 把输入输入流添加到运行循环</span><br><span class="line">    [_inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [_outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    </span><br><span class="line">    // 打开输入输出流</span><br><span class="line">    [_inputStream open];</span><br><span class="line">    [_outputStream open];</span><br><span class="line">    </span><br><span class="line">    //发送数据</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断开时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopConnect&#123;</span><br><span class="line">    // 从运行循环移除</span><br><span class="line">    [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    // 关闭输入输出流</span><br><span class="line">    [_inputStream close];</span><br><span class="line">    [_outputStream close];</span><br><span class="line">    </span><br><span class="line">    _inputStream = nil;</span><br><span class="line">    _outputStream = nil;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;Socket 连接已断开！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理只有一个回调函数，你所有的事情全部需要在这里面解决；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    //    NSStreamEventOpenCompleted = 1UL &lt;&lt; 0,//输入输出流打开完成</span><br><span class="line">    //    NSStreamEventHasBytesAvailable = 1UL &lt;&lt; 1,//有字节可读</span><br><span class="line">    //    NSStreamEventHasSpaceAvailable = 1UL &lt;&lt; 2,//可以发放字节</span><br><span class="line">    //    NSStreamEventErrorOccurred = 1UL &lt;&lt; 3,// 连接出现错误</span><br><span class="line">    //    NSStreamEventEndEncountered = 1UL &lt;&lt; 4// 连接结束</span><br><span class="line">    </span><br><span class="line">    switch (eventCode) &#123;</span><br><span class="line">        case NSStreamEventOpenCompleted:</span><br><span class="line">                NSLog(@&quot;输入输出流打开完成&quot;);</span><br><span class="line">                break;</span><br><span class="line">        case NSStreamEventHasBytesAvailable:</span><br><span class="line">                NSLog(@&quot;有字节可读&quot;);</span><br><span class="line">                [self readDataFromSocket];</span><br><span class="line">                break;</span><br><span class="line">        case NSStreamEventHasSpaceAvailable:</span><br><span class="line">                NSLog(@&quot;可以发送字节&quot;);</span><br><span class="line">            [self sendDataToSocket];</span><br><span class="line">                break;</span><br><span class="line">        case NSStreamEventErrorOccurred:</span><br><span class="line">                NSLog(@&quot;连接出现错误&quot;);</span><br><span class="line">                break;</span><br><span class="line">        case NSStreamEventEndEncountered:</span><br><span class="line">                NSLog(@&quot;连接结束&quot;);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        // 从运行循环移除</span><br><span class="line">        [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        // 关闭输入输出流</span><br><span class="line">        [_inputStream close];</span><br><span class="line">        [_outputStream close];</span><br><span class="line">                break;</span><br><span class="line">        default:</span><br><span class="line">                break;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住，一定是自己单独开一个线程，socket会一直占用着线程，如果你不把它自己关掉，那么它会无休止的连接着，你无法做一些其他的事情，所以，这一点很重要；</p>
<p>另外，用完一定要关掉它，一定，一定，重要的事情多说几遍；</p>
<p>4.状态机</p>
<p>我们在项目中有时会遇到一些状态值，一般情况下枚举将会是个好选择，然而当你遇到的状态是多选择的就显得不那么好用了；于是本项目中我用到的option会是一个好的点子；我们先上代码，然后来解释；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger,CardOperationState) &#123;</span><br><span class="line">    CardOperationState_idle = 0,</span><br><span class="line">    </span><br><span class="line">    CardOperationState_ReadCorrect = 1 &lt;&lt; 0, //读卡成功 1</span><br><span class="line">    CardOperationState_ReadWrong = 1 &lt;&lt; 1,   //读卡失败 2</span><br><span class="line">    </span><br><span class="line">    CardOperationState_Checkouted = 1 &lt;&lt; 2,      //已校验密码 4</span><br><span class="line">    CardOperationState_Written = 1 &lt;&lt; 3,         //数据已写入成功 8</span><br><span class="line">    CardOperationState_ChangedPass = 1 &lt;&lt; 4,     //已修改密码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子，如果你要表示的状态是已校验，已写入，已修改，那你的这个状态应该是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state == CardOperationState_Checkouted | CardOperationState_Written| CardOperationState_ChangedPass</span><br></pre></td></tr></table></figure>
<p>用枚举的话那要用好几个判断:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state == CardOperationState_Checkouted &amp;&amp; state == CardOperationState_Written &amp;&amp; state == CardOperationState_ChangedPass</span><br></pre></td></tr></table></figure>
<p>很明显，option少写了很多判断；</p>
<p>当前状态添加一个状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentState = currentState | CardOperationState_Checkouted;//增加已校验状态</span><br></pre></td></tr></table></figure>
<p>减少一个状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentState = currentState &amp; (~CardOperationState_ReadCorrect);</span><br></pre></td></tr></table></figure>
<p>判断是否包含一个状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentState &amp; CardOperationState_Checkouted</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/05/21/iOS 作为Central蓝牙连接外围（上）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/21/iOS 作为Central蓝牙连接外围（上）/" itemprop="url">iOS 作为Central蓝牙连接外围（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-21T18:06:00+08:00">
                2016-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary: 今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。</p>
<p>今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。难点主要集中在与蓝牙卡连接断开部分，因为蓝牙卡是低能耗的，每开启蓝牙卡片蓝牙后它会在8秒后自动断开连接，所以在处理蓝牙连接的的部分逻辑较为复杂。接下来我们把重点放在与蓝牙建立连接的部分，Google之，先来搞清楚与iOS有关的蓝牙库。    </p>
<p>先说一下蓝牙版本问题，如果你的设备支持的是蓝牙4.0之前的版本，那么会涉及到一个MFI的概念，MFI（Make For ipod/ipad/iphone）是苹果的一套认证，只有少数的硬件厂商才有苹果的MFI认证，做之前需要搞定这个认证。使用蓝牙4.0的话，由于4.0苹果开放了BLE（Bluetooth Low Energy）通道，就不会有认证的问题了，而且向下兼容。<br>我们用到的蓝牙库为CoreBluetooth，而蓝牙库中首先要介绍下两个概念Central和Peripheral；</p>
<h1 id="Central-和-Peripheral-在蓝牙交互中的角色"><a href="#Central-和-Peripheral-在蓝牙交互中的角色" class="headerlink" title="Central 和 Peripheral 在蓝牙交互中的角色"></a>Central 和 Peripheral 在蓝牙交互中的角色</h1><blockquote>
<font color="#C0C0C0" size="4">所有涉及蓝牙低功耗的交互中有两个主要的角色：中心Central和外围设备Perpheral。根据一些传统的客户端-服务端结构，Peripheral通常具有其他设备所需要的数据，而Central通常通过使用Perpheral的信息来实现一些特定的功能。</font>
</blockquote>
<p>这里我自己理解，如果你的设备连接的是本文这种蓝牙卡或者穿戴设备等，那么你的程序就是作为Central；如果你的设备是与另外一台iPhone设备，那么它既可以作为Central也可以作为Perpheral；</p>
<p>想了解更详细请参照：<a href="http://www.jianshu.com/p/760f042a1d81" target="_blank" rel="noopener">iOS蓝牙编程指南 – 核心蓝牙概述</a></p>
<h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><p>每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。特征是与外界交互的最小单位。比如说，一台蓝牙4.0设备，用特征A来描述自己的出厂信息，用特征B来与收发数据等。</p>
<p>服务和特征都是用UUID来唯一标识的，UUID的概念如果不清楚请自行google,国际蓝牙组织为一些很典型的设备(比如测量心跳和血压的设备)规定了标准的service UUID(特征的UUID比较多，这里就不列举了);        </p>
<blockquote>
<p><font color="#C0C0C0" size="2">UUID含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。<br>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</font></p>
</blockquote>
<blockquote>
<p>UUID由以下几部分的组合：</p>
</blockquote>
<blockquote>
<p>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>
</blockquote>
<blockquote>
<p>（2）时钟序列。</p>
</blockquote>
<blockquote>
<p>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。<br>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。</p>
</blockquote>
<h1 id="BLE中心模式流程"><a href="#BLE中心模式流程" class="headerlink" title="BLE中心模式流程"></a>BLE中心模式流程</h1><p>1.建立中心角色    </p>
<p>2.扫描外设(Discover Peripheral)    </p>
<p>3.连接外设(Connect Peripheral)    </p>
<p>4.扫描外设中的服务和特征(Discover Services And Characteristics)    </p>
<p>5.利用特征与外设做数据交互(Explore And Interact)</p>
<p>6.订阅Characteristic的通知</p>
<p>7.断开连接(Disconnect)</p>
<h1 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h1><h2 id="初始化-CBCentralManager"><a href="#初始化-CBCentralManager" class="headerlink" title="初始化 CBCentralManager"></a>初始化 CBCentralManager</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t centralQ = dispatch_queue_create(BLUETOOCH_QUEUE_IDENTIFER, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQ];</span><br></pre></td></tr></table></figure>
<p>上面的代码中，将self设置为代理，用于接收各种 central 事件。将queue设置为nil，则表示直接在主线程中运行，这里是我自己定义的任务队列。</p>
<p>创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>
<p>初始化 central manager 之后，设置的代理会调用centralManagerDidUpdateState:方法，所以需要去遵循<cbcentralmanagerdelegate>协议。这个 did update state 的方法，能获得当前设备是否能作为 central。关于这个协议的实现和其他方法，接下来会讲到，也可以先看看<a href="https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManagerDelegate_Protocol/index.html#//apple_ref/doc/uid/TP40011285" target="_blank" rel="noopener">官方API</a></cbcentralmanagerdelegate></p>
<h2 id="搜索当前可用的-peripheral"><a href="#搜索当前可用的-peripheral" class="headerlink" title="搜索当前可用的 peripheral"></a>搜索当前可用的 peripheral</h2><p>可以使用<em>CBCentralManager的scanForPeripheralsWithServices:options:</em>方法来扫描周围正在发出广播的 Peripheral 设备。peripheral 每秒都在发送大量的数据包，<em>scanForPeripheralsWithServices:options:</em>方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral  都会调用 <em>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</em> 方法。另外，当已发现的 peripheral  发送的数据包有变化时，这个代理方法同样会调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *services = @[[CBUUID UUIDWithString:BUSINESS_SERVICE_UUID_STRING]</span><br><span class="line">NSDictionary *scanOption = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@(NO)&#125;;</span><br><span class="line">[_centralManager scanForPeripheralsWithServices:services options:scanOption];</span><br></pre></td></tr></table></figure>
<p>这里的services是中心要扫描的蓝牙设备类型，表示只搜索当前数组包含的设备（每个 peripheral 的 service 都有唯一标识——UUID）；而scanOption中的<code>CBCentralManagerScanOptionAllowDuplicatesKey</code>设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option 会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。</p>
<p>在调用<code>scanForPeripheralsWithServices:options:</code>方法之后，找到可用设备，系统会回调（每找到一个都会回调）<code>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</code>。该方法会已CBPeripheral返回找到的 peripheral，所以你可以使用数组将找到的 peripheral 存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//扫描到蓝牙后的回调</span><br><span class="line">-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123;</span><br><span class="line">    //RSSI(Received Signal Strength Indication接收的信号强度指示)   </span><br><span class="line">    printf(&quot;didDiscoverPeripheral\n&quot;);</span><br><span class="line">    NSLog(@&quot;advertisement data is :%@&quot;,advertisementData);</span><br><span class="line">    NSString* identifer = [peripheral.identifier UUIDString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连接-peripheral"><a href="#连接-peripheral" class="headerlink" title="连接 peripheral"></a>连接 peripheral</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//连接外围设备</span><br><span class="line">[_centralManager connectPeripheral:peripheral options:nil];</span><br></pre></td></tr></table></figure>
<p>当连接成功后，会回调方法<em>centralManager:didConnectPeripheral:</em>。在这个方法中，你可以去记录当前的连接状态等数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123;</span><br><span class="line">    printf(&quot;已连接上设备：&quot;);</span><br><span class="line">    printf(&quot;name = %s\n&quot;,[peripheral.name UTF8String]);</span><br><span class="line">    </span><br><span class="line">    //连接到设备后要设置设备的代理，这样才可以接收到外围的服务与特性</span><br><span class="line">    peripheral.delegate = self;</span><br><span class="line">    </span><br><span class="line">    NSArray&lt;CBUUID*&gt;* uuids =@[</span><br><span class="line">	[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],</span><br><span class="line">	[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];</span><br><span class="line">	//发现服务</span><br><span class="line">	[peripheral discoverServices:uuids];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接断开则会回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//断开回调处理</span><br><span class="line">- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</span><br><span class="line">    printf(&quot;设备 %s 已断开！\n&quot;,[peripheral.name UTF8String]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>失败的情况下则是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//连接失败回调</span><br><span class="line">-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</span><br><span class="line">    NSLog(@&quot;didFailToConnectPeripheral error:%@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索-peripheral-的-service"><a href="#搜索-peripheral-的-service" class="headerlink" title="搜索 peripheral 的 service"></a>搜索 peripheral 的 service</h2><p>当与 peripheral 成功建立连接以后，就可以通信了。第一步是先找到当前 peripheral 提供的 service，因为 service 广播的数据有大小限制（貌似是 31 bytes），所以你实际找到的 service 的数量可能要比它广播时候说的数量要多。调用CBPeripheral的 <code>discoverServices:</code>方法可以找到当前 peripheral 的所有 service。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在搜索过程中，并不是所有的 service和characteristic 都是我们需要的,如果全部搜索，依然会造成不必要的资源浪费。</span><br><span class="line">//这里的uuids是我工程中用到的UUID</span><br><span class="line">NSArray&lt;CBUUID*&gt;* uuids =@[</span><br><span class="line">[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],</span><br><span class="line">[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];</span><br><span class="line">//发现服务</span><br><span class="line">[peripheral discoverServices:uuids];</span><br></pre></td></tr></table></figure>
<p>当找到特定的 Service 以后，会回调<cbperipheraldelegate>的<code>peripheral:didDiscoverServices:</code>方法。Core Bluetooth 提供了CBService类来表示 service，找到以后，它们以数组的形式存入了当前 peripheral 的services属性中，你可以在当前回调中遍历这个属性。</cbperipheraldelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; </span><br><span class="line">    if(error)&#123;</span><br><span class="line">        NSLog(@&quot;发现服务错误：%@&quot;,error);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;发现周边设备的服务:\n&quot;);</span><br><span class="line">    printf(&quot;==== didDiscoverServices ==== \n&quot;);</span><br><span class="line"> 	</span><br><span class="line">     //发现服务中的特性 </span><br><span class="line">    for (CBService *service in peripheral.services) &#123;</span><br><span class="line">        printf(&quot;-- service : %s\n&quot;,[[service.UUID UUIDString] UTF8String]);</span><br><span class="line">        [peripheral discoverCharacteristics:nil forService:service];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索-service-的-characteristic"><a href="#搜索-service-的-characteristic" class="headerlink" title="搜索 service 的 characteristic"></a>搜索 service 的 characteristic</h2><p>找到需要的 service 之后，下一步是找它所提供的 characteristic。如果搜索全部 characteristic，那调用CBPeripheral的<code>discoverCharacteristics:forService:</code>方法即可。如果是搜索当前service的characteristic，那还应该传入相应的CBService对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[peripheral discoverCharacteristics:nil forService:service];</span><br></pre></td></tr></table></figure>
<p>找到所有 characteristic 之后，回调<code>peripheral:didDiscoverCharacteristicsForService:error:</code>方法，此时 Core Bluetooth 提供了CBCharacteristic类来表示characteristic。可以通过以下代码来遍历找到的 characteristic ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123;</span><br><span class="line">    printf(&quot;发现服务 :(%s)\n&quot;,[[service.UUID UUIDString] UTF8String]);</span><br><span class="line">    </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;There is a error in peripheral:didDiscoverCharacteristicsForService:error: which called:%@&quot;,error);</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;开始读取服务数据...\n&quot;);</span><br><span class="line">    for (CBCharacteristic *characteristic in service.characteristics) &#123;</span><br><span class="line">        NSLog(@&quot;properties is %lu&quot;,characteristic.properties);</span><br><span class="line">        if (characteristic.properties &amp; CBCharacteristicPropertyNotify) &#123;</span><br><span class="line">//            [peripheral readValueForCharacteristic:characteristic];</span><br><span class="line">            [peripheral setNotifyValue:YES forCharacteristic:characteristic];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取-characteristic-数据"><a href="#读取-characteristic-数据" class="headerlink" title="读取 characteristic 数据"></a>读取 characteristic 数据</h2><p>这里读取涉及到两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[peripheral readValueForCharacteristic:characteristic];</span><br><span class="line">[peripheral setNotifyValue:YES forCharacteristic:characteristic];</span><br></pre></td></tr></table></figure>
<p>read这种方法是需要主动去接收的；notify方法订阅，当有数据发送时，可以直接在回调中接收,如果 characteristic 的数据经常变化，那么采用订阅的方式更好；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。</span><br><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;There is a error in peripheral:didUpdateValueForCharacteristic:error: which called:%@&quot;,error);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;characteristic data is:%@ &quot;,characteristic.value);</span><br><span class="line">    NSLog(@&quot;characteristic data length is %ld&quot;,characteristic.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以nofify可能会被调用多次，而且它获取的是实时数据，如果你接收蓝牙信息不是一次次接收的话，那么会用到它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//中心读取外设实时数据</span><br><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</span><br><span class="line">    printf(&quot;didUpdateNotificationStateForCharacteristic (%s)\n&quot;,[[characteristic.UUID UUIDString] UTF8String]);</span><br><span class="line">    if(error)&#123;</span><br><span class="line">        printf(&quot;error is : %s\n&quot;,[error.description UTF8String]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot; update notification success !!&quot;);</span><br><span class="line">    NSLog(@&quot;接收到的数据：%@&quot;,characteristic.value);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.saitjr.com/ios/core-bluetooth-read-write-as-central-role.html" target="_blank" rel="noopener">本文参考</a>，之后会继续讲解写数据和重连等问题；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/05/09/关于GLKit的推断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/09/关于GLKit的推断/" itemprop="url">关于GLKit的推断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-09T22:00:00+08:00">
                2016-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary:本篇是对OpenGLES_Ch2_1中的缓存管理代码的简单重用和重构，用以加深对GLKView的理解。苹果的GLKit框架封装了gl的具体实现，以便使用gl的用户减少编写gl的代码量以及避免不必要的错误。</p>
<p>本文介绍两个封装类，<code>AGLKContext</code>和<code>AGLKVertexAttribArrayBuffer</code>，前者是内建的<code>EAGLContext</code>的简单子类，后者封装了使用OpenGLES2.0顶点属性数组缓存的7个步骤；</p>
<h2 id="AGLKContext-m"><a href="#AGLKContext-m" class="headerlink" title="AGLKContext.m"></a><code>AGLKContext.m</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// This method sets the clear (background) RGBA color.</span><br><span class="line">// The clear color is undefined until this method is called.</span><br><span class="line">- (void)setClearColor:(GLKVector4)clearColorRGBA</span><br><span class="line">&#123;</span><br><span class="line">   clearColor = clearColorRGBA;</span><br><span class="line">    </span><br><span class="line">   NSAssert(self == [[self class] currentContext],</span><br><span class="line">      @&quot;Receiving context required to be current context&quot;);</span><br><span class="line">      </span><br><span class="line">   glClearColor(</span><br><span class="line">      clearColorRGBA.r, </span><br><span class="line">      clearColorRGBA.g, </span><br><span class="line">      clearColorRGBA.b, </span><br><span class="line">      clearColorRGBA.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line">// This method instructs OpenGL ES to set all data in the</span><br><span class="line">// current Context&apos;s Render Buffer(s) identified by mask to</span><br><span class="line">// colors (values) specified via -setClearColor: and/or</span><br><span class="line">// OpenGL ES functions for each Render Buffer type.</span><br><span class="line">- (void)clear:(GLbitfield)mask</span><br><span class="line">&#123;</span><br><span class="line">   NSAssert(self == [[self class] currentContext],</span><br><span class="line">      @&quot;Receiving context required to be current context&quot;);</span><br><span class="line">      </span><br><span class="line">   glClear(mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数原型: <code>void glClear(GLbitfield mask);</code><br>参数说明：<br>GLbitfield：可以使用 | 运算符组合不同的缓冲标志位，表明需要清除的缓冲，例如glClear（GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）表示要清除颜色缓冲以及深度缓冲，可以使用以下标志位    </p>
</blockquote>
<pre><code>GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲
GL_DEPTH_BUFFER_BIT:    深度缓冲
GL_ACCUM_BUFFER_BIT:    累积缓冲    
GL_STENCIL_BUFFER_BIT:  模板缓冲
</code></pre><p>函数说明：<br>glClear()函数的作用是用当前缓冲区清除值，也就是glClearColor或者glClearDepth、glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区，也可以使用glDrawBuffer一次清除多个颜色缓存。</p>
<p>以上两个函数的封装为渲染提供背景，并且利用glClearColor()将上下文帧缓存中的每个像素颜色设置为该颜色值；该类中的其他函数是OpenGL的相关函数，留着以后再研究；</p>
<h2 id="AGLKVertexAttribArrayBuffer-m"><a href="#AGLKVertexAttribArrayBuffer-m" class="headerlink" title="AGLKVertexAttribArrayBuffer.m"></a><code>AGLKVertexAttribArrayBuffer.m</code></h2><p>接下来我们说一下在开篇中谈到的7个步骤；</p>
<ul>
<li><p>NSParameterAssert<br>有的方法的条件可以满足可以不满足，都不影响执行。但如果你希望程序在某些条件不满足的时候产生错误告诉你，就用nsparameterassert让程序崩溃。</p>
</li>
<li><p>glGenBuffers  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// This method creates a vertex attribute array buffer in</span><br><span class="line">// the current OpenGL ES context for the thread upon which this </span><br><span class="line">// method is called.</span><br><span class="line">- (id)initWithAttribStride:(GLsizei)aStride</span><br><span class="line">   numberOfVertices:(GLsizei)count</span><br><span class="line">   bytes:(const GLvoid *)dataPtr</span><br><span class="line">   usage:(GLenum)usage;</span><br><span class="line">&#123;</span><br><span class="line">   NSParameterAssert(0 &lt; aStride);</span><br><span class="line">   NSAssert((0 &lt; count &amp;&amp; NULL != dataPtr) ||</span><br><span class="line">      (0 == count &amp;&amp; NULL == dataPtr),</span><br><span class="line">      @&quot;data must not be NULL or count &gt; 0&quot;);</span><br><span class="line">      </span><br><span class="line">   if(nil != (self = [super init]))</span><br><span class="line">   &#123;</span><br><span class="line">      stride = aStride;</span><br><span class="line">      bufferSizeBytes = stride * count;</span><br><span class="line">      </span><br><span class="line">      glGenBuffers(1,                // STEP 1</span><br><span class="line">         &amp;name);</span><br><span class="line">      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class="line">         self.name); </span><br><span class="line">      glBufferData(                  // STEP 3</span><br><span class="line">         GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class="line">         bufferSizeBytes,  // Number of bytes to copy</span><br><span class="line">         dataPtr,          // Address of bytes to copy</span><br><span class="line">         usage);           // Hint: cache in GPU memory</span><br><span class="line">         </span><br><span class="line">      NSAssert(0 != name, @&quot;Failed to generate name&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>glGenBuffers()创建缓存对象并且返回缓存对象的标示符。它需要2个参数：第一个为需要创建的缓存数量，第二个为用于存储单一ID或多个ID的GLuint变量或数组的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void glGenBuffers(GLsizei n, GLuint *buffers);</span><br><span class="line">//在buffers数组中返回当前n个未使用的名称，表示缓冲区对象</span><br><span class="line">GLboolean glIsBuffer(GLuint buffer);</span><br><span class="line">//判断是否是缓冲区对象</span><br></pre></td></tr></table></figure>
<ul>
<li>glBindBuffer  </li>
</ul>
<p>当缓存对象创建之后，在使用缓存对象之前，我们需要将缓存对象连接到相应的缓存上。<br>glBindBuffer()有2个参数：target与buffer。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glBindBuffer(GLenum target, GLuint buffer)</span><br></pre></td></tr></table></figure>
<p>target告诉顶点缓存对象(VBO)该缓存对象将保存顶点数组数据还是索引数组数据：GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。任何顶点属性，如顶点坐标、纹理坐标、法线与颜色分量数组都使用GL_ARRAY_BUFFER。用于glDraw[Range]Elements()的索引数据需要使用GL_ELEMENT_ARRAY绑定。注意，target标志帮助VBO确定缓存对象最有效的位置，如有些系统将索引保存AGP或系统内存中，将顶点保存在显卡内存中。<br>当第一次调用glBindBuffer()，VBO用0大小的内存缓存初始化该缓存，并且设置VBO的初始状态，如用途与访问属性。</p>
<ul>
<li>glBufferData   </li>
</ul>
<p>当缓存初始化之后，你可以使用glBufferData()将数据拷贝到缓存对象。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glBufferData(GLenum target，GLsizeiptr size, const GLvoid* data, GLenum usage);</span><br></pre></td></tr></table></figure>
<p>第一个参数target可以为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。size为待传递数据字节数量。第三个参数为源数据数组指针，如data为NULL，则VBO仅仅预留给定数据大小的内存空间。最后一个参数usage标志位VBO的另一个性能提示，它提供缓存对象将如何使用：static、dynamic或stream、与read、copy或draw。<br>VBO为usage标志指定9个枚举值：<br>GL_STATIC_DRAW<br>GL_STATIC_READ<br>GL_STATIC_COPY<br>GL_DYNAMIC_DRAW<br>GL_DYNAMIC_READ<br>GL_DYNAMIC_COPY<br>GL_STREAM_DRAW<br>GL_STREAM_READ<br>GL_STREAM_COPY<br>”static“表示VBO中的数据将不会被改动（一次指定多次使用），”dynamic“表示数据将会被频繁改动（反复指定与使用），”stream“表示每帧数据都要改变（一次指定一次使用）。”draw“表示数据将被发送到GPU以待绘制（应用程序到GL），”read“表示数据将被客户端程序读取（GL到应用程序），”copy“表示数据可用于绘制与读取（GL到GL）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// A vertex attribute array buffer must be prepared when your </span><br><span class="line">// application wants to use the buffer to render any geometry. </span><br><span class="line">// When your application prepares an buffer, some OpenGL ES state</span><br><span class="line">// is altered to allow bind the buffer and configure pointers.</span><br><span class="line">- (void)prepareToDrawWithAttrib:(GLuint)index</span><br><span class="line">   numberOfCoordinates:(GLint)count</span><br><span class="line">   attribOffset:(GLsizeiptr)offset</span><br><span class="line">   shouldEnable:(BOOL)shouldEnable</span><br><span class="line">&#123;</span><br><span class="line">   NSParameterAssert((0 &lt; count) &amp;&amp; (count &lt; 4));</span><br><span class="line">   NSParameterAssert(offset &lt; self.stride);</span><br><span class="line">   NSAssert(0 != name, @&quot;Invalid name&quot;);</span><br><span class="line">	</span><br><span class="line">   glBindBuffer(GL_ARRAY_BUFFER,     // STEP 2</span><br><span class="line">      self.name);</span><br><span class="line">	</span><br><span class="line">   if(shouldEnable)</span><br><span class="line">   &#123;</span><br><span class="line">      glEnableVertexAttribArray(     // Step 4</span><br><span class="line">         index); </span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   glVertexAttribPointer(            // Step 5</span><br><span class="line">      index,               // Identifies the attribute to use</span><br><span class="line">      count,               // number of coordinates for attribute</span><br><span class="line">      GL_FLOAT,            // data is floating point</span><br><span class="line">      GL_FALSE,            // no fixed point scaling</span><br><span class="line">      (self.stride),       // total num bytes stored per vertex</span><br><span class="line">      NULL + offset);      // offset from start of each vertex to </span><br><span class="line">                           // first coord for attribute</span><br><span class="line">	#ifdef DEBUG</span><br><span class="line">	   &#123;  // Report any errors </span><br><span class="line">	      GLenum error = glGetError();</span><br><span class="line">	      if(GL_NO_ERROR != error)</span><br><span class="line">	      &#123;</span><br><span class="line">	         NSLog(@&quot;GL Error: 0x%x&quot;, error);</span><br><span class="line">	      &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">	#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>glEnableVertexAttribArray    </li>
</ul>
<p>第4步和第5步理解起来有点困难，暂时放下，之后研究OpenGL的时候细研究，这里给出原书中的摘录；</p>
<blockquote>
<p>在第4步中，通过调用glEnableVertexAttribArray()来启动顶点缓存渲染操作；OpenGLES所支持的每一个渲染操作都可以单独地使用保存在当前OpenGLES上下文中的设置来开启或关闭。<br>在第5步中，glVertexAttribPointer()告诉OpenGLES顶点数据在哪里，以及怎么解释为每个顶点保存的数据。第一个参数指示当前绑定的缓存包含每个顶点的位置信息；第二个参数指示每个位置有3个部分；第三个参数告诉OpenGLES每个部分都保存为一个浮点类型的值；第四个参数告诉OpenGLES小数点固定数据是否可以被改变；第五个参数叫做“步幅”，它指定了每个顶点的保存需要多少个字节，换句话说，步幅指定了GPU从一个顶点的内存开始位置转到下一个顶点的内存开始位置需要跳过多少字节,sizeof(GLKVector3)指示在缓存中没有额外的字节，即顶点位置数据是密封的，在一个顶点缓存中保存除了每个顶点位置的X Y Z坐标之外的其他数据也是可能的；</p>
</blockquote>
<ul>
<li>glVertexAttribPointer </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer);</span><br></pre></td></tr></table></figure>
<p>参数：<br><em>index</em><br>指定要修改的顶点属性的索引值<br><em>size</em><br>指定每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a））<br><em>type</em><br>指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。<br><em>normalized</em><br>指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）。<br><em>stride</em><br>指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0。<br><em>pointer</em><br>指定第一个组件在数组的第一个顶点属性中的偏移量。该数组与GL_ARRAY_BUFFER绑定，储存于缓冲区中。初始值为0；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Submits the drawing command identified by mode and instructs</span><br><span class="line">// OpenGL ES to use count vertices from the buffer starting from</span><br><span class="line">// the vertex at index first. Vertex indices start at 0.</span><br><span class="line">- (void)drawArrayWithMode:(GLenum)mode</span><br><span class="line">   startVertexIndex:(GLint)first</span><br><span class="line">   numberOfVertices:(GLsizei)count</span><br><span class="line">&#123;</span><br><span class="line">   NSAssert(self.bufferSizeBytes &gt;= </span><br><span class="line">      ((first + count) * self.stride),</span><br><span class="line">      @&quot;Attempt to draw more vertex data than available.&quot;);</span><br><span class="line">      </span><br><span class="line">   glDrawArrays(mode, first, count); // Step 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>glDrawArrays</li>
</ul>
<p>glDrawArrays()第一个参数会告诉GPU怎么处理在绑定的顶点缓存内的顶点数据；第二个参数和第三个参数分别指定缓存内的需要渲染的第一个顶点的位置和需要渲染的顶点的数量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// This method deletes the receiver&apos;s buffer from the current</span><br><span class="line">// Context when the receiver is deallocated.</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    // Delete buffer from current context</span><br><span class="line">    if (0 != name)</span><br><span class="line">    &#123;</span><br><span class="line">        glDeleteBuffers(1, &amp;name); // Step 7 </span><br><span class="line">        name = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>glDeleteBuffers</li>
</ul>
<p>删除不需再需要的顶点缓存和上下文，该方法保证Cocoa Touch收回上下文使用的内存和其他资源。</p>
<p><a href="https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_2_GL/OpenGLES_Ch2_3" target="_blank" rel="noopener">本例的代码下载链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/05/07/GLKView是如何工作的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/07/GLKView是如何工作的/" itemprop="url">GLKView是如何工作的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-07T01:04:00+08:00">
                2016-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary: 本篇通过一个AGLKView的示例来深入了解一下上篇中GLKView的工作原理，目的是为了消除GLKView、Core Animation、OpenGLES间交互的神秘感；</p>
<p>本篇通过一个AGLKView的示例来深入了解一下上篇中GLKView的工作原理，目的是为了消除GLKView、Core Animation、OpenGLES间交互的神秘感；<br>本例位于<a href="https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch2_2" target="_blank" rel="noopener">点击此处下载本文例子</a>，建议将例子下下来，边看本文解析，边自己实现该例子；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">   return [CAEAGLLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个UIView都有一个相关联的Core Animation层；Cocoa Touch会调用该方法决定生成一个什么样的层;<br>CAEAGLLayer会与一个OGE帧缓存共享它的像素仓库；CAEAGLLayer是Core Animation提供的标准层之一；</p>
<blockquote>
<p>串行化(Serialization)是计算机科学中的一个概念，它是指将对象存储到介质（如文件、内存缓冲区等）中或是以二进制方式通过网络传输，在iOS中也叫做归档。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder*)coder</span><br><span class="line">&#123;    </span><br><span class="line">   if ((self = [super initWithCoder:coder]))</span><br><span class="line">   &#123;</span><br><span class="line">      CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;      </span><br><span class="line">      eaglLayer.drawableProperties = </span><br><span class="line">         [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class="line">             [NSNumber numberWithBool:NO], </span><br><span class="line">             kEAGLDrawablePropertyRetainedBacking, </span><br><span class="line">             kEAGLColorFormatRGBA8, </span><br><span class="line">             kEAGLDrawablePropertyColorFormat, </span><br><span class="line">             nil];          </span><br><span class="line">   &#125;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是Cocoa Touch用于初始化对象的标准方法之一，Cocoa Touch会自动调用该方法，这是反归档先前归档入一个文件的对象过程的一部分；本例中AGLKView从storyboard文件中加载过程就是反归档；若用代码的话应该是调用<em>“-initWithFrame:context:”</em>方法；<br>在这两个方法中，kEAGLDrawablePropertyRetainedBacking == NO 表示不使用保留背景，告诉Core Animation层任何部分需要在屏幕上显示的时候都需要绘制整个层的内容；kEAGLColorFormatRGBA8 使用8位来保存每个像素每个颜色的值；这段代码告诉Core Animation不要试图保留任何以前绘制的图像留作以后重用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// This method sets the receiver&apos;s OpenGL ES Context. If the </span><br><span class="line">// receiver already has a different Context, this method deletes</span><br><span class="line">// OpenGL ES Frame Buffer resources in the old Context and the </span><br><span class="line">// recreates them in the new Context.</span><br><span class="line">- (void)setContext:(EAGLContext *)aContext</span><br><span class="line">&#123;</span><br><span class="line">   if(context != aContext)</span><br><span class="line">   &#123;  // Delete any buffers previously created in old Context</span><br><span class="line">      [EAGLContext setCurrentContext:context];</span><br><span class="line">      </span><br><span class="line">      if (0 != defaultFrameBuffer)</span><br><span class="line">      &#123;</span><br><span class="line">         glDeleteFramebuffers(1, &amp;defaultFrameBuffer); // Step 7</span><br><span class="line">         defaultFrameBuffer = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (0 != colorRenderBuffer)</span><br><span class="line">      &#123;</span><br><span class="line">         glDeleteRenderbuffers(1, &amp;colorRenderBuffer); // Step 7</span><br><span class="line">         colorRenderBuffer = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (0 != depthRenderBuffer)</span><br><span class="line">      &#123;</span><br><span class="line">         glDeleteRenderbuffers(1, &amp;depthRenderBuffer); // Step 7</span><br><span class="line">         depthRenderBuffer = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      context = aContext;</span><br><span class="line">   </span><br><span class="line">      if(nil != context)</span><br><span class="line">      &#123;  // Configure the new Context with required buffers</span><br><span class="line">         context = aContext;</span><br><span class="line">         [EAGLContext setCurrentContext:context];</span><br><span class="line">                   </span><br><span class="line">         glGenFramebuffers(1, &amp;defaultFrameBuffer);    // Step 1</span><br><span class="line">         glBindFramebuffer(                            // Step 2</span><br><span class="line">            GL_FRAMEBUFFER,             </span><br><span class="line">            defaultFrameBuffer);</span><br><span class="line"></span><br><span class="line">         glGenRenderbuffers(1, &amp;colorRenderBuffer);    // Step 1</span><br><span class="line">         glBindRenderbuffer(                           // Step 2</span><br><span class="line">            GL_RENDERBUFFER, </span><br><span class="line">            colorRenderBuffer);</span><br><span class="line">         </span><br><span class="line">         // Attach color render buffer to bound Frame Buffer</span><br><span class="line">         glFramebufferRenderbuffer(</span><br><span class="line">            GL_FRAMEBUFFER, </span><br><span class="line">            GL_COLOR_ATTACHMENT0, </span><br><span class="line">            GL_RENDERBUFFER, </span><br><span class="line">            colorRenderBuffer);</span><br><span class="line"></span><br><span class="line">         // Create any additional render buffers based on the</span><br><span class="line">         // drawable size of defaultFrameBuffer</span><br><span class="line">         [self layoutSubviews];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改视图的上下文会导致先前创建的所有缓存全部失效，需要配置新的缓存；glFramebufferRenderbuffer()用来配置当前绑定的帧缓存以便在colorRenderBuffer中保存渲染的像素颜色；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Calling this method tells the receiver to redraw the contents </span><br><span class="line">// of its associated OpenGL ES Frame Buffer. This method </span><br><span class="line">// configures OpenGL ES and then calls -drawRect:</span><br><span class="line">- (void)display</span><br><span class="line">&#123;</span><br><span class="line">   [EAGLContext setCurrentContext:self.context];</span><br><span class="line">   glViewport(0, 0, (GLint)self.drawableWidth, (GLint)self.drawableHeight);</span><br><span class="line"></span><br><span class="line">   [self drawRect:[self bounds]];</span><br><span class="line">   </span><br><span class="line">   [self.context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This method is called automatically whenever the receiver</span><br><span class="line">// needs to redraw the contents of its associated OpenGL ES</span><br><span class="line">// Frame Buffer. This method should not be called directly. Call</span><br><span class="line">// -display instead which configures OpenGL ES before calling</span><br><span class="line">// -drawRect:</span><br><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">   if(delegate)</span><br><span class="line">   &#123;</span><br><span class="line">      [self.delegate glkView:self drawInRect:[self bounds]];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置视图的上下文为当前上下文，告诉OGE让渲染填满整个帧缓存，调用“-drawRect:”进行真正给图，然后让上下文调整外观使用Core Animation合成器把帧缓存的像素颜色渲染缓存与其他相关层混合起来；<br>glViewport()可以控制渲染至帧缓存的子集；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">   CAEAGLLayer 	*eaglLayer = (CAEAGLLayer *)self.layer;</span><br><span class="line">   </span><br><span class="line">   // Make sure our context is current</span><br><span class="line">   [EAGLContext setCurrentContext:self.context];</span><br><span class="line"></span><br><span class="line">   // Initialize the current Frame Buffer’s pixel color buffer </span><br><span class="line">   // so that it shares the corresponding Core Animation Layer’s</span><br><span class="line">   // pixel color storage.</span><br><span class="line">   [self.context renderbufferStorage:GL_RENDERBUFFER </span><br><span class="line">      fromDrawable:eaglLayer];</span><br><span class="line">      </span><br><span class="line">   </span><br><span class="line">   if (0 != depthRenderBuffer)</span><br><span class="line">   &#123;</span><br><span class="line">      glDeleteRenderbuffers(1, &amp;depthRenderBuffer); // Step 7</span><br><span class="line">      depthRenderBuffer = 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   GLint currentDrawableWidth = (GLint)self.drawableWidth;</span><br><span class="line">   GLint currentDrawableHeight = (GLint)self.drawableHeight;</span><br><span class="line">   </span><br><span class="line">   if(self.drawableDepthFormat != </span><br><span class="line">      AGLKViewDrawableDepthFormatNone &amp;&amp;</span><br><span class="line">      0 &lt; currentDrawableWidth &amp;&amp;</span><br><span class="line">      0 &lt; currentDrawableHeight)</span><br><span class="line">   &#123;</span><br><span class="line">      glGenRenderbuffers(1, &amp;depthRenderBuffer); // Step 1</span><br><span class="line">      glBindRenderbuffer(GL_RENDERBUFFER,        // Step 2</span><br><span class="line">         depthRenderBuffer);</span><br><span class="line">      glRenderbufferStorage(GL_RENDERBUFFER,     // Step 3 </span><br><span class="line">         GL_DEPTH_COMPONENT16, </span><br><span class="line">         currentDrawableWidth, </span><br><span class="line">         currentDrawableHeight);</span><br><span class="line">      glFramebufferRenderbuffer(GL_FRAMEBUFFER,  // Step 4 </span><br><span class="line">         GL_DEPTH_ATTACHMENT, </span><br><span class="line">         GL_RENDERBUFFER, </span><br><span class="line">         depthRenderBuffer);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // Check for any errors configuring the render buffer   </span><br><span class="line">   GLenum status = glCheckFramebufferStatus(</span><br><span class="line">      GL_FRAMEBUFFER) ;</span><br><span class="line">     </span><br><span class="line">   if(status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">       NSLog(@&quot;failed to make complete frame buffer object %x&quot;, status);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Make the Color Render Buffer the current buffer for display</span><br><span class="line">   glBindRenderbuffer(GL_RENDERBUFFER, colorRenderBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何在接收到重新调整大小的消息时，Cocoa Touch都会调用下面的layoutSubviews；上下文的”renderbufferStorage:fromDrawable”方法会调整视图的缓存尺寸以匹配层的新尺寸；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// This method returns the width in pixels of current context&apos;s</span><br><span class="line">// Pixel Color Render Buffer</span><br><span class="line">- (NSInteger)drawableWidth;</span><br><span class="line">&#123;</span><br><span class="line">   GLint          backingWidth;</span><br><span class="line"></span><br><span class="line">   glGetRenderbufferParameteriv(</span><br><span class="line">      GL_RENDERBUFFER, </span><br><span class="line">      GL_RENDERBUFFER_WIDTH, </span><br><span class="line">      &amp;backingWidth);</span><br><span class="line">      </span><br><span class="line">   return (NSInteger)backingWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/////////////////////////////////////////////////////////////////</span><br><span class="line">// This method returns the height in pixels of current context&apos;s</span><br><span class="line">// Pixel Color Render Buffer</span><br><span class="line">- (NSInteger)drawableHeight;</span><br><span class="line">&#123;</span><br><span class="line">   GLint          backingHeight;</span><br><span class="line"></span><br><span class="line">   glGetRenderbufferParameteriv(</span><br><span class="line">      GL_RENDERBUFFER, </span><br><span class="line">      GL_RENDERBUFFER_HEIGHT, </span><br><span class="line">      &amp;backingHeight);</span><br><span class="line">      </span><br><span class="line">   return (NSInteger)backingHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过OpenGLES的glGetRenderbufferParameteriv()方法获取和返回当前上下文的帧缓存的像素颜色渲染缓存尺寸;</p>
<p>接下来要说说<em>AGLKViewController</em>,它使用一个CADisplayLink对象来调度和执行与控制器相关联的视力的周期性的重绘；<br>CADisplayLink本质上是一个用于显示更新的同步计时器，它能够被设置用来在每个显示更新或者其他更新时发送一个消息；<br>显示更新频率通常是由嵌入设备硬件决定的，它代表一个帧缓存的内容每秒最多能够被在屏幕上通过的像素显示出来的次数；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/05/06/Python抓取One网页上的内容/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/Python抓取One网页上的内容/" itemprop="url">Python抓取One网页上的内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-06T16:46:00+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary: 本文是从微信推送内容中摘取下来的，其中某些内容进行了小的改动，本文作者在Mac 10.11.4下运行正常，脚本会存取网页上的内容并保存到本地txt文件中，文件中内容以json格式保存。</p>
<h1 id="1-python环境搭建"><a href="#1-python环境搭建" class="headerlink" title="1.python环境搭建"></a>1.python环境搭建</h1><h2 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h2><p><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><p>首先安装easy_install</p>
<p><code>curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python</code></p>
<p>接着</p>
<p><code>sudo easy_install pip</code></p>
<h2 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h2><p><code>pip install virtualenv</code></p>
<h2 id="安装request和beautifulsoup4"><a href="#安装request和beautifulsoup4" class="headerlink" title="安装request和beautifulsoup4"></a>安装request和beautifulsoup4</h2><p><code>pip install requests beautifulsoup4</code></p>
<h1 id="2-网页分析"><a href="#2-网页分析" class="headerlink" title="2.网页分析"></a>2.网页分析</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5ODUzOTA0OQ==&amp;mid=2651688023&amp;idx=1&amp;sn=ce865e87c60777c52ff60c2381c1a353&amp;scene=1&amp;srcid=0505caJlTtmQucm6toGF6Qiw&amp;key=b28b03434249256bfa726a59c0a981ca91726f8ece7ac2a4e4552ba24a316f23dd587233818175463c02bedea86bb34d&amp;ascene=0&amp;uin=MjA4NjU4OTk1&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.4+build(15E65" target="_blank" rel="noopener">请移步源网址，本文参考原文</a>&amp;version=11020201&amp;pass_ticket=EVsyFUgOaslYvrzF%2Bee4tQMk2jt%2F5PtB04iRB0X4XzE%3D)</p>
<h1 id="3-python编码"><a href="#3-python编码" class="headerlink" title="3.python编码"></a>3.python编码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">root_url = <span class="string">'http://wufazhuce.com'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(num)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> root_url+<span class="string">'/one/'</span>+str(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_urls</span><span class="params">(num)</span>:</span></span><br><span class="line">	urls = map(get_url,range(<span class="number">100</span>,<span class="number">100</span>+num))</span><br><span class="line">	<span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(url)</span>:</span></span><br><span class="line">	dataList = &#123;&#125;</span><br><span class="line">	response = requests.get(url)</span><br><span class="line">	<span class="keyword">if</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="string">'noValue'</span>:<span class="string">'noValue'</span>&#125;</span><br><span class="line">	soup = bs4.BeautifulSoup(response.text,<span class="string">'html.parser'</span>)</span><br><span class="line">	<span class="keyword">print</span> soup.title.string</span><br><span class="line">	dataList[<span class="string">'index'</span>] = soup.title.string[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">	<span class="keyword">for</span> meta <span class="keyword">in</span> soup.select(<span class="string">'meta'</span>):</span><br><span class="line">		<span class="keyword">if</span> meta.get(<span class="string">'name'</span>) == <span class="string">'description'</span>:</span><br><span class="line">			dataList[<span class="string">'content'</span>] = meta.get(<span class="string">'content'</span>)</span><br><span class="line">		dataList[<span class="string">'imgUrl'</span>] = soup.find_all(<span class="string">'img'</span>)[<span class="number">1</span>][<span class="string">'src'</span>]</span><br><span class="line">	<span class="keyword">return</span> dataList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	pool = Pool(<span class="number">4</span>)</span><br><span class="line">	dataList = []</span><br><span class="line">	urls = get_urls(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	start = time.time()</span><br><span class="line">	dataList = pool.map(get_data,urls)</span><br><span class="line">	end = time.time()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'use:%.2f s'</span>%(end-start)</span><br><span class="line">	jsonData = json.dumps(&#123;<span class="string">'data'</span>:dataList&#125;)</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">'data.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">		json.dump(jsonData,outfile)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/04/27/Mac下Android Studio环境搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/27/Mac下Android Studio环境搭建/" itemprop="url">Mac下Android Studio环境搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-27T08:25:00+08:00">
                2016-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇还原了本人在Macbook pro上安装Android Studio2.0的过程，安装环境是OS X EI Capitan 10.11.4；</p>
<p>下载Java SDK包，Android Studio安装包，android SDK包，这些资源在<a href="http://www.android-studio.org/index.php/download这个网站上都可以找到；" target="_blank" rel="noopener">http://www.android-studio.org/index.php/download这个网站上都可以找到；</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-80f5a33c449dec04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网站标题"></p>
<p>首先安装Java SDK包，这个安装的时候比较容易，直接双击点开的包就可以了；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-be1726d680728df3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JDK"></p>
<p>安装Android Studio，打开安装包装包拖入到自己Applications中，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-ec89f55cd82937b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDK"></p>
<p>安装完成后双击，它会提示你要不要打开，这个时候先不要打开，在Applications中右击显示包内容，在Contents/bin下打开idea.properties文件，在文件末尾添加一行：</p>
<p><code>disable.android.first.run=true</code></p>
<p>这是因为Android Studio会去获取 android sdk 组件信息，这个过程相当慢，还经常加载失败，导致Android Studio启动不起开。解决办法就是不去获取android sdk 组件信息。这个慢的原因，是因为android网站被墙了，必须翻墙才能访问到！所以如果你的电脑已经翻墙了，那么完全可以跳过这一步。</p>
<p>接下来点打开，如果是先打开后修改的话它会提示你的包已经损坏，并让你删除；</p>
<p>然后就是配置android SDK的目录了，我们把下载下来的包放到一个不经常修改的目录下，然后记住它的目录，我的是</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-76fee3c672cffe2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDK放在这里"></p>
<p>Android SDK Location就写你的SDK放置的路径，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-a4f081f44e57151c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>然后点Next就可以了，点完之后电脑会反应一会，时间会比较长，不要以为它什么都没有在干，等一会就好了。</p>
<p>下一步我们来安装SDK，进入到设置好的SDK目录下，使用命令行进入tools目录，输入<code>./android sdk</code>请出SDK Manager图形界面，点击顶部菜单栏Android SDK Manager -&gt; Preferences…</p>
<p>进入配置页面，http proxy server这里填写： mirrors.neusoft.edu.cn （感谢东软搭建国内的镜像服务器，为广大程序员造福无数），如果以上填写的不能下载，也可以试着填写mirrors.opencas.ac.cn（这个也是从网上找的，感谢这些人的贡献）</p>
<p>端口填写80，然后把Force https:// 前的勾勾上，然后点击mac顶部菜单Tools-&gt;Manage Add-on Site，把下面这堆网址：</p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/addon-6.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/addon-6.xml</a></p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/addon.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/addon.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml</a> </p>
<p><a href="http://mirrors.neusoft.edu.cn/android/repository/repository-10.xml" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/android/repository/repository-10.xml</a></p>
<p>全手动New加进去，然后就可以下载了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-769d654f67efd23f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>接下来点击安装，下面是我安装过程中截的图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1429775-08a78264896a3537?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="等待良人归来那一秒。。。"></p>
<p>接下来，你需要的是漫长的等待。。。。。。</p>
<p>你的Android Studio就安装完成了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2016/03/01/开始OpenGLES的探索/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/01/开始OpenGLES的探索/" itemprop="url">开始OpenGLES的探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-01T10:20:00+08:00">
                2016-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary: 本系列文章是学习《OpenGL ES应用开发实践指南 iOS卷》的过程，学习过程中参照书中给出的例子运行并记录笔记，此篇是开篇，书中的例子可以从本文给出的地址下载。</p>
<p>##先介绍几个概念：</p>
<blockquote>
<p>渲染：用3D数据生成一个2D图像的过程就叫做渲染；</p>
<p>像素：计算机显示矩形的颜色点叫做像素；</p>
<p>缓存：是指图形处理器能够控制和管理的连续RAM（原来就是内存）；</p>
<p>帧缓存：内存中接收2D结果数据的缓冲区；</p>
<p>上下文：是用于配置OpenGL ES的特定的软件平台的数据结构信息；</p>
</blockquote>
<p>##开始我们的OGE之旅：</p>
<p>首先是添加两个框架，一个是用于调用OpenGL ES进行渲染的<strong>OpenGLES.framework</strong>，另外一个是用于对接iOS系统和OpenGLES的<strong>GLKit.framework</strong>，后者开放了一套方便OpenGLES环境设置的接口，方便iOS程序进行OpenGLES编程；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface OpenGLESViewController : GLKViewController</span><br><span class="line">&#123;</span><br><span class="line">   GLuint vertexBufferID; //该值实际上是一个无符号整形，看名字可以看的出来</span><br><span class="line">&#125;</span><br><span class="line">@property (strong, nonatomic) GLKBaseEffect *baseEffect;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>下面这个结构体用来保存一个坐标，它是一个起始于坐标系原点的矢量（X,Y,Z）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//This data type is used to store information for each vertex</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    GLKVector3  positionCoords;</span><br><span class="line">&#125;SceneVertex;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//用来定义三角形，以下空白部分是最后在屏幕上显示的结果，纯属娱乐</span><br><span class="line">/*</span><br><span class="line"> *************</span><br><span class="line"> **** ********</span><br><span class="line"> ****  *******</span><br><span class="line"> ****   ******</span><br><span class="line"> ****    *****</span><br><span class="line"> ****     ****</span><br><span class="line"> *************</span><br><span class="line"> *************</span><br><span class="line">*/</span><br><span class="line">// Define vertex data for a triangle to use in example</span><br><span class="line">static const SceneVertex vertices[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;&#123;-0.5f, -0.5f, 0.0&#125;&#125;, // lower left corner</span><br><span class="line">    &#123;&#123; 0.5f, -0.5f, 0.0&#125;&#125;, // lower right corner</span><br><span class="line">    &#123;&#123;-0.5f,  0.5f, 0.0&#125;&#125;  // upper left corner</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>##viewDidLoad</p>
<p>先要将Controller的view强制转换成GLKView，GLKView提供了针对OpenGLES2.0版本的上下文，新建该类的上下文并将它设置为当前的上下文；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Verify the type of view created automatically by the</span><br><span class="line">// Interface Builder storyboard</span><br><span class="line">GLKView *view = (GLKView *)self.view;</span><br><span class="line">NSAssert([view isKindOfClass:[GLKView class]],</span><br><span class="line">   		   @&quot;View controller&apos;s view is not a GLKView&quot;);</span><br></pre></td></tr></table></figure>
<p>OpenGL ES的上下文不仅会保存它的状态，还会控制GPU去执行渲染运算,EAGLContext会封装一个特定于某个平台的上下文，一个应用可以使用多个上下文;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Create an OpenGL ES 2.0 context and provide it to the</span><br><span class="line">// view</span><br><span class="line">view.context = [[EAGLContext alloc]</span><br><span class="line">					initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line"></span><br><span class="line">//设置成当前上下文</span><br><span class="line">// Make the new context current</span><br><span class="line">[EAGLContext setCurrentContext:view.context];</span><br></pre></td></tr></table></figure>
<p>GLKBaseEffect类提供了不依赖OGE版本的渲染方法，它会在需要的时候自动构建一个GPU程序,该实例使用恒定不变的白色来渲染像素;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class="line">self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class="line">self.baseEffect.constantColor = GLKVector4Make(</span><br><span class="line">								     1.0f, // Red</span><br><span class="line">								     1.0f, // Green</span><br><span class="line">								     1.0f, // Blue</span><br><span class="line">								     1.0f);// Alpha</span><br><span class="line">//设置当前OGE上下文为不透明黑色，该黑色由RGBA颜色元素值组成，用于在上下文帧缓存被清除时对每个像素进行初始化</span><br><span class="line">glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // background color</span><br></pre></td></tr></table></figure>
<p>以下代码用于定义三角形的数据必须要发送到GPU来进行渲染，创建三角形数据数组缓存的前三个步骤，对应以下步骤：</p>
<p>1.为缓存生成一个唯一的标志符；</p>
<p>2.为运算绑定缓存；</p>
<p>3.复制数据到缓存；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Generate, bind, and initialize contents of a buffer to be</span><br><span class="line">// stored in GPU memory</span><br><span class="line">glGenBuffers(1,                // STEP 1</span><br><span class="line">      &amp;vertexBufferID);</span><br><span class="line">NSLog(@&quot;vertexBufferID = %p&quot;,vertexBufferID);</span><br><span class="line">//该结果是一个指针，指向所生成标志符的内存保存位置；</span><br><span class="line">//缓存标志符在文档中叫做 &quot;names&quot;</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class="line">      vertexBufferID);</span><br><span class="line">//保存不同类型的标志符到OGE的不同位置，同一时刻只能绑定一个缓存，即使它们是相同类型的；</span><br><span class="line">//OpenGLES2.0只支持绑定两种类型，GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER；</span><br><span class="line"></span><br><span class="line">glBufferData(                  // STEP 3</span><br><span class="line">      GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class="line">      sizeof(vertices), // Number of bytes to copy</span><br><span class="line">      vertices,         // Address of bytes to copy</span><br><span class="line">      GL_STATIC_DRAW);  // Hint: cache in GPU memory</span><br><span class="line">//第四个参数提示缓存在未来运算中可能会被怎样使用</span><br><span class="line">//GL_STATIC_DRAW 提示缓存内容适合复制到内存中，而很少对其进行修改；</span><br><span class="line">//GL_DYNAMIC_DRAW 缓存数据会频繁改变，提示OGE上下文用不同方式处理</span><br></pre></td></tr></table></figure>
<p>##glkView:drawInRect:</p>
<p>每当一个GLKView需要重绘时，保存在视图中的上下文都会成为当前上下文；如需要，它还会保存一个来自Core Animation层的帧缓存，并调用下面的方法；</p>
<p>此处接上面使用缓存的前三步；</p>
<p>4.启动；</p>
<p>5.设置指针；</p>
<p>6.绘图；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line"></span><br><span class="line">    // Clear Frame Buffer (erase previous drawing)</span><br><span class="line">    //它的值是前面glClearColor()设置的；</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // Enable use of positions from bound vertex buffer</span><br><span class="line">    glEnableVertexAttribArray(      // STEP 4</span><br><span class="line">      GLKVertexAttribPosition);</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(          // STEP 5</span><br><span class="line">      GLKVertexAttribPosition,</span><br><span class="line">      3,                   // three components per vertex</span><br><span class="line">      GL_FLOAT,            // data is floating point</span><br><span class="line">      GL_FALSE,            // no fixed point scaling</span><br><span class="line">      sizeof(SceneVertex), // no gaps in data</span><br><span class="line">      NULL);               // NULL tells GPU to start at</span><br><span class="line">                           // beginning of bound buffer</span><br><span class="line"></span><br><span class="line">    // Draw triangles using the first three vertices in the</span><br><span class="line">    // currently bound vertex buffer</span><br><span class="line">    glDrawArrays(GL_TRIANGLES,      // STEP 6</span><br><span class="line">     		 0,  // Start with first vertex in currently bound buffer</span><br><span class="line">     		 3); // Use three vertices from currently bound buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>glDrawArrays函数调用完成，此时所需要显示的场景已经完全显示或者GPU处理完成后会完全显示;</p>
<p>CPU运算和GPU运算是异步的，这个例子的所有代码都是运行在CPU上的，需要进一步处理时会向GPU发送命令；GPU可能也会处理Core Animation层的命令，所以GPU总执行次数不一定；</p>
<p>##viewDidUnload</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidUnload</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidUnload];</span><br><span class="line"></span><br><span class="line">    // Make the view&apos;s context current</span><br><span class="line">    GLKView *view = (GLKView *)self.view;</span><br><span class="line">    [EAGLContext setCurrentContext:view.context];</span><br><span class="line"></span><br><span class="line">    // Delete buffers that aren&apos;t needed when view is unloaded</span><br><span class="line">    if (0 != vertexBufferID)</span><br><span class="line">    &#123;</span><br><span class="line">       glDeleteBuffers (1,          // STEP 7</span><br><span class="line">                        &amp;vertexBufferID);</span><br><span class="line">       vertexBufferID = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Stop using the context created in -viewDidLoad</span><br><span class="line">    ((GLKView *)self.view).context = nil;</span><br><span class="line">    [EAGLContext setCurrentContext:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch_2_1" target="_blank" rel="noopener">点击此处下载本文例子</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://uwuneng.com/2015/12/11/Python-pelican搭建个人博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Charles">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NOTHING">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/11/Python-pelican搭建个人博客/" itemprop="url">Python-pelican搭建个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-11T09:23:00+08:00">
                2015-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coder/" itemprop="url" rel="index">
                    <span itemprop="name">coder</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Summary:  本文使用python pelican搭建个人静态博客，并上传到个人git仓库，实现访问个人博客，本文作者所用就是基于该博客的个人主页。</p>
<blockquote>
<p>PS：提升到系统root权限：$ sudo -s；</p>
</blockquote>
<h3 id="1-安装git；"><a href="#1-安装git；" class="headerlink" title="1.安装git；"></a>1.安装git；</h3><h3 id="2-安装pip过程："><a href="#2-安装pip过程：" class="headerlink" title="2.安装pip过程："></a>2.安装pip过程：</h3><p>查看pythion安装目录：<br><code>$ which python</code><br>/usr/local/bin/python<br>安装pip:<br><code>$ sudo easy_install pip</code><br>第一次输入时出现无法安装，则可以选择进行下面的安装；<br>安装最新版本的python,pip&amp;setuptools:<br><code>$ brew install python</code></p>
<blockquote>
<p>PS:brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，只需要一个命令,非常方便brew类似ubuntu系统下的apt-get的功能,<a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a> 安装方法如下：<code>$ ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</code></p>
</blockquote>
<p>详细请见：<a href="http://www.cnblogs.com/TankXiao/p/3247113.html" target="_blank" rel="noopener">http://www.cnblogs.com/TankXiao/p/3247113.html</a></p>
<h3 id="3-安装virtualenv"><a href="#3-安装virtualenv" class="headerlink" title="3.安装virtualenv:"></a>3.安装virtualenv:</h3><p><code>$ pip install virtualenv</code></p>
<h3 id="4-创建虚拟环境："><a href="#4-创建虚拟环境：" class="headerlink" title="4.创建虚拟环境："></a>4.创建虚拟环境：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv ~/virtualenv/pelican</span><br><span class="line">$ cd ~/virtualenvs/pelican</span><br><span class="line">$ source bin/activate</span><br></pre></td></tr></table></figure>
<h3 id="5-安装pelican："><a href="#5-安装pelican：" class="headerlink" title="5.安装pelican："></a>5.安装pelican：</h3><p><code>$ pip install pelican</code></p>
<h3 id="6-安装markdown-typogrify："><a href="#6-安装markdown-typogrify：" class="headerlink" title="6.安装markdown,typogrify："></a>6.安装markdown,typogrify：</h3><p><code>$ pip install markdown</code><br><code>$ pip install typogrify</code></p>
<h3 id="7-创建博客站点："><a href="#7-创建博客站点：" class="headerlink" title="7.创建博客站点："></a>7.创建博客站点：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ pelican-quickstart</span><br></pre></td></tr></table></figure>
<p>pelican-quickstart执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 命令成功执行后，会出现pelican的框架，如下所示</p>
<p>blog/</p>
<p>├── content                # 存放输入的markdown或RST源文件</p>
<p>│   └── (pages)            # 存放手工创建的静态页面，可选</p>
<p>│   └── (posts)            # 存放手工创建的文章，可选</p>
<p>├── output                 # 存放最终生成的静态博客</p>
<p>├── develop_server.sh      # 测试服务器</p>
<p>├── Makefile               # 管理博客的Makefile</p>
<p>├── pelicanconf.py         # 配置文件</p>
<p>└── publishconf.py         # 发布文件，可删除</p>
<h3 id="8-选择博客主题："><a href="#8-选择博客主题：" class="headerlink" title="8.选择博客主题："></a>8.选择博客主题：</h3><p>在blog目录下，各页面主题可以在这个网址查看Pelican themes  <a href="http://pelicanthemes.com/" target="_blank" rel="noopener">http://pelicanthemes.com/</a>, 克隆主题开源库 <a href="https://github.com/getpelican/pelican-themes" target="_blank" rel="noopener">https://github.com/getpelican/pelican-themes</a></p>
<ul>
<li><p>克隆主题到本地<br><code>$ git clone https://github.com/getpelican/pelican-themes.git</code></p>
</li>
<li><p>打开pelicanconf.py配置文件，更改或添加THEME为自己喜欢的主题，例如本博客所挑选的elegant，更多的配置含义请关注官方文档。</p>
</li>
<li>注意下面的这个主题需要填主题的目录路径</li>
</ul>
<p><code>THEME = &#39;pelican-themes/gum&#39;</code></p>
<p>添加评论系统:</p>
<p>开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。在Disqus上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。然后同理，在pelicanconf.py添加</p>
<p><code>DISQUS_SITENAME = Shortname</code></p>
<p>生成博客站点:</p>
<p><code>$ Site generation</code></p>
<p><code>$ pelican /path/to/your/content/ [-s path/to/your/settings.py]</code></p>
<p>PS：上面的这个路径是你自己博客的content路径；</p>
<p>预览生成的站点</p>
<p>For Python 2, run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd output</span><br><span class="line">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>
<p>For Python 3, run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd output</span><br><span class="line">$ python -m http.server</span><br></pre></td></tr></table></figure>
<h3 id="9-环境建好之后的事情："><a href="#9-环境建好之后的事情：" class="headerlink" title="9.环境建好之后的事情："></a>9.环境建好之后的事情：</h3><p>OK,到这里，pelican的环境部分我们已经配置完了，不过博主好奇刚才pelican的安装些什么了？也就是说pelican的依赖项：</p>
<blockquote>
</blockquote>
<ul>
<li>feedgenerator, to generate the Atom feeds</li>
<li>jinja2, for templating support</li>
<li>pygments, for syntax highlighting</li>
<li>docutils, for supporting reStructuredText as an input format</li>
<li>pytz, for timezone definitions</li>
<li>blinker, an object-to-object and broadcast signaling system</li>
<li>unidecode, for ASCII transliterations of Unicode text</li>
<li>six, for Python 2 and 3 compatibility utilities</li>
<li>MarkupSafe, for a markup safe string implementation</li>
<li>markdown, for supporting Markdown as an input format</li>
</ul>
<p>好家伙，这么多啊，都看看 发现都不错！之后用到了在展开慢慢来说。</p>
<p>现在，让我们看看pelican是多么神奇吧，</p>
<p><code>$ pelican-quickstart</code></p>
<p>运行命令之后，在当前目录下有以下的文件</p>
<p>yourproject/</p>
<p>├── content</p>
<p>│  └── (pages)</p>
<p>├── output</p>
<p>├── develop_server.sh</p>
<p>├── fabfile.py</p>
<p>├── Makefile</p>
<p>├── pelicanconf.py      # Main settings file</p>
<p>└── publishconf.py      # Settings to use when ready to publish</p>
<p>我来说说都是些什么吧，</p>
<p>content这里是放置你的博文的，例如我的hello_python.md文章；pages是让永和可以自己定制些页面，比如aboutme.md等等页面；</p>
<p>output这个目录下放置的就是一会利用pelican生成的静态博客内容，当然是html的；</p>
<p>pelicanconf.py，是博客的配置文件，后面慢慢讲；</p>
<p>Makefile，make命令的配置文件，如果你懂linux这个就so easy！不过不懂也没事。</p>
<p>develop_server.sh 本地服务的脚本;</p>
<p>大致看完这个之后，我们可以先写一篇自己的文章瞅瞅啊，文章模板如下：</p>
<p>Title: My super title</p>
<p>Date: 2010-12-03 10:20</p>
<p>Category: Python</p>
<p>Tags: pelican, publishing</p>
<p>Slug: my-super-post</p>
<p>Author: Alexis Metaireau</p>
<p>Summary: Short version for index and feeds</p>
<p>This is the content of my super blog post.</p>
<p>写完保存后，要有以下的几个命令来生成博客内容啦；</p>
<h3 id="10-git上创建个人主页"><a href="#10-git上创建个人主页" class="headerlink" title="10.git上创建个人主页"></a>10.git上创建个人主页</h3><p>首先在自己的git帐号下新建一个组织，填写组织名；添加一个repository:<em>usiege/usiege.github.com</em>(必须用自己用户名，且唯一)；这里需要解决git多用户的问题；将生成的静态页面push到repository中；此时可以访问username.github.com的静态页面；</p>
<p>利用下面的命令来生成你的博客site：</p>
<p><code>$ make html</code></p>
<p>我比较喜欢下面的这个命令，它是实时生成你的站点，就是说你修改你的博客什么的它会实时的生成！很棒吧。</p>
<p><code>$ make regenerate</code></p>
<p>ok，生成之后，我们要看下显示的效果，用下面的命令吧</p>
<p><code>$ make serve</code></p>
<p>下面这个我比较喜欢，理由同上面的那个regerate，哈哈</p>
<p><code>$ make devserver</code></p>
<p>至此，我们可以在本地浏览刚才建好的博客了，地址就是<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a></p>
<p>停止服务器则是下面的命令：</p>
<p><code>$ ./develop_server.sh&gt;</code></p>
<p>创建成功以后，便可以把生成的页面push到github。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd output</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">$ git remote add origin https://github.com/xxx/xxx.github.io.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>关于上传的一些注意点：<br> $ git push origin master<br>   git push命令会将本地仓库推送到远程服务器。<br>   git pull命令则相反。<br>   修改完代码后，使用git status可以查看文件的差别，使用git add 添加要commit的文件，也可以用git add -i来智能添加文件。之后git commit提交本次修改，git push上传到github。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Charles</p>
              <p class="site-description motion-element" itemprop="description">Nothing is true,every is permitted.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/usiege" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/8a7d7e6876ab" target="_blank" title="Jianshu">
                      
                        <i class="fa fa-fw fa-globe"></i>Jianshu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/jianin45" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/jianin45" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.sina.com.cn/tjfcg45" target="_blank" title="Blog">
                      
                        <i class="fa fa-fw fa-globe"></i>Blog</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Charles</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
