{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo/csdn.png","path":"images/logo/csdn.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo/github.png","path":"images/logo/github.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo/jianshu.png","path":"images/logo/jianshu.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo/two.png","path":"images/logo/two.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo/weibo.png","path":"images/logo/weibo.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525417580831},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1525406500404},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1525406500404},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1525406500404},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1525406500407},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1525406500407},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1525406500408},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1525406500408},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1525406500409},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1525406500410},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1525406500411},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1525406500412},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1525406500413},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1525406500415},{"_id":"themes/next/_config.yml","hash":"4cc67960963d18b8d6f6c685d93fad41b9aa5757","modified":1525425560829},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1525406500417},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1525406500470},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525417541754},{"_id":"source/_posts/Android NFC卡实例详解.md","hash":"c916e788ac29f0a8064223e226f91c91604c8702","modified":1525423746122},{"_id":"source/_posts/Jenkins 100次构建失败踩坑全录（一）.md","hash":"b7eebd730269987760b14116470ebfa295f3a104","modified":1525423755791},{"_id":"source/_posts/Jenkins 100次构建失败踩坑全录（二）.md","hash":"0cc5d949180235876bbca8d3724e3b574f35386c","modified":1525423756637},{"_id":"source/_posts/GLKView是如何工作的.md","hash":"3285beb5dbc0eda265ea1cd1d77c7265898289f9","modified":1525429561183},{"_id":"source/_posts/Jenkins 构建之脚本篇.md","hash":"34f0f28aa7e849eb52797ec30f904ab4cfca750a","modified":1525423753790},{"_id":"source/_posts/Mac下Android Studio环境搭建.md","hash":"8a0ed5c3e5e53a7068a60139241964091605e86b","modified":1525423757615},{"_id":"source/_posts/MGJRouter代码分析.md","hash":"8e8eb1d5fad25196e9b4d61d9c6de64d3ae295da","modified":1525423759489},{"_id":"source/_posts/OpenGL-初识.md","hash":"814e7538392c681e68651dfe9912423a44b07f9e","modified":1525431180423},{"_id":"source/_posts/OpenGL-由实例理解概念.md","hash":"89a17cdebe7941f98e212817dffdafdd8f830186","modified":1525429607442},{"_id":"source/_posts/OpenGL-纹理的初步应用.md","hash":"b09cecc70edd59c17df06b1e8b4eabe5e0e6c625","modified":1525429614946},{"_id":"source/_posts/OpenGLES-纹理的初步认识.md","hash":"66d9987013da48fe7be54513190a5902718215c6","modified":1525429632865},{"_id":"source/_posts/Python-django安装.md","hash":"3eb29fefeeec0a54d107070a64d50587ff6dbe4b","modified":1525424713611},{"_id":"source/_posts/Python抓取One网页上的内容.md","hash":"e56164117208196f3ead81f8d7edcbce4b2fd730","modified":1525423765762},{"_id":"source/_posts/Swift Currying（柯里化）.md","hash":"bb2eaaec93e7f1f6c2cc5a7c4cea855cc6683c43","modified":1525423769531},{"_id":"source/_posts/Python-pelican搭建个人博客.md","hash":"d7aa74a49aeb091b1fa6508e770ddfdcaf4ab12a","modified":1525423768487},{"_id":"source/_posts/git checkout 与 reset.md","hash":"12b1a86c26da44aec4cec79f5de9373b3bfdd5f7","modified":1525423747170},{"_id":"source/_posts/hello-world.md","hash":"d3fac6a34f0f93065bf00bb4bca0ab80734fd047","modified":1525423749193},{"_id":"source/_posts/iOS 作为Central蓝牙连接外围（上）.md","hash":"92ae59d46f8a1cccaa05f07e932c1a252cd7472b","modified":1525423750104},{"_id":"source/_posts/iOS 作为Central蓝牙连接外围（下）.md","hash":"f9ef89ada73cc5961579060d5af22b06055f8e3a","modified":1525429572932},{"_id":"source/_posts/wow插件的构成.md","hash":"ad91c5f66bfbe7ab8143979c64ea1746af56796a","modified":1525429646216},{"_id":"source/_posts/人类是如何产生的？魔兽告诉你.md","hash":"32b4396e5c3354007e8b7fc8828fef450e13a2ac","modified":1525429447195},{"_id":"source/_posts/你一定不知道Swift源码怎么看？.md","hash":"f23940ebd9e12034c6640f9b8d0bb527377d77cc","modified":1525429444924},{"_id":"source/_posts/你的pod不工作了吗？.md","hash":"621de7a048e63a9ad28477ac49616ce6acc6c319","modified":1525429443529},{"_id":"source/_posts/关于wow游戏插件制作之前的几件事.md","hash":"f943c19835ff25a71c3b8a928a09cbe4d652d2ff","modified":1525429440258},{"_id":"source/_posts/关于GLKit的推断.md","hash":"e72d01da6e3637196bd30fc7a7943ceaffc20900","modified":1525429442221},{"_id":"source/_posts/北欧神话拾遗：“奥丁”，“英灵殿”，“提尔”，“西芙”，这些名字你知道吗？.md","hash":"b63335bb7bbc541fc910168e4f8f45551a1c795a","modified":1525429795456},{"_id":"source/_posts/宇宙恐怖组织的形成.md","hash":"1f0d66780b4f580d5f747fb0bd806a71afceb8c4","modified":1525429449482},{"_id":"source/_posts/守护者与上古神的战斗.md","hash":"b49a1adf1edb48cca312b2855add4245c9bf7a11","modified":1525429455141},{"_id":"source/_posts/巨魔与虫族的世纪之战.md","hash":"994a56099415146f842fc732c924007a81864247","modified":1525429463399},{"_id":"source/_posts/开始OpenGLES的探索.md","hash":"af74fbb5b4251087a95b183694367482a7605c38","modified":1525429469652},{"_id":"source/_posts/朴素贝叶斯使用Python进行文本分类.md","hash":"0c8a20117099595cc50955fbabc1d110668be2a9","modified":1525423850376},{"_id":"source/_posts/本行三件事：猎龙 训龙 调教龙.md","hash":"c95e50c63881f885a141543b63783637914ea5f9","modified":1525423740123},{"_id":"source/_posts/我为何这样堕落？.md","hash":"a1af24e93890c2252f79b42e50d7bc269cb3ac65","modified":1525429476074},{"_id":"source/_posts/艾泽拉斯上古探秘.md","hash":"858a5c8c4a5ea41c83957a290e758654b91106bd","modified":1525429490503},{"_id":"source/_posts/艾泽拉斯龙族的诞生.md","hash":"868b13e0154c731dd99b5f7e68ff29a0d7a20530","modified":1525429503310},{"_id":"source/_posts/雷神陨落与巨魔日衰.md","hash":"3ebf3cdce29ef39a302adce950d2cb0b46f935ab","modified":1525429519540},{"_id":"source/_posts/记一次iOS上线提审.md","hash":"9fbe4afc552c538c63a6aeab02c8741d5758e50a","modified":1525429511162},{"_id":"source/_posts/艾泽拉斯早期的世界格局.md","hash":"de4cd6858f0cdac3e96f1bc04aa0a74e4fb829b5","modified":1525429497741},{"_id":"source/_posts/魔兽宝强的故事——小三与兄弟反目.md","hash":"1597d32d9e01d1d745412a70e50db23f9ec25fc7","modified":1525429539291},{"_id":"source/about/index.md","hash":"3d76169fdf8d69d977d77b3ede22af53cb55d26f","modified":1525426359617},{"_id":"source/_posts/魔兽世界的历史从这里开始.md","hash":"a3fbeb6b999455f80c5440b178b9fa267d61361d","modified":1525429529469},{"_id":"source/_posts/魔古帝国的形成与始皇帝雷神.md","hash":"30f72fb1ad427e33ae558275fa84d2364e836ab2","modified":1525429545837},{"_id":"source/categories/index.md","hash":"876e30cb996227963b9d5bf14deecfee7bf1c5fb","modified":1525426279937},{"_id":"source/tags/index.md","hash":"7c919b11896aab5681bab893de2aceb1cf9b7a56","modified":1525426017138},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525406370650},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525406500371},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1525406500380},{"_id":"themes/next/.git/index","hash":"3590d580f02b538a0fe00366c3a14812052df219","modified":1525406500752},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1525406500358},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1525406500404},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1525406500405},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1525406500405},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1525406500406},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1525406500418},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1525406500419},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1525406500420},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1525406500421},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1525406500421},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1525406500421},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1525406500421},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1525406500422},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1525406500422},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1525406500422},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1525406500423},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1525406500423},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1525406500423},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1525406500471},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1525406500424},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1525406500473},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1525406500425},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1525406500426},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1525406500429},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1525406500466},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1525406500467},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1525406500467},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1525406500468},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1525406500469},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1525406500470},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1525406500470},{"_id":"themes/next/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525409508971},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1525406500741},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1525406500747},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1525406500744},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500575},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525406370653},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525406370654},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525406370654},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525406370652},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525406370654},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1525406370652},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1525406370653},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1525406370654},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525406370655},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525406370651},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1525406370649},{"_id":"themes/next/.git/logs/HEAD","hash":"447b95448701c831b19b289030dc8e8a0a67f904","modified":1525406500374},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1525406500475},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1525406500477},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1525406500476},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1525406500477},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1525406500478},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1525406500478},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1525406500481},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1525406500482},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1525406500482},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1525406500430},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1525406500431},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525406500428},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1525406500427},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1525406500433},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1525406500432},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1525406500433},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1525406500431},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1525406500443},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1525406500443},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1525406500446},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1525406500458},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1525406500458},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1525406500459},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1525406500459},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1525406500459},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1525406500459},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1525406500460},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1525406500435},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1525406500434},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1525406500437},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1525406500438},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1525406500436},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1525406500438},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1525406500439},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1525406500575},{"_id":"themes/next/source/images/.DS_Store","hash":"bd60dc29d66ed7a008c3ed8bc05567aa93d7414b","modified":1525409508970},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1525406500576},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1525406500577},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1525406500580},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1525406500580},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1525406500581},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1525406500582},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1525406500584},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1525406500584},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1525406500585},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1525406500589},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1525406500590},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1525406500590},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525406500591},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1525406500591},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525406500592},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1525406500592},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1525406500593},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525406500593},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500445},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500445},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500574},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500575},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500549},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500550},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525406500551},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1525406500373},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525406500444},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1525406500444},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1525406500446},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1525406500447},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1525406500447},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1525406500448},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1525406500449},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1525406500450},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1525406500450},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1525406500451},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1525406500453},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1525406500451},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1525406500452},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1525406500453},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1525406500454},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1525406500454},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1525406500455},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1525406500454},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1525406500455},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1525406500455},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1525406500456},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1525406500456},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1525406500457},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1525406500457},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1525406500458},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1525406500461},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1525406500463},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1525406500462},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1525406500465},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1525406500436},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1525406500437},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1525406500440},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1525406500440},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1525406500441},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1525406500441},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1525406500442},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1525406500442},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1525406500442},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1525406500574},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1525406500574},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1525406500574},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1525406500574},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1525406500547},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1525406500549},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1525406500550},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1525406500551},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1525406500597},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1525406500598},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1525406500596},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1525406500599},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1525406500600},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1525406500601},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1525406500602},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1525406500601},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1525406500603},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1525406500603},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1525406500604},{"_id":"themes/next/source/images/logo/.DS_Store","hash":"f36583ac38aca006ab0605ea388520718932085a","modified":1525408871731},{"_id":"themes/next/source/images/logo/csdn.png","hash":"2bbc75ca8418416bf59d851409a012b26f001288","modified":1525408750727},{"_id":"themes/next/source/images/logo/github.png","hash":"b500c35c030819d1c1a0f208c26ad00fdba0ed20","modified":1525408675773},{"_id":"themes/next/source/images/logo/jianshu.png","hash":"727d9ec02d6c5ee8bffe4ee71484629cdf2caa62","modified":1525408659082},{"_id":"themes/next/source/images/logo/two.png","hash":"264e02e74bd2dc5f9397e2083488eb7d32e8c8ed","modified":1525332450867},{"_id":"themes/next/source/images/logo/weibo.png","hash":"cb9f5d47ec46e9570fea57c82945586ea09ae88e","modified":1525408615152},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1525406500623},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1525406500630},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1525406500632},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1525406500632},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1525406500633},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1525406500650},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1525406500650},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1525406500651},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1525406500652},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1525406500656},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1525406500656},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1525406500656},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1525406500657},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1525406500657},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1525406500683},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1525406500690},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1525406500689},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1525406500689},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1525406500692},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1525406500690},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1525406500692},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1525406500693},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1525406500695},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1525406500709},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1525406500711},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1525406500712},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1525406500694},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1525406500697},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1525406500696},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1525406500698},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1525406500700},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1525406500699},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1525406500700},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1525406500701},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1525406500701},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1525406500705},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1525406500702},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1525406500705},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1525406500704},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1525406500708},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1525406500708},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1525406500727},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1525406500725},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1525406500737},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1525406500738},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1525406500738},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1525406500686},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"447b95448701c831b19b289030dc8e8a0a67f904","modified":1525406500375},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1525406500370},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1525406500460},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1525406500461},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1525406500486},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1525406500486},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1525406500488},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1525406500487},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1525406500488},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1525406500502},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1525406500526},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1525406500544},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1525406500544},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1525406500545},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1525406500546},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1525406500545},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1525406500546},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1525406500552},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1525406500554},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1525406500556},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1525406500557},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1525406500557},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1525406500558},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525406500559},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1525406500560},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1525406500561},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1525406500543},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1525406500562},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1525406500567},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1525406500567},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1525406500568},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1525406500572},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1525406500572},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1525406500573},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1525406500573},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1525406500573},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1525406500573},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1525406500602},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1525406500615},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1525406500622},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1525406500620},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525406500634},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525406500636},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525406500638},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525406500637},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525406500639},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525406500639},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525406500647},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525406500646},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525406500649},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1525406500655},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525406500655},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1525406500658},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1525406500659},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1525406500658},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1525406500721},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1525406500721},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1525406500616},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1525406500682},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1525406500681},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1525406500732},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"447b95448701c831b19b289030dc8e8a0a67f904","modified":1525406500369},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1525406500489},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1525406500496},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1525406500497},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1525406500498},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1525406500501},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1525406500499},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1525406500492},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1525406500494},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1525406500489},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1525406500492},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1525406500490},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1525406500490},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1525406500490},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1525406500491},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1525406500522},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1525406500521},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1525406500523},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1525406500523},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1525406500523},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1525406500523},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1525406500524},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1525406500524},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1525406500525},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1525406500524},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1525406500503},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1525406500503},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1525406500505},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1525406500504},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1525406500510},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1525406500509},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1525406500511},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1525406500512},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1525406500514},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1525406500516},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1525406500517},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1525406500516},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1525406500517},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1525406500520},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1525406500519},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1525406500527},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1525406500526},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1525406500528},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1525406500527},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1525406500528},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1525406500532},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1525406500533},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1525406500531},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1525406500532},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1525406500535},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1525406500535},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1525406500536},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1525406500534},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1525406500536},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1525406500534},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1525406500537},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1525406500541},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1525406500538},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1525406500542},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1525406500560},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525406500561},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1525406500571},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1525406500608},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1525406500609},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1525406500610},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1525406500614},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1525406500612},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525406500640},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525406500640},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525406500641},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525406500642},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525406500643},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525406500645},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1525406500664},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1525406500667},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1525406500676},{"_id":"themes/next/.git/objects/pack/pack-44f8d26b13b40bf6211ee93287b429a93cb2b5b4.idx","hash":"d5ba13477eb1a0d4ef3bd4c1d6bb51ecf57cb37f","modified":1525406500312},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1525406500628},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1525406500719},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1525406500672},{"_id":"themes/next/.git/objects/pack/pack-44f8d26b13b40bf6211ee93287b429a93cb2b5b4.pack","hash":"b2fe56e7ec4d44ebc5be59f9296fa57f7ee42a03","modified":1525406500300},{"_id":"public/about/index.html","hash":"816a86d0647044b6503025d33708d9a745ef381b","modified":1525431202200},{"_id":"public/categories/index.html","hash":"d828e51fd4ae3caa2520c1ff865947f3210f4864","modified":1525431202201},{"_id":"public/tags/index.html","hash":"5a6b066af3c40b2be4476dc342787b6406977bb5","modified":1525431202201},{"_id":"public/categories/coder/page/3/index.html","hash":"9c8cdc95196e744034ae14a7359eb347ca17c4f8","modified":1525431202201},{"_id":"public/categories/wower/index.html","hash":"382dd8e1fb27ea489a5b13890733537f515274d6","modified":1525431202201},{"_id":"public/categories/Azeroth/page/2/index.html","hash":"2436fc80e216665ddddaae75679b2e683f89b9bd","modified":1525431202201},{"_id":"public/page/5/index.html","hash":"f95742c2ba01bcf5bc865236c9a40b9a362ebcb4","modified":1525431202201},{"_id":"public/archives/page/5/index.html","hash":"82d6327bffa0ac8d5293a0b4f7a822fa24340ecc","modified":1525431202201},{"_id":"public/archives/2015/index.html","hash":"a09fab62e7e2074a5ec7b6c6c6763d9a3cbe446d","modified":1525431202201},{"_id":"public/archives/2015/12/index.html","hash":"89d31ceaf9dee5d650238212682c8b9d0cd605d4","modified":1525431202201},{"_id":"public/archives/2016/03/index.html","hash":"66fa15edccb1ed03165fd12611a1e4e1f95d851b","modified":1525431202201},{"_id":"public/archives/2016/04/index.html","hash":"3436f3e112480a210ca41c397760dec41c3d6459","modified":1525431202201},{"_id":"public/archives/2016/05/index.html","hash":"9639387c5bfe26c3103fa70bb291cc74cceca729","modified":1525431202201},{"_id":"public/archives/2016/06/index.html","hash":"d5adb24569a5a768c2b49aa4b32e88a6f28805b2","modified":1525431202202},{"_id":"public/archives/2016/07/index.html","hash":"43264ca94f02085799dda9a6c036b82bdcabf600","modified":1525431202202},{"_id":"public/archives/2016/08/page/2/index.html","hash":"7f6d6752a07b5e766d8ff181e5104a1934374105","modified":1525431202202},{"_id":"public/archives/2016/09/index.html","hash":"e966aed485a95c6e0278b9c9bb7d45d6a8b4cbf7","modified":1525431202202},{"_id":"public/archives/2017/index.html","hash":"a59c3ab1aa0362eddd6ad4bd4b7d1c85f9d6b9d7","modified":1525431202202},{"_id":"public/archives/2017/08/index.html","hash":"7e807b53471cf32e0642f5e2b6a64fd15c1c5a5b","modified":1525431202202},{"_id":"public/archives/2017/10/index.html","hash":"5516edd52a679c44483bb925a2f706f7c8cf1ad9","modified":1525431202202},{"_id":"public/archives/2017/12/index.html","hash":"e6760ef5b32c9d11d9204c7b473da32323ade359","modified":1525431202202},{"_id":"public/archives/2018/index.html","hash":"0bd392af85e071e2a281ce111c3c36807dbaf4d4","modified":1525431202202},{"_id":"public/archives/2018/01/index.html","hash":"389ec8f222852f7f519ba6ac55f1073172c323c7","modified":1525431202202},{"_id":"public/archives/2018/04/index.html","hash":"6d7ad4f18fef9714a969d0c60f3cc905c83991d4","modified":1525431202202},{"_id":"public/archives/2018/05/index.html","hash":"ccc94a86709814e094a85c6783df57c5c3085c0e","modified":1525431202202},{"_id":"public/tags/Android/index.html","hash":"ea4e5c864e839b48fcbad5c23bfbbf23d5b55469","modified":1525431202202},{"_id":"public/tags/NFC/index.html","hash":"3bebaed141e7353118bcd4f14881c7500e50a0ba","modified":1525431202202},{"_id":"public/tags/jenkins/index.html","hash":"8a5f50371b21363745ca762df38d8817b377080b","modified":1525431202202},{"_id":"public/tags/opengles/index.html","hash":"327c7cb540809e118041d7fff83233492e5081a6","modified":1525431202202},{"_id":"public/tags/Android-Studio/index.html","hash":"bd145ac15a6a698a3f72052c018e6cf97b20f9bd","modified":1525431202202},{"_id":"public/tags/mac/index.html","hash":"b23d9e68138b1ba93deb2fc813c552d0a0419eeb","modified":1525431202202},{"_id":"public/tags/iOS/index.html","hash":"f702c3b093944774750705a239f0a279a3b23ce8","modified":1525431202203},{"_id":"public/tags/modularization/index.html","hash":"0e7641453e00b5893b7d0c37707aef7663530555","modified":1525431202203},{"_id":"public/tags/opengl/index.html","hash":"1fc9238f455e23ad741f0ea445d5b7952702debf","modified":1525431202203},{"_id":"public/tags/glut/index.html","hash":"a54854f5fc863a1a2d2959638dc19e7da55a0a27","modified":1525431202203},{"_id":"public/tags/render/index.html","hash":"f6331c2fc5263beb2de9eab5db305c28ec4e554e","modified":1525431202203},{"_id":"public/tags/texture/index.html","hash":"095d0238439b15b2de2025d4faad4c1319840ac8","modified":1525431202203},{"_id":"public/tags/python/index.html","hash":"9c77d5ce632e0d0312a3b0ced8274c64e6e1d89e","modified":1525431202203},{"_id":"public/tags/django/index.html","hash":"142925871834988f772ece76853a56fcf6581afb","modified":1525431202203},{"_id":"public/tags/request/index.html","hash":"8924a76a3d724dd49b6ce9eb54be38b4a8b92748","modified":1525431202203},{"_id":"public/tags/beautifulsoup4/index.html","hash":"618d40c1bc83f02458e6b1a30e372fe81e702893","modified":1525431202203},{"_id":"public/tags/swift/index.html","hash":"aa912efc1210120f093acd82a634fc6637d9ad67","modified":1525431202203},{"_id":"public/tags/pelican/index.html","hash":"26601c877a22e1e0c2381239715950739fe46e85","modified":1525431202203},{"_id":"public/tags/git/index.html","hash":"79e3c9fd1b13544b1f5eb90e2f95027b2feb116e","modified":1525431202203},{"_id":"public/tags/bluetooth/index.html","hash":"68af9145c24cfe8a6b078cb72e3fd09f70c43c55","modified":1525431202203},{"_id":"public/tags/addons/index.html","hash":"3eddc1d8c386cb1d838fd4824957ddf194fede26","modified":1525431202203},{"_id":"public/tags/wow/index.html","hash":"ea6769c0d73cb088b7249baeac21c7c2a1d59b5a","modified":1525431202203},{"_id":"public/tags/toc/index.html","hash":"baafc878d43daaeec200bba0db5717a74f89c9c0","modified":1525431202203},{"_id":"public/tags/UTC/index.html","hash":"1d1c89506cffdd7fe128b6fc4137a6614e4d7bc6","modified":1525431202203},{"_id":"public/tags/lua/index.html","hash":"2bf7657c3189739d9bb9d055297691e186e4ed4f","modified":1525431202204},{"_id":"public/tags/CocaoPods/index.html","hash":"1846df81930ac269dbc9f616b60c3ba95e17d9b1","modified":1525431202204},{"_id":"public/tags/GLKit/index.html","hash":"bdfa5d157b6c632e476fba9d8c74ff0f2ee3de60","modified":1525431202204},{"_id":"public/tags/Mechine-Learning/index.html","hash":"a2b32b17e32bb7b2506473edbbf67a1dfda5d283","modified":1525431202204},{"_id":"public/tags/Python/index.html","hash":"dae4955f6f479deb5c9f817f274f029675290a28","modified":1525431202204},{"_id":"public/tags/paradigm/index.html","hash":"76119297c52b675fd9b9a4928f110168e9e11acf","modified":1525431202204},{"_id":"public/2018/05/03/你一定不知道Swift源码怎么看？/index.html","hash":"bdd98dcaf0122883ff03397e670c18861385cb84","modified":1525431202204},{"_id":"public/2018/05/03/hello-world/index.html","hash":"3cd8603c4a4445bfdb552fb989c9c3b4e324290a","modified":1525431202204},{"_id":"public/2018/04/27/本行三件事：猎龙 训龙 调教龙/index.html","hash":"2f80f25349d0160ea68338d6e9d340446fc01d92","modified":1525431202204},{"_id":"public/2018/04/17/朴素贝叶斯使用Python进行文本分类/index.html","hash":"511fca871248093daeb029eb3ba3c55527116f35","modified":1525431202204},{"_id":"public/2018/01/07/MGJRouter代码分析/index.html","hash":"c9a6bf12823d3e6fb7c86220716669e77cd0b842","modified":1525431202204},{"_id":"public/2018/01/06/Swift Currying（柯里化）/index.html","hash":"2e3483395de6ae7e85cd21297f8fa42ab5d33c5b","modified":1525431202204},{"_id":"public/2017/12/12/Jenkins 构建之脚本篇/index.html","hash":"9c1103331c2b07f97ce916e6b8f1cc48e8aed5fb","modified":1525431202204},{"_id":"public/2017/12/10/Jenkins 100次构建失败踩坑全录（二）/index.html","hash":"1e01920bd9ff9c3624a98a45bd7b611ce193e8b1","modified":1525431202204},{"_id":"public/2017/12/09/Jenkins 100次构建失败踩坑全录（一）/index.html","hash":"45aec0b3242f2f136ca75d65f5acd8c58af4339c","modified":1525431202204},{"_id":"public/2017/12/07/记一次iOS上线提审/index.html","hash":"d758bdc1e2efac343ae1382f2dfaae234c5fc480","modified":1525431202205},{"_id":"public/2017/10/25/Python-django安装/index.html","hash":"40d77354e5c2339293cbe274d42328d12f7a7f6a","modified":1525431202205},{"_id":"public/2017/10/17/你的pod不工作了吗？/index.html","hash":"d0c72867d512c9eb3333da28921b49e08ee888dc","modified":1525431202205},{"_id":"public/2017/08/18/git checkout 与 reset/index.html","hash":"cbf084b32867206f5c56e99baa0f0b6ee07a3ab4","modified":1525431202205},{"_id":"public/2016/09/17/雷神陨落与巨魔日衰/index.html","hash":"d7f08a4e3c3f146217e99268e7e5a530be770465","modified":1525431202205},{"_id":"public/2016/08/28/魔古帝国的形成与始皇帝雷神/index.html","hash":"18865601107827831b8109b02571eb78a36827c3","modified":1525431202205},{"_id":"public/2016/08/26/巨魔与虫族的世纪之战/index.html","hash":"c8c2d2ade077f01bce5aaa470a5b28190ab72ebe","modified":1525431202205},{"_id":"public/2016/08/25/wow插件的构成/index.html","hash":"0e66105d170b4fc9d687219f849ffba85596af6b","modified":1525431202205},{"_id":"public/2016/08/18/人类是如何产生的？魔兽告诉你/index.html","hash":"377a761c23020c4f0747965d24194053fbad49aa","modified":1525431202205},{"_id":"public/2016/08/17/北欧神话拾遗：“奥丁”，“英灵殿”，“提尔”，“西芙”，这些名字你知道吗？/index.html","hash":"1ea54511dcfe164d8b7152f762f9f4b12e3d6904","modified":1525431202205},{"_id":"public/2016/08/16/艾泽拉斯龙族的诞生/index.html","hash":"2c9205aae8858bf502cf93a0a99131f4207f8d9d","modified":1525431202205},{"_id":"public/2016/08/15/魔兽宝强的故事——小三与兄弟反目/index.html","hash":"1f810ba966047cd4c4db48100a268b2045640905","modified":1525431202205},{"_id":"public/2016/08/14/艾泽拉斯早期的世界格局/index.html","hash":"c5c0de4e61e94e17ab6345ce262fa2476e2de99e","modified":1525431202205},{"_id":"public/2016/08/13/守护者与上古神的战斗/index.html","hash":"f1ce60552420d941c8cfc7b815ad2216352f9e6a","modified":1525431202205},{"_id":"public/2016/08/12/艾泽拉斯上古探秘/index.html","hash":"b909d310236f9838b81fd8c814098598389436f5","modified":1525431202205},{"_id":"public/2016/08/11/我为何这样堕落？/index.html","hash":"9be238dcb0a8ba92fb2cbdd779c6f5b88292f1b5","modified":1525431202206},{"_id":"public/2016/08/10/宇宙恐怖组织的形成/index.html","hash":"82b23fced7787537c2c9d89158d2666cfd505107","modified":1525431202206},{"_id":"public/2016/08/09/魔兽世界的历史从这里开始/index.html","hash":"22e8180f71b15202308f6cb889261cbfc80de272","modified":1525431202206},{"_id":"public/2016/08/08/关于wow游戏插件制作之前的几件事/index.html","hash":"6fcd11c0eecaf2d18580ba5cb34c748e396192b2","modified":1525431202206},{"_id":"public/2016/08/06/OpenGL-纹理的初步应用/index.html","hash":"acdb192accf0d6d65537ab25f58f956a16f2b6ff","modified":1525431202206},{"_id":"public/2016/07/10/OpenGL-由实例理解概念/index.html","hash":"3f273cc9ced533d9446609aec32dac905fc3b1fb","modified":1525431202206},{"_id":"public/2016/07/08/Android NFC卡实例详解/index.html","hash":"7e7baef5f87f8072f81e0f9b207de13e7de8dd5c","modified":1525431202206},{"_id":"public/2016/06/15/OpenGL-初识/index.html","hash":"f0921e735c6cdc1829d6ff4b3ce8fb97e9d9f3c1","modified":1525431202206},{"_id":"public/2016/06/04/OpenGLES-纹理的初步认识/index.html","hash":"d625cf4f1f6aef055ab9ed86ae1cf1b755d2dcaf","modified":1525431202206},{"_id":"public/2016/05/29/iOS 作为Central蓝牙连接外围（下）/index.html","hash":"a26520488d31f0516d1882c4045014c12e8a5703","modified":1525431202206},{"_id":"public/2016/05/21/iOS 作为Central蓝牙连接外围（上）/index.html","hash":"6aee983edf6f4a039721f50552d85af946c2a7d4","modified":1525431202206},{"_id":"public/2016/05/09/关于GLKit的推断/index.html","hash":"ea661872c824dc907ccfb8be3acdb708198cb60d","modified":1525431202206},{"_id":"public/2016/05/07/GLKView是如何工作的/index.html","hash":"fe76c7fd8993f4a3b23319ade3dcf42f675ebde5","modified":1525431202206},{"_id":"public/2016/05/06/Python抓取One网页上的内容/index.html","hash":"c5157014aff66013f5119e1316da4f32e8202650","modified":1525431202206},{"_id":"public/2016/04/27/Mac下Android Studio环境搭建/index.html","hash":"45267e88e28f8da1145966afa5a1046effbf73e4","modified":1525431202207},{"_id":"public/2016/03/01/开始OpenGLES的探索/index.html","hash":"ef4e0bec50dfff929097005b5872804b4bfdcb2c","modified":1525431202207},{"_id":"public/2015/12/11/Python-pelican搭建个人博客/index.html","hash":"8215979d41b98543cf9d0c8aa27aa600c6acaac9","modified":1525431202207},{"_id":"public/categories/coder/index.html","hash":"cb34093b5fe6a92111d3cac6855f9fe484830c67","modified":1525431202207},{"_id":"public/categories/coder/page/2/index.html","hash":"f7bb74919fd02f3a56ad21dddeac92a7bb3a00e1","modified":1525431202207},{"_id":"public/categories/Azeroth/index.html","hash":"c6b3f04e93a6fc9b8c97205cbec7172adc5c44c6","modified":1525431202207},{"_id":"public/index.html","hash":"de18d5683b9694ed5d247e37c898a9d8b9d4004b","modified":1525431202207},{"_id":"public/page/2/index.html","hash":"28eea00c3f5ead0b2edde40561272275ac104752","modified":1525431202207},{"_id":"public/page/3/index.html","hash":"cca5e3b0ac697018af760dd065a58fd7ecc2ff8c","modified":1525431202207},{"_id":"public/page/4/index.html","hash":"566fdccca3c5b41006c221de1a2a0fc673540dc8","modified":1525431202207},{"_id":"public/archives/index.html","hash":"4c9e9f449d23b4f2a9de2a0f9a49735c586212fd","modified":1525431202207},{"_id":"public/archives/page/2/index.html","hash":"7ca313a3220ec99da825608e23eb769e0301dcd1","modified":1525431202207},{"_id":"public/archives/page/3/index.html","hash":"32b3438e1e51cd9d87aa3ea72da72844d3d45b67","modified":1525431202207},{"_id":"public/archives/page/4/index.html","hash":"3a15edcd16db2e1a3770ec3cca36187b9e2ab143","modified":1525431202207},{"_id":"public/archives/2016/index.html","hash":"3f599effb28ef3878612064162ac503b5dae21f1","modified":1525431202208},{"_id":"public/archives/2016/page/2/index.html","hash":"49e20954cbd6c8ddbe7e7a3607cc8ef02526aa58","modified":1525431202208},{"_id":"public/archives/2016/page/3/index.html","hash":"9df22b31cee4b346632c62f062150e747f32ab13","modified":1525431202208},{"_id":"public/archives/2016/08/index.html","hash":"f410d3bec9306dfb1b66cc17cdd3c6b1d3bfc789","modified":1525431202208},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1525431202225},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1525431202225},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1525431202226},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1525431202226},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1525431202226},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1525431202226},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1525431202226},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1525431202226},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1525431202226},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1525431202226},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1525431202226},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1525431202226},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525431202226},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1525431202226},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1525431202226},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525431202226},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1525431202226},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525431202227},{"_id":"public/images/logo/github.png","hash":"b500c35c030819d1c1a0f208c26ad00fdba0ed20","modified":1525431202227},{"_id":"public/images/logo/csdn.png","hash":"2bbc75ca8418416bf59d851409a012b26f001288","modified":1525431202227},{"_id":"public/images/logo/jianshu.png","hash":"727d9ec02d6c5ee8bffe4ee71484629cdf2caa62","modified":1525431202227},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1525431202227},{"_id":"public/images/logo/two.png","hash":"264e02e74bd2dc5f9397e2083488eb7d32e8c8ed","modified":1525431202227},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1525431202227},{"_id":"public/images/logo/weibo.png","hash":"cb9f5d47ec46e9570fea57c82945586ea09ae88e","modified":1525431202227},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525431202227},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525431202227},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525431202227},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525431202227},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525431202227},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525431202227},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1525431202227},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1525431202227},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1525431202227},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1525431202227},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1525431202227},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525431202228},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1525431202228},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1525431202977},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1525431202986},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1525431203001},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1525431203001},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1525431203001},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1525431203001},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1525431203001},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1525431203001},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1525431203001},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1525431203001},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1525431203001},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1525431203001},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1525431203001},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1525431203001},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1525431203001},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1525431203001},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1525431203001},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1525431203002},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1525431203002},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1525431203002},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1525431203002},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1525431203002},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1525431203002},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1525431203002},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1525431203002},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1525431203003},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1525431203003},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1525431203003},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1525431203003},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1525431203003},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1525431203003},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1525431203004},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525431203004},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525431203004},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1525431203004},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1525431203004},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525431203004},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525431203004},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525431203004},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525431203004},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525431203004},{"_id":"public/css/main.css","hash":"0ec721ea95b33432f953a5cc51e368351c0ec422","modified":1525431203004},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1525431203004},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1525431203004},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1525431203004},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1525431203004},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1525431203004},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1525431203004},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1525431203004},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1525431203005},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1525431203005},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1525431203005},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1525431203005},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525431203005},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525431203005},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1525431203005},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1525431203005},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1525431203006},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1525431203006},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1525431203006},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1525431203006},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1525431203006},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1525431203006},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1525431203008},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1525431203009},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1525431203078}],"Category":[{"name":"coder","_id":"cjgrucink00041v60x4yga3ie"},{"name":"wower","_id":"cjgrucioj001m1v60x7zavhlj"},{"name":"Azeroth","_id":"cjgrucion001u1v60r4iz3pus"}],"Data":[],"Page":[{"title":"about","date":"2018-05-04T09:32:13.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-05-04 17:32:13\ntype: \"about\"\n---\n","updated":"2018-05-04T09:32:39.617Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjgrucing00011v606jydxc8s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-05-04T09:31:01.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-05-04 17:31:01\ntype: \"categories\"\n---\n","updated":"2018-05-04T09:31:19.937Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjgrucinj00031v60iimx7su9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-05-04T09:25:50.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-05-04 17:25:50\ntype: \"tags\"\n---\n","updated":"2018-05-04T09:26:57.138Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjgrucinn00071v60u1e0eace","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Android NFC卡实例详解","date":"2016-07-08T03:08:00.000Z","_content":"\n公司最近在做一个NFC卡片的工程，经过几天的时间，终于写了一个Demo出来，在此记录下在此过程中遇到的问题。由于之前本人是做iOS的，Android写起来并不是那么的顺手，其中有一些比较基础的问题也会做出解答，水平不高，唯愿不被吐槽。另外最近写java发现，不得不说java还是比较好写的，不用考虑循环引用的问题，而且没有指针的存在理解起来也不是很费劲，内部类用起来的便捷性，底层库也比较好用，下面直接进入Demo吧；\n<!-- more -->\n\n\n项目地址：[NFCDemo](https://github.com/usiege/Android_S/tree/NFC-master/NFCDemo)\n\n## NFC\n由于本篇主要讲的是Android手机对NFC卡片的处理，所以先来介绍几个NFC的概念，定义并不完全，如需了解更多请自行谷歌；\n\n\n>>NFC,全称是近场通信（Near Field Communication）,是一种短距离无线技术；\n\n>一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。;\n\n>Android NFC同时支持三个主要的操作模式:\n\n>**设备读/写模式，允许NFC设备的读/写NFC目标设备**(本例中我们用的是这种操作模式);\n\n>P2P模式，使NFC设备与其他NFC节点交换数据；这种运作模式被使用在Android Beam中;\n\n>卡仿真模式，使NFC设备本身作为一个NFC卡。然后模拟NFC卡可以通过一个外部的NFC读写访问，如销售终端NFC点。\n\n\n>>NDEF(NFC data exchange format)\n\n>为实现NFC标签、NFC设备以及NFC设备之间的交互通信，NFC论坛(NFC Forum)定义了称为NFC数据交换格式（NDEF）的通用数据格式;\n\n>NDEF是轻量级的紧凑的二进制格式，可带有URL，vCard和NFC定义的各种数据类型;\n\n>NDEF使NFC的各种功能更加容易的使用各种支持的标签类型进行数据传输，因为NDEF已经封装了NFC标签的种类细节信息，使得应用不用关心是在与何种标签通信;\n\n>**大致可以理解为就是NFC通信用的一种传输格式；**\n\n>>Android Beam\n\n>Android Beam是一个基于近场通信所做的新功能，这个功能可以为其他手机分享你正在使用的功能。 Android升级到4.1后，Android Beam现在可以在两台支持NFC的Android设备间分享照片和视频，还可以与支持NFC的蓝牙设备相连。\n\n>*？这里有一个标签的概念比较模糊，原文是“当Android设备扫描包含NDEF格式数据的NFC标签，它对消息进行解析，试图找出其中的数据的MIME类型或URI标识”，从该句可看，所谓的标签就是基于NDEF格式的捆绑数据，从标签可获取到NFC设备数据；这里有待确认！*\n\n## NFC逻辑封装\n\n由于NFC相关是独立于Activity的，所以将NFC的逻辑全部封装在了一个叫做`NfcManager`的类中，注意该类并不需要做成一个单例；\n\n- 获取权限\n\n在`AndroidManifest.xml`文件中添加NFC权限：\n\n\n```\n<uses-permission android:name=\"android.permission.NFC\"/>\n```\n\n另外获取NFC设备数据需要在`<activity/>`内添加如下内容：\n\n```\n<intent-filter>\n    <action android:name=\"android.nfc.action.TECH_DISCOVERED\"/>\n</intent-filter>\n\n<meta-data\n\tandroid:name=\"android.nfc.action.TECH_DISCOVERED\"\n\tandroid:resource=\"@xml/nfc_tech_filter\"/>\n```\n\n上面的`nfc_tech_filter`是在res/xml文件下的自定义xml文件，用于对NFC服务的筛选：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<resources>\n    <tech-list>\n        <tech>android.nfc.tech.IsoDep</tech>\n    </tech-list>\n    <tech-list>\n        <tech>android.nfc.tech.NfcA</tech>\n    </tech-list>\n</resources>\n\n```\n\n- Intent\n\n>>Intent是Android中的一个用于传递信息的封装类，可以理解为不同组件通信的媒介或者信使。\n\n>在进行`Intent`的查询过程中了解到Android开发的四大组件，分别是*Activity*,*Service*,*Broadcast*,*ContentProvider*，而`Intent`可作为前三者的传递者；\n\n>在SDK中给出了Intent作用的表现形式为：\n\n>- 通过Context.startActivity() orActivity.startActivityForResult() 启动一个Activity；\n\n>- 通过 Context.startService() 启动一个服务，或者通过Context.bindService() 和后台服务交互；\n>- 通过广播方法(比如 Context.sendBroadcast(),Context.sendOrderedBroadcast(),  Context.sendStickyBroadcast()) 发给broadcast receivers。\n\n本例中，我们的NFC卡片信息就是从Intent中读取到的；\n\n- 初始化NFC\n\n自定义`NFCActivity`，并在其中声明并定义一个实例变量：\n\n```\nNfcManager  nfcManager_  = new NfcManager();\n```\n\n这里要说一下从谷歌开源项目风格中吸收到的一种命名规则，私有实例变量会在名称后加下划线，而OC的风格是在前面加，不管哪种命名风格，都会有可能性的增加程序的易读性，易用，宜用；\n\n接下来初始化nfc模块，在`onCreat()`函数中：\n\n```\nnfcManager_.initAdapter(this);\n```\n\n`NFCManager`声明：\n\n```\n\npublic class NfcManager{\n\n\t//NFC\n    private NfcAdapter nfcAdapter_;\n    private PendingIntent pendingIntent_;\n    private NFCActivity activity_;\n    \n    \n\t//初始化\n    public void initAdapter(NFCActivity activity){\n\n        System.out.println (\"初始化NFC\");\n        //初始化nfc适配器\n        nfcAdapter_ = NfcAdapter.getDefaultAdapter(activity);\n        //初始化卡片信息\n        pendingIntent_ = PendingIntent.getActivity(activity, 0,\n                            new Intent(activity, activity.getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);\n        //保留外部变量\n        activity_ = activity;\n    }\n}\n```\n\n从这里可以看到，`NFCActivity`保留了`NfcManager`的实例变量，而反过来`NfcManager`也保留了`NFCActivity`的实例变量，这如果是在OC中会造成循环引用问题的；\n\n- 接收Intent\n\n同样，在`onCreat()`中：\n\n```\nonNewIntent (getIntent ());\n```\n\n这里这个貌似不用主动调用，`onNewIntent()`方法也会初调用；这个`onNewIntent()`是`Activity`的重写方法，Activity检测到有新的Intent时就会调用该方法，我们的NFC事件也是通过这个方法被传送回来的。\n\n接下来：\n\n```\n//处理NFC触发\n    @Override\n    protected void onNewIntent(Intent intent) {\n        //读取数据\n        nfcManager_.readData(intent);\n    }\n```\n\n我们再来看看这个`readData()`：\n\n```\n\t private IsoDep isodep_; //ISO14443-4 NFC操作\n\t //从Intent中读卡\n    public void readData(Intent intent){\n\n        if (!NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction())){\n        \t\t//这里我们做了一个判断，即如果返回的不是NFC事件，直接返回，不做处理；\n            return;\n        }\n\n        System.out.println (\"从intent中获取标签信息！\");\n        \n        //从intent中获取标签信息\n        Parcelable p = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n        if (p != null) {\n            Tag tag = (Tag) p;\n            isodep_ = IsoDep.get(tag);\n            if (isodep_ != null){\n                readData();\n            }\n        }else {\n            //那么这里就是没有获取到Intent喽\n        }\n    }\n    private void readData() {\n    \t//毫无疑问，这里就是读卡的操作了\n    \t//如果想要了解读卡的具体细节，那么这就与外围的NFC设备有关了，Tag里的逻辑将是由NFC设备厂商定义\n    \t//本工程中的是调用NFC卡厂商的sdk进行读卡的，在实际工程中具体问题需要具体分析，本文中只讨论过程\n    \t//如果读者有兴趣，稍后会贴出本工程git地址，本例读卡写卡处理sdk为 package com.broadstar.nfccardsdk;\n    }\n```\n\n另外在activity生命周期函数内：\n\n```\n\t//程序恢复\n    @Override\n    protected void onResume() {\n        super.onResume();\n        nfcManager_.enableForegroundDispatch(this);\n    }\n\n    //程序暂停\n    @Override\n    protected void onPause() {\n        super.onPause();\n        nfcManager_.disableForegroundDispatch(this);\n    }\n```\n\n同样`NfcManager`内部实现：\n\n```\n\t public static String[][] TECHLISTS; //NFC技术列表\n    public static IntentFilter[] FILTERS; //过滤器\n\n    static {\n        try {\n            TECHLISTS = new String[][] { { IsoDep.class.getName() }, { NfcA.class.getName() } };\n\n            FILTERS = new IntentFilter[] { new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED, \"*/*\") };\n        } catch (Exception ignored) {\n        }\n    }\t\n    \n    public void enableForegroundDispatch(NFCActivity activity){\n        if (nfcAdapter_ != null) {\n            nfcAdapter_.enableForegroundDispatch(activity, pendingIntent_, FILTERS, TECHLISTS);\n        }\n    }\n    \n    public void disableForegroundDispatch(NFCActivity activity){\n        if (nfcAdapter_ != null)\n            nfcAdapter_.disableForegroundDispatch(activity);\n    }\n\n```\n\n## 一些其他的问题\n\n- String parseInt(,)\n\n```\n String str=\"123\";\n int i = Integer.parseInt(str,8);\n```\n`parseInt(,)`后面的参数表示当str被看作是多少进制时，i所得到的值(i 是10进制)\n\n- instanceOf关键字\n\n判断某个子类对象是否属于某个子类的方法：\n\n```\n\npublic class CardInfo{}\npublic class ReadCardInfo extends CardInfo{}\n\npublic void someMethod(CardInfo info) {\n    if (info instanceof ReadCardInfo) {\n    \t//是否是ReadCardInfo的实例\n    }\n}\n```\n\n- 手机访问网络权限\n\n出现java.net.SocketException: socket failed: EACCES (Permission denied)抱错时，AndroidManifest.xml中：\n\n```\n<!--网络访问权限-->\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n- Android Studio第三方Sdk无法识别的问题\n\n安卓工程的第三方sdk都是放在libs文件夹下的，当无法识别时，点击工程树目录处点击Project，右键libs里的jar包，点击Add as a library，然后再点击同步工程即可解决；\n\n- 不要在子线程中更新UI，切记，网上有方法可以调用，如果想这样做，那么请自行研究\n\n\n- 外部类中new另外一个类的内部类\n\n例如本例中，`NFCActivity`中有一个`CardHandler`的实例：\n\n`CardHandler`中有一个内部公共类：\n\n```\npublic class CardHandler{\n\n\t//内部类\n\tpublic class sendCommand implements Runnable {\n\t\n        private Map<String, Object> param_ = null;\n        private Message msg = null;\n\n        public sendCommand(Map<String, Object> param) {\n            sendCommand.this.param_ = param;\n        }\n\n        //子线程中不可以操作UI，使用Handler进行消息传递\n        @Override\n        public void run() {\n            \n        }\n    }\n}\n```\n\n`NFCActivity`中`operateCard()`函数想要实例化一个`sendCommand`的内部类对象，那么：\n\n\n```\nCardHandler cardHandler_ = new CardHandler(this,nfcManager_);\nprivate void operateCard(Map<String, Object> param) {\n        //内部类的用法\n        ThreadPoolUtils.execute(cardHandler_.new sendCommand(param));\n        //上面的这个方法把sendCommnad操作放在了子线程中\n}\n```","source":"_posts/Android NFC卡实例详解.md","raw":"title: Android NFC卡实例详解\ndate: 2016-07-08 11:08:00\ncategories: coder\ntags: [Android, NFC]\n-----------\n\n公司最近在做一个NFC卡片的工程，经过几天的时间，终于写了一个Demo出来，在此记录下在此过程中遇到的问题。由于之前本人是做iOS的，Android写起来并不是那么的顺手，其中有一些比较基础的问题也会做出解答，水平不高，唯愿不被吐槽。另外最近写java发现，不得不说java还是比较好写的，不用考虑循环引用的问题，而且没有指针的存在理解起来也不是很费劲，内部类用起来的便捷性，底层库也比较好用，下面直接进入Demo吧；\n<!-- more -->\n\n\n项目地址：[NFCDemo](https://github.com/usiege/Android_S/tree/NFC-master/NFCDemo)\n\n## NFC\n由于本篇主要讲的是Android手机对NFC卡片的处理，所以先来介绍几个NFC的概念，定义并不完全，如需了解更多请自行谷歌；\n\n\n>>NFC,全称是近场通信（Near Field Communication）,是一种短距离无线技术；\n\n>一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。;\n\n>Android NFC同时支持三个主要的操作模式:\n\n>**设备读/写模式，允许NFC设备的读/写NFC目标设备**(本例中我们用的是这种操作模式);\n\n>P2P模式，使NFC设备与其他NFC节点交换数据；这种运作模式被使用在Android Beam中;\n\n>卡仿真模式，使NFC设备本身作为一个NFC卡。然后模拟NFC卡可以通过一个外部的NFC读写访问，如销售终端NFC点。\n\n\n>>NDEF(NFC data exchange format)\n\n>为实现NFC标签、NFC设备以及NFC设备之间的交互通信，NFC论坛(NFC Forum)定义了称为NFC数据交换格式（NDEF）的通用数据格式;\n\n>NDEF是轻量级的紧凑的二进制格式，可带有URL，vCard和NFC定义的各种数据类型;\n\n>NDEF使NFC的各种功能更加容易的使用各种支持的标签类型进行数据传输，因为NDEF已经封装了NFC标签的种类细节信息，使得应用不用关心是在与何种标签通信;\n\n>**大致可以理解为就是NFC通信用的一种传输格式；**\n\n>>Android Beam\n\n>Android Beam是一个基于近场通信所做的新功能，这个功能可以为其他手机分享你正在使用的功能。 Android升级到4.1后，Android Beam现在可以在两台支持NFC的Android设备间分享照片和视频，还可以与支持NFC的蓝牙设备相连。\n\n>*？这里有一个标签的概念比较模糊，原文是“当Android设备扫描包含NDEF格式数据的NFC标签，它对消息进行解析，试图找出其中的数据的MIME类型或URI标识”，从该句可看，所谓的标签就是基于NDEF格式的捆绑数据，从标签可获取到NFC设备数据；这里有待确认！*\n\n## NFC逻辑封装\n\n由于NFC相关是独立于Activity的，所以将NFC的逻辑全部封装在了一个叫做`NfcManager`的类中，注意该类并不需要做成一个单例；\n\n- 获取权限\n\n在`AndroidManifest.xml`文件中添加NFC权限：\n\n\n```\n<uses-permission android:name=\"android.permission.NFC\"/>\n```\n\n另外获取NFC设备数据需要在`<activity/>`内添加如下内容：\n\n```\n<intent-filter>\n    <action android:name=\"android.nfc.action.TECH_DISCOVERED\"/>\n</intent-filter>\n\n<meta-data\n\tandroid:name=\"android.nfc.action.TECH_DISCOVERED\"\n\tandroid:resource=\"@xml/nfc_tech_filter\"/>\n```\n\n上面的`nfc_tech_filter`是在res/xml文件下的自定义xml文件，用于对NFC服务的筛选：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<resources>\n    <tech-list>\n        <tech>android.nfc.tech.IsoDep</tech>\n    </tech-list>\n    <tech-list>\n        <tech>android.nfc.tech.NfcA</tech>\n    </tech-list>\n</resources>\n\n```\n\n- Intent\n\n>>Intent是Android中的一个用于传递信息的封装类，可以理解为不同组件通信的媒介或者信使。\n\n>在进行`Intent`的查询过程中了解到Android开发的四大组件，分别是*Activity*,*Service*,*Broadcast*,*ContentProvider*，而`Intent`可作为前三者的传递者；\n\n>在SDK中给出了Intent作用的表现形式为：\n\n>- 通过Context.startActivity() orActivity.startActivityForResult() 启动一个Activity；\n\n>- 通过 Context.startService() 启动一个服务，或者通过Context.bindService() 和后台服务交互；\n>- 通过广播方法(比如 Context.sendBroadcast(),Context.sendOrderedBroadcast(),  Context.sendStickyBroadcast()) 发给broadcast receivers。\n\n本例中，我们的NFC卡片信息就是从Intent中读取到的；\n\n- 初始化NFC\n\n自定义`NFCActivity`，并在其中声明并定义一个实例变量：\n\n```\nNfcManager  nfcManager_  = new NfcManager();\n```\n\n这里要说一下从谷歌开源项目风格中吸收到的一种命名规则，私有实例变量会在名称后加下划线，而OC的风格是在前面加，不管哪种命名风格，都会有可能性的增加程序的易读性，易用，宜用；\n\n接下来初始化nfc模块，在`onCreat()`函数中：\n\n```\nnfcManager_.initAdapter(this);\n```\n\n`NFCManager`声明：\n\n```\n\npublic class NfcManager{\n\n\t//NFC\n    private NfcAdapter nfcAdapter_;\n    private PendingIntent pendingIntent_;\n    private NFCActivity activity_;\n    \n    \n\t//初始化\n    public void initAdapter(NFCActivity activity){\n\n        System.out.println (\"初始化NFC\");\n        //初始化nfc适配器\n        nfcAdapter_ = NfcAdapter.getDefaultAdapter(activity);\n        //初始化卡片信息\n        pendingIntent_ = PendingIntent.getActivity(activity, 0,\n                            new Intent(activity, activity.getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);\n        //保留外部变量\n        activity_ = activity;\n    }\n}\n```\n\n从这里可以看到，`NFCActivity`保留了`NfcManager`的实例变量，而反过来`NfcManager`也保留了`NFCActivity`的实例变量，这如果是在OC中会造成循环引用问题的；\n\n- 接收Intent\n\n同样，在`onCreat()`中：\n\n```\nonNewIntent (getIntent ());\n```\n\n这里这个貌似不用主动调用，`onNewIntent()`方法也会初调用；这个`onNewIntent()`是`Activity`的重写方法，Activity检测到有新的Intent时就会调用该方法，我们的NFC事件也是通过这个方法被传送回来的。\n\n接下来：\n\n```\n//处理NFC触发\n    @Override\n    protected void onNewIntent(Intent intent) {\n        //读取数据\n        nfcManager_.readData(intent);\n    }\n```\n\n我们再来看看这个`readData()`：\n\n```\n\t private IsoDep isodep_; //ISO14443-4 NFC操作\n\t //从Intent中读卡\n    public void readData(Intent intent){\n\n        if (!NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction())){\n        \t\t//这里我们做了一个判断，即如果返回的不是NFC事件，直接返回，不做处理；\n            return;\n        }\n\n        System.out.println (\"从intent中获取标签信息！\");\n        \n        //从intent中获取标签信息\n        Parcelable p = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\n        if (p != null) {\n            Tag tag = (Tag) p;\n            isodep_ = IsoDep.get(tag);\n            if (isodep_ != null){\n                readData();\n            }\n        }else {\n            //那么这里就是没有获取到Intent喽\n        }\n    }\n    private void readData() {\n    \t//毫无疑问，这里就是读卡的操作了\n    \t//如果想要了解读卡的具体细节，那么这就与外围的NFC设备有关了，Tag里的逻辑将是由NFC设备厂商定义\n    \t//本工程中的是调用NFC卡厂商的sdk进行读卡的，在实际工程中具体问题需要具体分析，本文中只讨论过程\n    \t//如果读者有兴趣，稍后会贴出本工程git地址，本例读卡写卡处理sdk为 package com.broadstar.nfccardsdk;\n    }\n```\n\n另外在activity生命周期函数内：\n\n```\n\t//程序恢复\n    @Override\n    protected void onResume() {\n        super.onResume();\n        nfcManager_.enableForegroundDispatch(this);\n    }\n\n    //程序暂停\n    @Override\n    protected void onPause() {\n        super.onPause();\n        nfcManager_.disableForegroundDispatch(this);\n    }\n```\n\n同样`NfcManager`内部实现：\n\n```\n\t public static String[][] TECHLISTS; //NFC技术列表\n    public static IntentFilter[] FILTERS; //过滤器\n\n    static {\n        try {\n            TECHLISTS = new String[][] { { IsoDep.class.getName() }, { NfcA.class.getName() } };\n\n            FILTERS = new IntentFilter[] { new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED, \"*/*\") };\n        } catch (Exception ignored) {\n        }\n    }\t\n    \n    public void enableForegroundDispatch(NFCActivity activity){\n        if (nfcAdapter_ != null) {\n            nfcAdapter_.enableForegroundDispatch(activity, pendingIntent_, FILTERS, TECHLISTS);\n        }\n    }\n    \n    public void disableForegroundDispatch(NFCActivity activity){\n        if (nfcAdapter_ != null)\n            nfcAdapter_.disableForegroundDispatch(activity);\n    }\n\n```\n\n## 一些其他的问题\n\n- String parseInt(,)\n\n```\n String str=\"123\";\n int i = Integer.parseInt(str,8);\n```\n`parseInt(,)`后面的参数表示当str被看作是多少进制时，i所得到的值(i 是10进制)\n\n- instanceOf关键字\n\n判断某个子类对象是否属于某个子类的方法：\n\n```\n\npublic class CardInfo{}\npublic class ReadCardInfo extends CardInfo{}\n\npublic void someMethod(CardInfo info) {\n    if (info instanceof ReadCardInfo) {\n    \t//是否是ReadCardInfo的实例\n    }\n}\n```\n\n- 手机访问网络权限\n\n出现java.net.SocketException: socket failed: EACCES (Permission denied)抱错时，AndroidManifest.xml中：\n\n```\n<!--网络访问权限-->\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n- Android Studio第三方Sdk无法识别的问题\n\n安卓工程的第三方sdk都是放在libs文件夹下的，当无法识别时，点击工程树目录处点击Project，右键libs里的jar包，点击Add as a library，然后再点击同步工程即可解决；\n\n- 不要在子线程中更新UI，切记，网上有方法可以调用，如果想这样做，那么请自行研究\n\n\n- 外部类中new另外一个类的内部类\n\n例如本例中，`NFCActivity`中有一个`CardHandler`的实例：\n\n`CardHandler`中有一个内部公共类：\n\n```\npublic class CardHandler{\n\n\t//内部类\n\tpublic class sendCommand implements Runnable {\n\t\n        private Map<String, Object> param_ = null;\n        private Message msg = null;\n\n        public sendCommand(Map<String, Object> param) {\n            sendCommand.this.param_ = param;\n        }\n\n        //子线程中不可以操作UI，使用Handler进行消息传递\n        @Override\n        public void run() {\n            \n        }\n    }\n}\n```\n\n`NFCActivity`中`operateCard()`函数想要实例化一个`sendCommand`的内部类对象，那么：\n\n\n```\nCardHandler cardHandler_ = new CardHandler(this,nfcManager_);\nprivate void operateCard(Map<String, Object> param) {\n        //内部类的用法\n        ThreadPoolUtils.execute(cardHandler_.new sendCommand(param));\n        //上面的这个方法把sendCommnad操作放在了子线程中\n}\n```","slug":"Android NFC卡实例详解","published":1,"updated":"2018-05-04T08:49:06.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinc00001v60oyhiy9u1","content":"<p>公司最近在做一个NFC卡片的工程，经过几天的时间，终于写了一个Demo出来，在此记录下在此过程中遇到的问题。由于之前本人是做iOS的，Android写起来并不是那么的顺手，其中有一些比较基础的问题也会做出解答，水平不高，唯愿不被吐槽。另外最近写java发现，不得不说java还是比较好写的，不用考虑循环引用的问题，而且没有指针的存在理解起来也不是很费劲，内部类用起来的便捷性，底层库也比较好用，下面直接进入Demo吧；<br><a id=\"more\"></a></p>\n<p>项目地址：<a href=\"https://github.com/usiege/Android_S/tree/NFC-master/NFCDemo\" target=\"_blank\" rel=\"noopener\">NFCDemo</a></p>\n<h2 id=\"NFC\"><a href=\"#NFC\" class=\"headerlink\" title=\"NFC\"></a>NFC</h2><p>由于本篇主要讲的是Android手机对NFC卡片的处理，所以先来介绍几个NFC的概念，定义并不完全，如需了解更多请自行谷歌；</p>\n<blockquote>\n<blockquote>\n<p>NFC,全称是近场通信（Near Field Communication）,是一种短距离无线技术；</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。;</p>\n</blockquote>\n<blockquote>\n<p>Android NFC同时支持三个主要的操作模式:</p>\n</blockquote>\n<blockquote>\n<p><strong>设备读/写模式，允许NFC设备的读/写NFC目标设备</strong>(本例中我们用的是这种操作模式);</p>\n</blockquote>\n<blockquote>\n<p>P2P模式，使NFC设备与其他NFC节点交换数据；这种运作模式被使用在Android Beam中;</p>\n</blockquote>\n<blockquote>\n<p>卡仿真模式，使NFC设备本身作为一个NFC卡。然后模拟NFC卡可以通过一个外部的NFC读写访问，如销售终端NFC点。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>NDEF(NFC data exchange format)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>为实现NFC标签、NFC设备以及NFC设备之间的交互通信，NFC论坛(NFC Forum)定义了称为NFC数据交换格式（NDEF）的通用数据格式;</p>\n</blockquote>\n<blockquote>\n<p>NDEF是轻量级的紧凑的二进制格式，可带有URL，vCard和NFC定义的各种数据类型;</p>\n</blockquote>\n<blockquote>\n<p>NDEF使NFC的各种功能更加容易的使用各种支持的标签类型进行数据传输，因为NDEF已经封装了NFC标签的种类细节信息，使得应用不用关心是在与何种标签通信;</p>\n</blockquote>\n<blockquote>\n<p><strong>大致可以理解为就是NFC通信用的一种传输格式；</strong></p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Android Beam</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Android Beam是一个基于近场通信所做的新功能，这个功能可以为其他手机分享你正在使用的功能。 Android升级到4.1后，Android Beam现在可以在两台支持NFC的Android设备间分享照片和视频，还可以与支持NFC的蓝牙设备相连。</p>\n</blockquote>\n<blockquote>\n<p><em>？这里有一个标签的概念比较模糊，原文是“当Android设备扫描包含NDEF格式数据的NFC标签，它对消息进行解析，试图找出其中的数据的MIME类型或URI标识”，从该句可看，所谓的标签就是基于NDEF格式的捆绑数据，从标签可获取到NFC设备数据；这里有待确认！</em></p>\n</blockquote>\n<h2 id=\"NFC逻辑封装\"><a href=\"#NFC逻辑封装\" class=\"headerlink\" title=\"NFC逻辑封装\"></a>NFC逻辑封装</h2><p>由于NFC相关是独立于Activity的，所以将NFC的逻辑全部封装在了一个叫做<code>NfcManager</code>的类中，注意该类并不需要做成一个单例；</p>\n<ul>\n<li>获取权限</li>\n</ul>\n<p>在<code>AndroidManifest.xml</code>文件中添加NFC权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.NFC&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>另外获取NFC设备数据需要在<code>&lt;activity/&gt;</code>内添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">    &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">\tandroid:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;</span><br><span class=\"line\">\tandroid:resource=&quot;@xml/nfc_tech_filter&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的<code>nfc_tech_filter</code>是在res/xml文件下的自定义xml文件，用于对NFC服务的筛选：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;resources&gt;</span><br><span class=\"line\">    &lt;tech-list&gt;</span><br><span class=\"line\">        &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt;</span><br><span class=\"line\">    &lt;/tech-list&gt;</span><br><span class=\"line\">    &lt;tech-list&gt;</span><br><span class=\"line\">        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;</span><br><span class=\"line\">    &lt;/tech-list&gt;</span><br><span class=\"line\">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Intent</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>Intent是Android中的一个用于传递信息的封装类，可以理解为不同组件通信的媒介或者信使。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>在进行<code>Intent</code>的查询过程中了解到Android开发的四大组件，分别是<em>Activity</em>,<em>Service</em>,<em>Broadcast</em>,<em>ContentProvider</em>，而<code>Intent</code>可作为前三者的传递者；</p>\n</blockquote>\n<blockquote>\n<p>在SDK中给出了Intent作用的表现形式为：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>通过Context.startActivity() orActivity.startActivityForResult() 启动一个Activity；</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>通过 Context.startService() 启动一个服务，或者通过Context.bindService() 和后台服务交互；</li>\n<li>通过广播方法(比如 Context.sendBroadcast(),Context.sendOrderedBroadcast(),  Context.sendStickyBroadcast()) 发给broadcast receivers。</li>\n</ul>\n</blockquote>\n<p>本例中，我们的NFC卡片信息就是从Intent中读取到的；</p>\n<ul>\n<li>初始化NFC</li>\n</ul>\n<p>自定义<code>NFCActivity</code>，并在其中声明并定义一个实例变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NfcManager  nfcManager_  = new NfcManager();</span><br></pre></td></tr></table></figure>\n<p>这里要说一下从谷歌开源项目风格中吸收到的一种命名规则，私有实例变量会在名称后加下划线，而OC的风格是在前面加，不管哪种命名风格，都会有可能性的增加程序的易读性，易用，宜用；</p>\n<p>接下来初始化nfc模块，在<code>onCreat()</code>函数中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nfcManager_.initAdapter(this);</span><br></pre></td></tr></table></figure>\n<p><code>NFCManager</code>声明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class NfcManager&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//NFC</span><br><span class=\"line\">    private NfcAdapter nfcAdapter_;</span><br><span class=\"line\">    private PendingIntent pendingIntent_;</span><br><span class=\"line\">    private NFCActivity activity_;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">\t//初始化</span><br><span class=\"line\">    public void initAdapter(NFCActivity activity)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println (&quot;初始化NFC&quot;);</span><br><span class=\"line\">        //初始化nfc适配器</span><br><span class=\"line\">        nfcAdapter_ = NfcAdapter.getDefaultAdapter(activity);</span><br><span class=\"line\">        //初始化卡片信息</span><br><span class=\"line\">        pendingIntent_ = PendingIntent.getActivity(activity, 0,</span><br><span class=\"line\">                            new Intent(activity, activity.getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);</span><br><span class=\"line\">        //保留外部变量</span><br><span class=\"line\">        activity_ = activity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到，<code>NFCActivity</code>保留了<code>NfcManager</code>的实例变量，而反过来<code>NfcManager</code>也保留了<code>NFCActivity</code>的实例变量，这如果是在OC中会造成循环引用问题的；</p>\n<ul>\n<li>接收Intent</li>\n</ul>\n<p>同样，在<code>onCreat()</code>中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onNewIntent (getIntent ());</span><br></pre></td></tr></table></figure>\n<p>这里这个貌似不用主动调用，<code>onNewIntent()</code>方法也会初调用；这个<code>onNewIntent()</code>是<code>Activity</code>的重写方法，Activity检测到有新的Intent时就会调用该方法，我们的NFC事件也是通过这个方法被传送回来的。</p>\n<p>接下来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//处理NFC触发</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onNewIntent(Intent intent) &#123;</span><br><span class=\"line\">        //读取数据</span><br><span class=\"line\">        nfcManager_.readData(intent);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看这个<code>readData()</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IsoDep isodep_; //ISO14443-4 NFC操作</span><br><span class=\"line\">//从Intent中读卡</span><br><span class=\"line\">  public void readData(Intent intent)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (!NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction()))&#123;</span><br><span class=\"line\">      \t\t//这里我们做了一个判断，即如果返回的不是NFC事件，直接返回，不做处理；</span><br><span class=\"line\">          return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println (&quot;从intent中获取标签信息！&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      //从intent中获取标签信息</span><br><span class=\"line\">      Parcelable p = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class=\"line\">      if (p != null) &#123;</span><br><span class=\"line\">          Tag tag = (Tag) p;</span><br><span class=\"line\">          isodep_ = IsoDep.get(tag);</span><br><span class=\"line\">          if (isodep_ != null)&#123;</span><br><span class=\"line\">              readData();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">          //那么这里就是没有获取到Intent喽</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  private void readData() &#123;</span><br><span class=\"line\">  \t//毫无疑问，这里就是读卡的操作了</span><br><span class=\"line\">  \t//如果想要了解读卡的具体细节，那么这就与外围的NFC设备有关了，Tag里的逻辑将是由NFC设备厂商定义</span><br><span class=\"line\">  \t//本工程中的是调用NFC卡厂商的sdk进行读卡的，在实际工程中具体问题需要具体分析，本文中只讨论过程</span><br><span class=\"line\">  \t//如果读者有兴趣，稍后会贴出本工程git地址，本例读卡写卡处理sdk为 package com.broadstar.nfccardsdk;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>另外在activity生命周期函数内：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//程序恢复</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   protected void onResume() &#123;</span><br><span class=\"line\">       super.onResume();</span><br><span class=\"line\">       nfcManager_.enableForegroundDispatch(this);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   //程序暂停</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   protected void onPause() &#123;</span><br><span class=\"line\">       super.onPause();</span><br><span class=\"line\">       nfcManager_.disableForegroundDispatch(this);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>同样<code>NfcManager</code>内部实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String[][] TECHLISTS; //NFC技术列表</span><br><span class=\"line\">  public static IntentFilter[] FILTERS; //过滤器</span><br><span class=\"line\"></span><br><span class=\"line\">  static &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">          TECHLISTS = new String[][] &#123; &#123; IsoDep.class.getName() &#125;, &#123; NfcA.class.getName() &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          FILTERS = new IntentFilter[] &#123; new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED, &quot;*/*&quot;) &#125;;</span><br><span class=\"line\">      &#125; catch (Exception ignored) &#123;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">  </span><br><span class=\"line\">  public void enableForegroundDispatch(NFCActivity activity)&#123;</span><br><span class=\"line\">      if (nfcAdapter_ != null) &#123;</span><br><span class=\"line\">          nfcAdapter_.enableForegroundDispatch(activity, pendingIntent_, FILTERS, TECHLISTS);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  public void disableForegroundDispatch(NFCActivity activity)&#123;</span><br><span class=\"line\">      if (nfcAdapter_ != null)</span><br><span class=\"line\">          nfcAdapter_.disableForegroundDispatch(activity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"一些其他的问题\"><a href=\"#一些其他的问题\" class=\"headerlink\" title=\"一些其他的问题\"></a>一些其他的问题</h2><ul>\n<li>String parseInt(,)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str=&quot;123&quot;;</span><br><span class=\"line\">int i = Integer.parseInt(str,8);</span><br></pre></td></tr></table></figure>\n<p><code>parseInt(,)</code>后面的参数表示当str被看作是多少进制时，i所得到的值(i 是10进制)</p>\n<ul>\n<li>instanceOf关键字</li>\n</ul>\n<p>判断某个子类对象是否属于某个子类的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class CardInfo&#123;&#125;</span><br><span class=\"line\">public class ReadCardInfo extends CardInfo&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void someMethod(CardInfo info) &#123;</span><br><span class=\"line\">    if (info instanceof ReadCardInfo) &#123;</span><br><span class=\"line\">    \t//是否是ReadCardInfo的实例</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>手机访问网络权限</li>\n</ul>\n<p>出现java.net.SocketException: socket failed: EACCES (Permission denied)抱错时，AndroidManifest.xml中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--网络访问权限--&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Android Studio第三方Sdk无法识别的问题</li>\n</ul>\n<p>安卓工程的第三方sdk都是放在libs文件夹下的，当无法识别时，点击工程树目录处点击Project，右键libs里的jar包，点击Add as a library，然后再点击同步工程即可解决；</p>\n<ul>\n<li>不要在子线程中更新UI，切记，网上有方法可以调用，如果想这样做，那么请自行研究</li>\n</ul>\n<ul>\n<li>外部类中new另外一个类的内部类</li>\n</ul>\n<p>例如本例中，<code>NFCActivity</code>中有一个<code>CardHandler</code>的实例：</p>\n<p><code>CardHandler</code>中有一个内部公共类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CardHandler&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//内部类</span><br><span class=\"line\">\tpublic class sendCommand implements Runnable &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        private Map&lt;String, Object&gt; param_ = null;</span><br><span class=\"line\">        private Message msg = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        public sendCommand(Map&lt;String, Object&gt; param) &#123;</span><br><span class=\"line\">            sendCommand.this.param_ = param;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //子线程中不可以操作UI，使用Handler进行消息传递</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>NFCActivity</code>中<code>operateCard()</code>函数想要实例化一个<code>sendCommand</code>的内部类对象，那么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CardHandler cardHandler_ = new CardHandler(this,nfcManager_);</span><br><span class=\"line\">private void operateCard(Map&lt;String, Object&gt; param) &#123;</span><br><span class=\"line\">        //内部类的用法</span><br><span class=\"line\">        ThreadPoolUtils.execute(cardHandler_.new sendCommand(param));</span><br><span class=\"line\">        //上面的这个方法把sendCommnad操作放在了子线程中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>公司最近在做一个NFC卡片的工程，经过几天的时间，终于写了一个Demo出来，在此记录下在此过程中遇到的问题。由于之前本人是做iOS的，Android写起来并不是那么的顺手，其中有一些比较基础的问题也会做出解答，水平不高，唯愿不被吐槽。另外最近写java发现，不得不说java还是比较好写的，不用考虑循环引用的问题，而且没有指针的存在理解起来也不是很费劲，内部类用起来的便捷性，底层库也比较好用，下面直接进入Demo吧；<br>","more":"</p>\n<p>项目地址：<a href=\"https://github.com/usiege/Android_S/tree/NFC-master/NFCDemo\" target=\"_blank\" rel=\"noopener\">NFCDemo</a></p>\n<h2 id=\"NFC\"><a href=\"#NFC\" class=\"headerlink\" title=\"NFC\"></a>NFC</h2><p>由于本篇主要讲的是Android手机对NFC卡片的处理，所以先来介绍几个NFC的概念，定义并不完全，如需了解更多请自行谷歌；</p>\n<blockquote>\n<blockquote>\n<p>NFC,全称是近场通信（Near Field Communication）,是一种短距离无线技术；</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。;</p>\n</blockquote>\n<blockquote>\n<p>Android NFC同时支持三个主要的操作模式:</p>\n</blockquote>\n<blockquote>\n<p><strong>设备读/写模式，允许NFC设备的读/写NFC目标设备</strong>(本例中我们用的是这种操作模式);</p>\n</blockquote>\n<blockquote>\n<p>P2P模式，使NFC设备与其他NFC节点交换数据；这种运作模式被使用在Android Beam中;</p>\n</blockquote>\n<blockquote>\n<p>卡仿真模式，使NFC设备本身作为一个NFC卡。然后模拟NFC卡可以通过一个外部的NFC读写访问，如销售终端NFC点。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>NDEF(NFC data exchange format)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>为实现NFC标签、NFC设备以及NFC设备之间的交互通信，NFC论坛(NFC Forum)定义了称为NFC数据交换格式（NDEF）的通用数据格式;</p>\n</blockquote>\n<blockquote>\n<p>NDEF是轻量级的紧凑的二进制格式，可带有URL，vCard和NFC定义的各种数据类型;</p>\n</blockquote>\n<blockquote>\n<p>NDEF使NFC的各种功能更加容易的使用各种支持的标签类型进行数据传输，因为NDEF已经封装了NFC标签的种类细节信息，使得应用不用关心是在与何种标签通信;</p>\n</blockquote>\n<blockquote>\n<p><strong>大致可以理解为就是NFC通信用的一种传输格式；</strong></p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Android Beam</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Android Beam是一个基于近场通信所做的新功能，这个功能可以为其他手机分享你正在使用的功能。 Android升级到4.1后，Android Beam现在可以在两台支持NFC的Android设备间分享照片和视频，还可以与支持NFC的蓝牙设备相连。</p>\n</blockquote>\n<blockquote>\n<p><em>？这里有一个标签的概念比较模糊，原文是“当Android设备扫描包含NDEF格式数据的NFC标签，它对消息进行解析，试图找出其中的数据的MIME类型或URI标识”，从该句可看，所谓的标签就是基于NDEF格式的捆绑数据，从标签可获取到NFC设备数据；这里有待确认！</em></p>\n</blockquote>\n<h2 id=\"NFC逻辑封装\"><a href=\"#NFC逻辑封装\" class=\"headerlink\" title=\"NFC逻辑封装\"></a>NFC逻辑封装</h2><p>由于NFC相关是独立于Activity的，所以将NFC的逻辑全部封装在了一个叫做<code>NfcManager</code>的类中，注意该类并不需要做成一个单例；</p>\n<ul>\n<li>获取权限</li>\n</ul>\n<p>在<code>AndroidManifest.xml</code>文件中添加NFC权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.NFC&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>另外获取NFC设备数据需要在<code>&lt;activity/&gt;</code>内添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;intent-filter&gt;</span><br><span class=\"line\">    &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;/&gt;</span><br><span class=\"line\">&lt;/intent-filter&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">\tandroid:name=&quot;android.nfc.action.TECH_DISCOVERED&quot;</span><br><span class=\"line\">\tandroid:resource=&quot;@xml/nfc_tech_filter&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的<code>nfc_tech_filter</code>是在res/xml文件下的自定义xml文件，用于对NFC服务的筛选：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;resources&gt;</span><br><span class=\"line\">    &lt;tech-list&gt;</span><br><span class=\"line\">        &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt;</span><br><span class=\"line\">    &lt;/tech-list&gt;</span><br><span class=\"line\">    &lt;tech-list&gt;</span><br><span class=\"line\">        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;</span><br><span class=\"line\">    &lt;/tech-list&gt;</span><br><span class=\"line\">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Intent</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>Intent是Android中的一个用于传递信息的封装类，可以理解为不同组件通信的媒介或者信使。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>在进行<code>Intent</code>的查询过程中了解到Android开发的四大组件，分别是<em>Activity</em>,<em>Service</em>,<em>Broadcast</em>,<em>ContentProvider</em>，而<code>Intent</code>可作为前三者的传递者；</p>\n</blockquote>\n<blockquote>\n<p>在SDK中给出了Intent作用的表现形式为：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>通过Context.startActivity() orActivity.startActivityForResult() 启动一个Activity；</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>通过 Context.startService() 启动一个服务，或者通过Context.bindService() 和后台服务交互；</li>\n<li>通过广播方法(比如 Context.sendBroadcast(),Context.sendOrderedBroadcast(),  Context.sendStickyBroadcast()) 发给broadcast receivers。</li>\n</ul>\n</blockquote>\n<p>本例中，我们的NFC卡片信息就是从Intent中读取到的；</p>\n<ul>\n<li>初始化NFC</li>\n</ul>\n<p>自定义<code>NFCActivity</code>，并在其中声明并定义一个实例变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NfcManager  nfcManager_  = new NfcManager();</span><br></pre></td></tr></table></figure>\n<p>这里要说一下从谷歌开源项目风格中吸收到的一种命名规则，私有实例变量会在名称后加下划线，而OC的风格是在前面加，不管哪种命名风格，都会有可能性的增加程序的易读性，易用，宜用；</p>\n<p>接下来初始化nfc模块，在<code>onCreat()</code>函数中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nfcManager_.initAdapter(this);</span><br></pre></td></tr></table></figure>\n<p><code>NFCManager</code>声明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class NfcManager&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//NFC</span><br><span class=\"line\">    private NfcAdapter nfcAdapter_;</span><br><span class=\"line\">    private PendingIntent pendingIntent_;</span><br><span class=\"line\">    private NFCActivity activity_;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">\t//初始化</span><br><span class=\"line\">    public void initAdapter(NFCActivity activity)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println (&quot;初始化NFC&quot;);</span><br><span class=\"line\">        //初始化nfc适配器</span><br><span class=\"line\">        nfcAdapter_ = NfcAdapter.getDefaultAdapter(activity);</span><br><span class=\"line\">        //初始化卡片信息</span><br><span class=\"line\">        pendingIntent_ = PendingIntent.getActivity(activity, 0,</span><br><span class=\"line\">                            new Intent(activity, activity.getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);</span><br><span class=\"line\">        //保留外部变量</span><br><span class=\"line\">        activity_ = activity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到，<code>NFCActivity</code>保留了<code>NfcManager</code>的实例变量，而反过来<code>NfcManager</code>也保留了<code>NFCActivity</code>的实例变量，这如果是在OC中会造成循环引用问题的；</p>\n<ul>\n<li>接收Intent</li>\n</ul>\n<p>同样，在<code>onCreat()</code>中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onNewIntent (getIntent ());</span><br></pre></td></tr></table></figure>\n<p>这里这个貌似不用主动调用，<code>onNewIntent()</code>方法也会初调用；这个<code>onNewIntent()</code>是<code>Activity</code>的重写方法，Activity检测到有新的Intent时就会调用该方法，我们的NFC事件也是通过这个方法被传送回来的。</p>\n<p>接下来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//处理NFC触发</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onNewIntent(Intent intent) &#123;</span><br><span class=\"line\">        //读取数据</span><br><span class=\"line\">        nfcManager_.readData(intent);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看这个<code>readData()</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IsoDep isodep_; //ISO14443-4 NFC操作</span><br><span class=\"line\">//从Intent中读卡</span><br><span class=\"line\">  public void readData(Intent intent)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (!NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction()))&#123;</span><br><span class=\"line\">      \t\t//这里我们做了一个判断，即如果返回的不是NFC事件，直接返回，不做处理；</span><br><span class=\"line\">          return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      System.out.println (&quot;从intent中获取标签信息！&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">      //从intent中获取标签信息</span><br><span class=\"line\">      Parcelable p = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class=\"line\">      if (p != null) &#123;</span><br><span class=\"line\">          Tag tag = (Tag) p;</span><br><span class=\"line\">          isodep_ = IsoDep.get(tag);</span><br><span class=\"line\">          if (isodep_ != null)&#123;</span><br><span class=\"line\">              readData();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">          //那么这里就是没有获取到Intent喽</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  private void readData() &#123;</span><br><span class=\"line\">  \t//毫无疑问，这里就是读卡的操作了</span><br><span class=\"line\">  \t//如果想要了解读卡的具体细节，那么这就与外围的NFC设备有关了，Tag里的逻辑将是由NFC设备厂商定义</span><br><span class=\"line\">  \t//本工程中的是调用NFC卡厂商的sdk进行读卡的，在实际工程中具体问题需要具体分析，本文中只讨论过程</span><br><span class=\"line\">  \t//如果读者有兴趣，稍后会贴出本工程git地址，本例读卡写卡处理sdk为 package com.broadstar.nfccardsdk;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>另外在activity生命周期函数内：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//程序恢复</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   protected void onResume() &#123;</span><br><span class=\"line\">       super.onResume();</span><br><span class=\"line\">       nfcManager_.enableForegroundDispatch(this);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   //程序暂停</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   protected void onPause() &#123;</span><br><span class=\"line\">       super.onPause();</span><br><span class=\"line\">       nfcManager_.disableForegroundDispatch(this);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>同样<code>NfcManager</code>内部实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String[][] TECHLISTS; //NFC技术列表</span><br><span class=\"line\">  public static IntentFilter[] FILTERS; //过滤器</span><br><span class=\"line\"></span><br><span class=\"line\">  static &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">          TECHLISTS = new String[][] &#123; &#123; IsoDep.class.getName() &#125;, &#123; NfcA.class.getName() &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">          FILTERS = new IntentFilter[] &#123; new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED, &quot;*/*&quot;) &#125;;</span><br><span class=\"line\">      &#125; catch (Exception ignored) &#123;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">  </span><br><span class=\"line\">  public void enableForegroundDispatch(NFCActivity activity)&#123;</span><br><span class=\"line\">      if (nfcAdapter_ != null) &#123;</span><br><span class=\"line\">          nfcAdapter_.enableForegroundDispatch(activity, pendingIntent_, FILTERS, TECHLISTS);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  public void disableForegroundDispatch(NFCActivity activity)&#123;</span><br><span class=\"line\">      if (nfcAdapter_ != null)</span><br><span class=\"line\">          nfcAdapter_.disableForegroundDispatch(activity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"一些其他的问题\"><a href=\"#一些其他的问题\" class=\"headerlink\" title=\"一些其他的问题\"></a>一些其他的问题</h2><ul>\n<li>String parseInt(,)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str=&quot;123&quot;;</span><br><span class=\"line\">int i = Integer.parseInt(str,8);</span><br></pre></td></tr></table></figure>\n<p><code>parseInt(,)</code>后面的参数表示当str被看作是多少进制时，i所得到的值(i 是10进制)</p>\n<ul>\n<li>instanceOf关键字</li>\n</ul>\n<p>判断某个子类对象是否属于某个子类的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class CardInfo&#123;&#125;</span><br><span class=\"line\">public class ReadCardInfo extends CardInfo&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void someMethod(CardInfo info) &#123;</span><br><span class=\"line\">    if (info instanceof ReadCardInfo) &#123;</span><br><span class=\"line\">    \t//是否是ReadCardInfo的实例</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>手机访问网络权限</li>\n</ul>\n<p>出现java.net.SocketException: socket failed: EACCES (Permission denied)抱错时，AndroidManifest.xml中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--网络访问权限--&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Android Studio第三方Sdk无法识别的问题</li>\n</ul>\n<p>安卓工程的第三方sdk都是放在libs文件夹下的，当无法识别时，点击工程树目录处点击Project，右键libs里的jar包，点击Add as a library，然后再点击同步工程即可解决；</p>\n<ul>\n<li>不要在子线程中更新UI，切记，网上有方法可以调用，如果想这样做，那么请自行研究</li>\n</ul>\n<ul>\n<li>外部类中new另外一个类的内部类</li>\n</ul>\n<p>例如本例中，<code>NFCActivity</code>中有一个<code>CardHandler</code>的实例：</p>\n<p><code>CardHandler</code>中有一个内部公共类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CardHandler&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t//内部类</span><br><span class=\"line\">\tpublic class sendCommand implements Runnable &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">        private Map&lt;String, Object&gt; param_ = null;</span><br><span class=\"line\">        private Message msg = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        public sendCommand(Map&lt;String, Object&gt; param) &#123;</span><br><span class=\"line\">            sendCommand.this.param_ = param;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //子线程中不可以操作UI，使用Handler进行消息传递</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>NFCActivity</code>中<code>operateCard()</code>函数想要实例化一个<code>sendCommand</code>的内部类对象，那么：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CardHandler cardHandler_ = new CardHandler(this,nfcManager_);</span><br><span class=\"line\">private void operateCard(Map&lt;String, Object&gt; param) &#123;</span><br><span class=\"line\">        //内部类的用法</span><br><span class=\"line\">        ThreadPoolUtils.execute(cardHandler_.new sendCommand(param));</span><br><span class=\"line\">        //上面的这个方法把sendCommnad操作放在了子线程中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Jenkins 100次构建失败踩坑全录（二）","date":"2017-12-10T12:53:00.000Z","_content":"\n接上篇，继续踩坑，下面到构建触发器环节：\n<!-- more -->\n\n+ 构建触发器\n![image_1c0qnmug31v0hvkf1pp1kqf1bir9.png-91.5kB][1]\n能用到的发图所示，说明在下方，自行研究，需要注意的一点是图中的*号之间是有空格的；\n\n+ 构建环境\n这里又有一个超时，与上面的无关，这个是构建过程中的，根据需要添加，下面那个选项是时间戳；\n![image_1c0qooi0dkg7ls9abefu71n77p.png-38.6kB][2]\n\n接下来是Keychains和Mobile PP，必填项；\n![image_1c0qosdhm132q23k103kckp1dok16.png-8kB][3]\n\n逐个击破：\nKeychains部分\n![image_1c0qovfpn1n431vc7n8qonb8o51j.png-83.2kB][4]\n这个部分也是选择题，因为之前你已经上传了，但是这里会出现无法选择的bug，点保存刷新下页面就可以选了，Variables部分填如下：\n```\n${KEYCHAIN_PATH} ${KEYCHAIN_PASSWORD} ${CODE_SIGNING_IDENTITY}\n```\nMobile Provisioning Profiles部分\n![image_1c0qprhce18lu1vjb1pd1aakjv20.png-47.6kB][5]\n这个部分同上，请选择你确定的PP文件，一定要对应好：\n```\n${PROVISIONING_PROFILE}\n```\n\n+ 构建\n\n整个配置过程最重要的部分，大多数问题都出在这里，我这里目前到了Archive阶段，也就是说归档成功，然后归档结果可以用xcode进行ipa打包，具体打包还要设置一个shell脚本，网上好多，有的可以用有的不可以，所以打算研究下这个脚本，自己写一个再上传，之后会在博客中跟进，现在先继续把已完成的部分写下来；\n\n首先是先要加一个结束后的脚本，这个脚本不做打包操作，只是设置一下环境，以及配置一下有pod依赖的情况，如下：\n```\n#!/bin/bash -l\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\nexport LC_ALL=en_US.UTF-8\n\npod install --verbose --no-repo-update\nopen LeWaiJiao.xcworkspace\n```\n![image_1c0qqc2ubcfq5tvuui19m3oi89.png-47.4kB][6]\n\n下面的那个**Pack application,build and sign** .ipa项就是打ipa的功能，暂时没有搞通，后续会补上来，先跳过；\n\n![image_1c0qqnucp1np81vaj3rs1l7p1otdm.png-97.4kB][7]\n\n**Code signing & OS X keychain options**\n\n下面的bundleID是你要进行打包的bundleID，info.plist是workspace下的路径，注意一下下面的Development Team ID这个ID是你的钥匙串上的证书名称，后面括号里的那一串字符，由字母和数字组成的，需要你自己做对应，下面的照着抄就行了，password填你电脑用户的密码，不要填错了；\n\n![image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png-102.7kB][8]\n\n\n贴几个Error：\n=========\n\n```\nCode Signing Error: Code signing is required for product type 'Application' in SDK 'iOS 11.1'\n```\n需要你在xcode中设置，然后上传到你们的Git服务器再构建：\n![image_1c0qs83ul1baipc04otg331geb1g.png-35.4kB][9]\n\n```\nNo global development team or local team ID was configured.\n```\n\n就是之前说的**Development Team ID**部分，填了就解决了；\n[http://www.jianshu.com/p/8b2fc2da0466][10]\n\n```\nxcodebuild: error: The flag -scheme is required when specifying -archivePath but not -exportArchive.\n```\n这个问题也是个大坑，找了好久，也是搜狗找到的：\n[http://www.jianshu.com/p/8967e4e27e9b][11]\n[https://www.tuicool.com/articles/zQ73Q3Q][12]\n[https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc][13]\n\n解决方法最直接的就是指定scheme和xcode workspace file，分别填你xcode工程中的scheme和pod生成的xcworkspace的名字；\n![image_1c0r0aqt33tdthopme188a2kk1t.png-87.3kB][14]\n\n有些同学不知道scheme在什么地方，如下图所示：\n![image_1c0r0eai5f09qj47rs134c1upu2a.png-145.6kB][15]\n\n\n如上，能保证构建可以成功在Archive过程完成，如遇其他问题，欢迎评论区讨论；\n之后会再继续完成打包ipa以及上传平台，同时之前提过的SSH部分会持续跟近，因为SSH与本文所讨论的内容并不十分吻合，所以这里不作讨论。\n\n\n  [1]: http://static.zybuluo.com/usiege/it14w81rja3zme63xykjxy5o/image_1c0qnmug31v0hvkf1pp1kqf1bir9.png\n  [2]: http://static.zybuluo.com/usiege/pjeg3kt1s3cb0rxb2l1dfsfr/image_1c0qooi0dkg7ls9abefu71n77p.png\n  [3]: http://static.zybuluo.com/usiege/cjtc66sg8991c5ulj3uib8dq/image_1c0qosdhm132q23k103kckp1dok16.png\n  [4]: http://static.zybuluo.com/usiege/li5lfp7spsd6c3bw435besbb/image_1c0qovfpn1n431vc7n8qonb8o51j.png\n  [5]: http://static.zybuluo.com/usiege/1s0il4bxtsop1ame15pbq0ul/image_1c0qprhce18lu1vjb1pd1aakjv20.png\n  [6]: http://static.zybuluo.com/usiege/rxby0iwous3ppc63wyn1c83y/image_1c0qqc2ubcfq5tvuui19m3oi89.png\n  [7]: http://static.zybuluo.com/usiege/eceobb4arpah1xacmv2lmxrr/image_1c0qqnucp1np81vaj3rs1l7p1otdm.png\n  [8]: http://static.zybuluo.com/usiege/xhxhseh11fwg4wnbt8gpj95y/image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png\n  [9]: http://static.zybuluo.com/usiege/r85b8hxub85tfinbuzue1svp/image_1c0qs83ul1baipc04otg331geb1g.png\n  [10]: http://www.jianshu.com/p/8b2fc2da0466\n  [11]: http://www.jianshu.com/p/8967e4e27e9b\n  [12]: https://www.tuicool.com/articles/zQ73Q3Q\n  [13]: https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc\n  [14]: http://static.zybuluo.com/usiege/tlotqzvjbjlqk2ms1u43w2yd/image_1c0r0aqt33tdthopme188a2kk1t.png\n  [15]: http://static.zybuluo.com/usiege/1y4937ijhbvifle7jfgjg3ac/image_1c0r0eai5f09qj47rs134c1upu2a.png","source":"_posts/Jenkins 100次构建失败踩坑全录（二）.md","raw":"title: Jenkins 100次构建失败踩坑全录（二）\ndate: 2017-12-10 20:53:00\ncategories: coder\ntags: [jenkins]\n-----------\n\n接上篇，继续踩坑，下面到构建触发器环节：\n<!-- more -->\n\n+ 构建触发器\n![image_1c0qnmug31v0hvkf1pp1kqf1bir9.png-91.5kB][1]\n能用到的发图所示，说明在下方，自行研究，需要注意的一点是图中的*号之间是有空格的；\n\n+ 构建环境\n这里又有一个超时，与上面的无关，这个是构建过程中的，根据需要添加，下面那个选项是时间戳；\n![image_1c0qooi0dkg7ls9abefu71n77p.png-38.6kB][2]\n\n接下来是Keychains和Mobile PP，必填项；\n![image_1c0qosdhm132q23k103kckp1dok16.png-8kB][3]\n\n逐个击破：\nKeychains部分\n![image_1c0qovfpn1n431vc7n8qonb8o51j.png-83.2kB][4]\n这个部分也是选择题，因为之前你已经上传了，但是这里会出现无法选择的bug，点保存刷新下页面就可以选了，Variables部分填如下：\n```\n${KEYCHAIN_PATH} ${KEYCHAIN_PASSWORD} ${CODE_SIGNING_IDENTITY}\n```\nMobile Provisioning Profiles部分\n![image_1c0qprhce18lu1vjb1pd1aakjv20.png-47.6kB][5]\n这个部分同上，请选择你确定的PP文件，一定要对应好：\n```\n${PROVISIONING_PROFILE}\n```\n\n+ 构建\n\n整个配置过程最重要的部分，大多数问题都出在这里，我这里目前到了Archive阶段，也就是说归档成功，然后归档结果可以用xcode进行ipa打包，具体打包还要设置一个shell脚本，网上好多，有的可以用有的不可以，所以打算研究下这个脚本，自己写一个再上传，之后会在博客中跟进，现在先继续把已完成的部分写下来；\n\n首先是先要加一个结束后的脚本，这个脚本不做打包操作，只是设置一下环境，以及配置一下有pod依赖的情况，如下：\n```\n#!/bin/bash -l\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\nexport LC_ALL=en_US.UTF-8\n\npod install --verbose --no-repo-update\nopen LeWaiJiao.xcworkspace\n```\n![image_1c0qqc2ubcfq5tvuui19m3oi89.png-47.4kB][6]\n\n下面的那个**Pack application,build and sign** .ipa项就是打ipa的功能，暂时没有搞通，后续会补上来，先跳过；\n\n![image_1c0qqnucp1np81vaj3rs1l7p1otdm.png-97.4kB][7]\n\n**Code signing & OS X keychain options**\n\n下面的bundleID是你要进行打包的bundleID，info.plist是workspace下的路径，注意一下下面的Development Team ID这个ID是你的钥匙串上的证书名称，后面括号里的那一串字符，由字母和数字组成的，需要你自己做对应，下面的照着抄就行了，password填你电脑用户的密码，不要填错了；\n\n![image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png-102.7kB][8]\n\n\n贴几个Error：\n=========\n\n```\nCode Signing Error: Code signing is required for product type 'Application' in SDK 'iOS 11.1'\n```\n需要你在xcode中设置，然后上传到你们的Git服务器再构建：\n![image_1c0qs83ul1baipc04otg331geb1g.png-35.4kB][9]\n\n```\nNo global development team or local team ID was configured.\n```\n\n就是之前说的**Development Team ID**部分，填了就解决了；\n[http://www.jianshu.com/p/8b2fc2da0466][10]\n\n```\nxcodebuild: error: The flag -scheme is required when specifying -archivePath but not -exportArchive.\n```\n这个问题也是个大坑，找了好久，也是搜狗找到的：\n[http://www.jianshu.com/p/8967e4e27e9b][11]\n[https://www.tuicool.com/articles/zQ73Q3Q][12]\n[https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc][13]\n\n解决方法最直接的就是指定scheme和xcode workspace file，分别填你xcode工程中的scheme和pod生成的xcworkspace的名字；\n![image_1c0r0aqt33tdthopme188a2kk1t.png-87.3kB][14]\n\n有些同学不知道scheme在什么地方，如下图所示：\n![image_1c0r0eai5f09qj47rs134c1upu2a.png-145.6kB][15]\n\n\n如上，能保证构建可以成功在Archive过程完成，如遇其他问题，欢迎评论区讨论；\n之后会再继续完成打包ipa以及上传平台，同时之前提过的SSH部分会持续跟近，因为SSH与本文所讨论的内容并不十分吻合，所以这里不作讨论。\n\n\n  [1]: http://static.zybuluo.com/usiege/it14w81rja3zme63xykjxy5o/image_1c0qnmug31v0hvkf1pp1kqf1bir9.png\n  [2]: http://static.zybuluo.com/usiege/pjeg3kt1s3cb0rxb2l1dfsfr/image_1c0qooi0dkg7ls9abefu71n77p.png\n  [3]: http://static.zybuluo.com/usiege/cjtc66sg8991c5ulj3uib8dq/image_1c0qosdhm132q23k103kckp1dok16.png\n  [4]: http://static.zybuluo.com/usiege/li5lfp7spsd6c3bw435besbb/image_1c0qovfpn1n431vc7n8qonb8o51j.png\n  [5]: http://static.zybuluo.com/usiege/1s0il4bxtsop1ame15pbq0ul/image_1c0qprhce18lu1vjb1pd1aakjv20.png\n  [6]: http://static.zybuluo.com/usiege/rxby0iwous3ppc63wyn1c83y/image_1c0qqc2ubcfq5tvuui19m3oi89.png\n  [7]: http://static.zybuluo.com/usiege/eceobb4arpah1xacmv2lmxrr/image_1c0qqnucp1np81vaj3rs1l7p1otdm.png\n  [8]: http://static.zybuluo.com/usiege/xhxhseh11fwg4wnbt8gpj95y/image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png\n  [9]: http://static.zybuluo.com/usiege/r85b8hxub85tfinbuzue1svp/image_1c0qs83ul1baipc04otg331geb1g.png\n  [10]: http://www.jianshu.com/p/8b2fc2da0466\n  [11]: http://www.jianshu.com/p/8967e4e27e9b\n  [12]: https://www.tuicool.com/articles/zQ73Q3Q\n  [13]: https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc\n  [14]: http://static.zybuluo.com/usiege/tlotqzvjbjlqk2ms1u43w2yd/image_1c0r0aqt33tdthopme188a2kk1t.png\n  [15]: http://static.zybuluo.com/usiege/1y4937ijhbvifle7jfgjg3ac/image_1c0r0eai5f09qj47rs134c1upu2a.png","slug":"Jenkins 100次构建失败踩坑全录（二）","published":1,"updated":"2018-05-04T08:49:16.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinh00021v602syk3hzt","content":"<p>接上篇，继续踩坑，下面到构建触发器环节：<br><a id=\"more\"></a></p>\n<ul>\n<li><p>构建触发器<br><img src=\"http://static.zybuluo.com/usiege/it14w81rja3zme63xykjxy5o/image_1c0qnmug31v0hvkf1pp1kqf1bir9.png\" alt=\"image_1c0qnmug31v0hvkf1pp1kqf1bir9.png-91.5kB\"><br>能用到的发图所示，说明在下方，自行研究，需要注意的一点是图中的*号之间是有空格的；</p>\n</li>\n<li><p>构建环境<br>这里又有一个超时，与上面的无关，这个是构建过程中的，根据需要添加，下面那个选项是时间戳；<br><img src=\"http://static.zybuluo.com/usiege/pjeg3kt1s3cb0rxb2l1dfsfr/image_1c0qooi0dkg7ls9abefu71n77p.png\" alt=\"image_1c0qooi0dkg7ls9abefu71n77p.png-38.6kB\"></p>\n</li>\n</ul>\n<p>接下来是Keychains和Mobile PP，必填项；<br><img src=\"http://static.zybuluo.com/usiege/cjtc66sg8991c5ulj3uib8dq/image_1c0qosdhm132q23k103kckp1dok16.png\" alt=\"image_1c0qosdhm132q23k103kckp1dok16.png-8kB\"></p>\n<p>逐个击破：<br>Keychains部分<br><img src=\"http://static.zybuluo.com/usiege/li5lfp7spsd6c3bw435besbb/image_1c0qovfpn1n431vc7n8qonb8o51j.png\" alt=\"image_1c0qovfpn1n431vc7n8qonb8o51j.png-83.2kB\"><br>这个部分也是选择题，因为之前你已经上传了，但是这里会出现无法选择的bug，点保存刷新下页面就可以选了，Variables部分填如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;KEYCHAIN_PATH&#125; $&#123;KEYCHAIN_PASSWORD&#125; $&#123;CODE_SIGNING_IDENTITY&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Mobile Provisioning Profiles部分<br><img src=\"http://static.zybuluo.com/usiege/1s0il4bxtsop1ame15pbq0ul/image_1c0qprhce18lu1vjb1pd1aakjv20.png\" alt=\"image_1c0qprhce18lu1vjb1pd1aakjv20.png-47.6kB\"><br>这个部分同上，请选择你确定的PP文件，一定要对应好：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;PROVISIONING_PROFILE&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>构建</li>\n</ul>\n<p>整个配置过程最重要的部分，大多数问题都出在这里，我这里目前到了Archive阶段，也就是说归档成功，然后归档结果可以用xcode进行ipa打包，具体打包还要设置一个shell脚本，网上好多，有的可以用有的不可以，所以打算研究下这个脚本，自己写一个再上传，之后会在博客中跟进，现在先继续把已完成的部分写下来；</p>\n<p>首先是先要加一个结束后的脚本，这个脚本不做打包操作，只是设置一下环境，以及配置一下有pod依赖的情况，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -l</span><br><span class=\"line\">export LANG=en_US.UTF-8</span><br><span class=\"line\">export LANGUAGE=en_US.UTF-8</span><br><span class=\"line\">export LC_ALL=en_US.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">pod install --verbose --no-repo-update</span><br><span class=\"line\">open LeWaiJiao.xcworkspace</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.zybuluo.com/usiege/rxby0iwous3ppc63wyn1c83y/image_1c0qqc2ubcfq5tvuui19m3oi89.png\" alt=\"image_1c0qqc2ubcfq5tvuui19m3oi89.png-47.4kB\"></p>\n<p>下面的那个<strong>Pack application,build and sign</strong> .ipa项就是打ipa的功能，暂时没有搞通，后续会补上来，先跳过；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/eceobb4arpah1xacmv2lmxrr/image_1c0qqnucp1np81vaj3rs1l7p1otdm.png\" alt=\"image_1c0qqnucp1np81vaj3rs1l7p1otdm.png-97.4kB\"></p>\n<p><strong>Code signing &amp; OS X keychain options</strong></p>\n<p>下面的bundleID是你要进行打包的bundleID，info.plist是workspace下的路径，注意一下下面的Development Team ID这个ID是你的钥匙串上的证书名称，后面括号里的那一串字符，由字母和数字组成的，需要你自己做对应，下面的照着抄就行了，password填你电脑用户的密码，不要填错了；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/xhxhseh11fwg4wnbt8gpj95y/image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png\" alt=\"image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png-102.7kB\"></p>\n<h1 id=\"贴几个Error：\"><a href=\"#贴几个Error：\" class=\"headerlink\" title=\"贴几个Error：\"></a>贴几个Error：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Code Signing Error: Code signing is required for product type &apos;Application&apos; in SDK &apos;iOS 11.1&apos;</span><br></pre></td></tr></table></figure>\n<p>需要你在xcode中设置，然后上传到你们的Git服务器再构建：<br><img src=\"http://static.zybuluo.com/usiege/r85b8hxub85tfinbuzue1svp/image_1c0qs83ul1baipc04otg331geb1g.png\" alt=\"image_1c0qs83ul1baipc04otg331geb1g.png-35.4kB\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No global development team or local team ID was configured.</span><br></pre></td></tr></table></figure>\n<p>就是之前说的<strong>Development Team ID</strong>部分，填了就解决了；<br><a href=\"http://www.jianshu.com/p/8b2fc2da0466\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8b2fc2da0466</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild: error: The flag -scheme is required when specifying -archivePath but not -exportArchive.</span><br></pre></td></tr></table></figure>\n<p>这个问题也是个大坑，找了好久，也是搜狗找到的：<br><a href=\"http://www.jianshu.com/p/8967e4e27e9b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8967e4e27e9b</a><br><a href=\"https://www.tuicool.com/articles/zQ73Q3Q\" target=\"_blank\" rel=\"noopener\">https://www.tuicool.com/articles/zQ73Q3Q</a><br><a href=\"https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc</a></p>\n<p>解决方法最直接的就是指定scheme和xcode workspace file，分别填你xcode工程中的scheme和pod生成的xcworkspace的名字；<br><img src=\"http://static.zybuluo.com/usiege/tlotqzvjbjlqk2ms1u43w2yd/image_1c0r0aqt33tdthopme188a2kk1t.png\" alt=\"image_1c0r0aqt33tdthopme188a2kk1t.png-87.3kB\"></p>\n<p>有些同学不知道scheme在什么地方，如下图所示：<br><img src=\"http://static.zybuluo.com/usiege/1y4937ijhbvifle7jfgjg3ac/image_1c0r0eai5f09qj47rs134c1upu2a.png\" alt=\"image_1c0r0eai5f09qj47rs134c1upu2a.png-145.6kB\"></p>\n<p>如上，能保证构建可以成功在Archive过程完成，如遇其他问题，欢迎评论区讨论；<br>之后会再继续完成打包ipa以及上传平台，同时之前提过的SSH部分会持续跟近，因为SSH与本文所讨论的内容并不十分吻合，所以这里不作讨论。</p>\n","site":{"data":{}},"excerpt":"<p>接上篇，继续踩坑，下面到构建触发器环节：<br>","more":"</p>\n<ul>\n<li><p>构建触发器<br><img src=\"http://static.zybuluo.com/usiege/it14w81rja3zme63xykjxy5o/image_1c0qnmug31v0hvkf1pp1kqf1bir9.png\" alt=\"image_1c0qnmug31v0hvkf1pp1kqf1bir9.png-91.5kB\"><br>能用到的发图所示，说明在下方，自行研究，需要注意的一点是图中的*号之间是有空格的；</p>\n</li>\n<li><p>构建环境<br>这里又有一个超时，与上面的无关，这个是构建过程中的，根据需要添加，下面那个选项是时间戳；<br><img src=\"http://static.zybuluo.com/usiege/pjeg3kt1s3cb0rxb2l1dfsfr/image_1c0qooi0dkg7ls9abefu71n77p.png\" alt=\"image_1c0qooi0dkg7ls9abefu71n77p.png-38.6kB\"></p>\n</li>\n</ul>\n<p>接下来是Keychains和Mobile PP，必填项；<br><img src=\"http://static.zybuluo.com/usiege/cjtc66sg8991c5ulj3uib8dq/image_1c0qosdhm132q23k103kckp1dok16.png\" alt=\"image_1c0qosdhm132q23k103kckp1dok16.png-8kB\"></p>\n<p>逐个击破：<br>Keychains部分<br><img src=\"http://static.zybuluo.com/usiege/li5lfp7spsd6c3bw435besbb/image_1c0qovfpn1n431vc7n8qonb8o51j.png\" alt=\"image_1c0qovfpn1n431vc7n8qonb8o51j.png-83.2kB\"><br>这个部分也是选择题，因为之前你已经上传了，但是这里会出现无法选择的bug，点保存刷新下页面就可以选了，Variables部分填如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;KEYCHAIN_PATH&#125; $&#123;KEYCHAIN_PASSWORD&#125; $&#123;CODE_SIGNING_IDENTITY&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Mobile Provisioning Profiles部分<br><img src=\"http://static.zybuluo.com/usiege/1s0il4bxtsop1ame15pbq0ul/image_1c0qprhce18lu1vjb1pd1aakjv20.png\" alt=\"image_1c0qprhce18lu1vjb1pd1aakjv20.png-47.6kB\"><br>这个部分同上，请选择你确定的PP文件，一定要对应好：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;PROVISIONING_PROFILE&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>构建</li>\n</ul>\n<p>整个配置过程最重要的部分，大多数问题都出在这里，我这里目前到了Archive阶段，也就是说归档成功，然后归档结果可以用xcode进行ipa打包，具体打包还要设置一个shell脚本，网上好多，有的可以用有的不可以，所以打算研究下这个脚本，自己写一个再上传，之后会在博客中跟进，现在先继续把已完成的部分写下来；</p>\n<p>首先是先要加一个结束后的脚本，这个脚本不做打包操作，只是设置一下环境，以及配置一下有pod依赖的情况，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -l</span><br><span class=\"line\">export LANG=en_US.UTF-8</span><br><span class=\"line\">export LANGUAGE=en_US.UTF-8</span><br><span class=\"line\">export LC_ALL=en_US.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">pod install --verbose --no-repo-update</span><br><span class=\"line\">open LeWaiJiao.xcworkspace</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://static.zybuluo.com/usiege/rxby0iwous3ppc63wyn1c83y/image_1c0qqc2ubcfq5tvuui19m3oi89.png\" alt=\"image_1c0qqc2ubcfq5tvuui19m3oi89.png-47.4kB\"></p>\n<p>下面的那个<strong>Pack application,build and sign</strong> .ipa项就是打ipa的功能，暂时没有搞通，后续会补上来，先跳过；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/eceobb4arpah1xacmv2lmxrr/image_1c0qqnucp1np81vaj3rs1l7p1otdm.png\" alt=\"image_1c0qqnucp1np81vaj3rs1l7p1otdm.png-97.4kB\"></p>\n<p><strong>Code signing &amp; OS X keychain options</strong></p>\n<p>下面的bundleID是你要进行打包的bundleID，info.plist是workspace下的路径，注意一下下面的Development Team ID这个ID是你的钥匙串上的证书名称，后面括号里的那一串字符，由字母和数字组成的，需要你自己做对应，下面的照着抄就行了，password填你电脑用户的密码，不要填错了；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/xhxhseh11fwg4wnbt8gpj95y/image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png\" alt=\"image_1c0qr7dli1unv1s7s1vu2ugm1fuh13.png-102.7kB\"></p>\n<h1 id=\"贴几个Error：\"><a href=\"#贴几个Error：\" class=\"headerlink\" title=\"贴几个Error：\"></a>贴几个Error：</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Code Signing Error: Code signing is required for product type &apos;Application&apos; in SDK &apos;iOS 11.1&apos;</span><br></pre></td></tr></table></figure>\n<p>需要你在xcode中设置，然后上传到你们的Git服务器再构建：<br><img src=\"http://static.zybuluo.com/usiege/r85b8hxub85tfinbuzue1svp/image_1c0qs83ul1baipc04otg331geb1g.png\" alt=\"image_1c0qs83ul1baipc04otg331geb1g.png-35.4kB\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No global development team or local team ID was configured.</span><br></pre></td></tr></table></figure>\n<p>就是之前说的<strong>Development Team ID</strong>部分，填了就解决了；<br><a href=\"http://www.jianshu.com/p/8b2fc2da0466\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8b2fc2da0466</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild: error: The flag -scheme is required when specifying -archivePath but not -exportArchive.</span><br></pre></td></tr></table></figure>\n<p>这个问题也是个大坑，找了好久，也是搜狗找到的：<br><a href=\"http://www.jianshu.com/p/8967e4e27e9b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8967e4e27e9b</a><br><a href=\"https://www.tuicool.com/articles/zQ73Q3Q\" target=\"_blank\" rel=\"noopener\">https://www.tuicool.com/articles/zQ73Q3Q</a><br><a href=\"https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/clang-scanbuild-plugin/commit/b970f5280a9c1929e9cd9d3b4d2b76a7d6cbc0dc</a></p>\n<p>解决方法最直接的就是指定scheme和xcode workspace file，分别填你xcode工程中的scheme和pod生成的xcworkspace的名字；<br><img src=\"http://static.zybuluo.com/usiege/tlotqzvjbjlqk2ms1u43w2yd/image_1c0r0aqt33tdthopme188a2kk1t.png\" alt=\"image_1c0r0aqt33tdthopme188a2kk1t.png-87.3kB\"></p>\n<p>有些同学不知道scheme在什么地方，如下图所示：<br><img src=\"http://static.zybuluo.com/usiege/1y4937ijhbvifle7jfgjg3ac/image_1c0r0eai5f09qj47rs134c1upu2a.png\" alt=\"image_1c0r0eai5f09qj47rs134c1upu2a.png-145.6kB\"></p>\n<p>如上，能保证构建可以成功在Archive过程完成，如遇其他问题，欢迎评论区讨论；<br>之后会再继续完成打包ipa以及上传平台，同时之前提过的SSH部分会持续跟近，因为SSH与本文所讨论的内容并不十分吻合，所以这里不作讨论。</p>"},{"title":"Jenkins 100次构建失败踩坑全录（一）","date":"2017-12-09T12:53:00.000Z","_content":"\n本文将以问题与解决方案的方式对Jenkins构建过程中的问题进行收录，后期会在评论中持续收集，如果有相同情况，请自行对照解决；\n<!-- more -->\n\n本文参考：\n手把手教你利用Jenkins持续集成iOS项目\nhttp://www.jianshu.com/p/41ecb06ae95f\n关于iOS-Jenkins进行持续集成项目部署\nhttp://www.jianshu.com/p/54c7daae6c94\niOS持续集成：Jenkins篇\nhttp://www.jianshu.com/p/faf879b3d182\n\n\n## 关卡1 ：\n安装Jenkins：首先你的电脑得有一个Java环境，接下来安装Jenkins。你可以直接去[Jenkins入口][1]网站，查看安装方式；\n当然你也可以使用以下方法：\n\n+ 安装homebrew\n```\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n+ 安装jenkins\n```\n$ brew install jenkins\n```\n安装成功后需要开启jenkins服务；\n\n## 关卡2 ：\n开启Jenkins服务：确认jenkins已安装，在终端进入到jenkins安装目录下，会有一个叫做jenkins.war的文件，\n```\n$ java -jar jenkins.war\n```\n或者在终端输入：\n```\n$ jenkins\n```\n当出现：\n![image_1c0ptnl2j13mh1mn2hmk18qf7usp.png-188.1kB][2]\n\n服务已经就位，可以开始进行配置了；\n\n这里还有两个命令用于jenkins开启和停用（Mac上）：\n```\n$ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n$ sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n如果是linux上也可以这样：\n```\n$ sudo systemctl status jenkins.service\n$ sudo systemctl start jenkins.service\n```\n不过实际操作过程中，可能会出现停用失败的情况，我的做法是直接打开活动监视器，在里面搜java服务，强制关闭掉；这里需要注意，如果服务没有停止再进行jenkins开启是不成功的，提示会告诉你已经在用：\n\n![image_1c0pu09in491qq31bqs25f1hbg26.png-222.9kB][3]\n\n如果你想查看是否jenkins在运行，使用命令查看：\n```\n$ ps aux | grep jenkins\n```\n\n## 关卡3 ：\n安装并开启完成就可以在浏览器里输入[localhost:8080][4]进行页面化配置了；\n安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入http://localhost:8080\n![image_1c0pvjgjqfbg3i01c371uhc1ves2j.png-27.6kB][5]\n\n这个时候可能会报一个错误。如果出现了这面的问题。出现这个问题的原因就是Java环境有问题，重启Java环境即可。\n\n这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开http://localhost:8080 会出现下图的重设初始密码的界面。\n\n![image_1c0pvl71n5dulcc413164i1hcp30.png-30.4kB][6]\n\n按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。\n\n![image_1c0pvm8al1tce1iled5voi216ac3d.png-200.2kB][7]\n\n打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图\n\n![image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png-99.6kB][8]\n\n一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。\n\n还是继续登录localhost:8080\n\n然而这一关还没有结束：\n写blog的时候我把自己设置的帐号注销了，然而当时设置的密码却忘记了，怎么都想不起来，怎么办呢？\n首先我想能不能用之前给的Jenkins帐户呢，经试错，未果；\n接下来上百度查了几种方法，有的方法很复杂，不打算用，我们只用最简单粗暴的；只要之前的帐号信息没有丢失，又可以进入系统就OK了，于是：\n\n![image_1c0q0bnonde9a9omqa1092a1747.png-85.9kB][9]\n\n注意实际操作过程中发现不是`/User/Shared/Jenkins/Home`下的config.xml，也不是`/User/Shared/Jenkins/Home/users`下的config.xml，而是**你自己用户目录**`~/.jenkins/`下的config.xml，具体原因可能是jenkins运行的工作空间是当前用户目录下的`.jenkins`，然后就是这样：\n\n![image_1c0q277tu152r9mg1dhg1edq8jp5q.png-55.9kB][10]\n\n经检验，无误，可进入，但是好像遗留了一个问题，就是这样进入的话就找不到管理用户的选项了；解决问题，勾选图中黄色圈，返回系统管理，出现管理用户（还是个隐藏道具）；\n![image_1c0q3ukis1vlhib71uij1729ohs67.png-33.1kB][11]\n\n![image_1c0q419b0164pqfe25d9br1fpt74.png-39.8kB][12]\n\n![image_1c0q42m3mvf41d8fjs21ptb1ae77h.png-11.4kB][13]\n\n搞的像是特工登录非授权帐户一样，不管怎么说，总算是攻破了，进入下一关；\n\n## 关卡 4：\n先不管工程构建里那一堆设置，我们先来搞一下证书Cer，钥匙Keychain，配置文件Provisioning Profiles的一些问题：\n首先去系统管理 -> 管理插件 -> 可选插件，搜索并安装Keychains and Provisioning Profiles Management插件；\n进入插件：\n![image_1c0qeblep1tcj4m319ap1bek783ah.png-31.1kB][14]\n\n不要关键去填下面的空，我会告诉你这是一道有选项的题目；进入文件目录，`Command + shift + G`，写下这样的路径`~/资源库/Keychains`，\n\n![image_1c0qekdqp9v712rd1gefjdr1fdcbe.png-62.2kB][15]\n\n这里我们把login.keychain-db上传到Jenkins里，但是Upload并不能上传这样后缀的文件，所以需要你手动把login.keychain-db修改成login.keychain（复制后再修改，以防止其他地方会引用到带-db）；上传完成后就会在下面出现你一些信息；然后打开你的钥匙串，这个知道在什么地方吧；\n\n![image_1c0qet898q8m118mk2s6kj1cq5eb.png-131kB][16]\n\n点击打包所用到的证书，将红色框中的名称复制出来，添加到identities中；\n\n![image_1c0qf02rofnpc3r121c1nlb1mqteo.png-42.7kB][17]\n\n如果有多个，则点击Add Code Signing Identity添加；\n\n然后是PP文件，这些文件需要我们从系统PP文件夹下复制到Jenkins资源文件夹下，如下图两个路径：\n这个是系统PP文件目录\n![image_1c0qkdte41j1rgq81k8v1bi19f4f5.png-144.2kB][18]\n这个是Jenkins PP文件目录\n![image_1c0qkkk833p0nt18andthn9qfi.png-79.2kB][19]\n\nProvisioning Profiles Directory Path 填写成，注意替换为自己的username：\n\n```\n/User/{USERNAME}/Library/MobileDevice/Provisioning Profiles\n```\n接着去你苹果帐号里去找你对应打包所需要的PP文件，然后点upload上传到Jenkins环境里；\n以上，证书部分解决；\n\n## 关卡 5\n创建项目过程我们会对各个需要的项进行逐个描述：\n点新建项目，输入项目名称，选择 构建一个自由风格的软件项目，然后确定，进入配置页面。\n![image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png-8.2kB][20]\n\n+ General\n这个部分的内容都很浅显，没有什么可以说的，根据需要自行填充；这里说一下GitLab connection选项，因为我自己的工程是用gitlab管理的代码，所以需要在Jenkins里下一个Gitlab的插件，然后在里面进行帐号配置，可以采用帐号密码以及SSH的方式，具体这个部分会有一个SSH的坑，先不作分析，后面会讲到，我这里先用帐号密码的方式进行构建，经检验发现SSH方式非必要；\n\n**Credentials**在这里配置：\n![image_1c0qljaq610ljc02k6g1r821fs5gc.png-78.2kB][21]\n\n+ 源码管理\n这里我选的Git，**Repository URL**填你工程的git地址，选用帐号密码的形式应该是以http或https开头的，**Credentials**填你在上一步中新建好的，\n![image_1c0qlt20313duogl2g51hp11nqsgp.png-73kB][22]\n**Branch Specifier (blank for 'any')**\t填你要进行构建的分支，我这里是`*/release`；\n\n这里我们PS一个隐藏BOSS：\n```\nreturned status code 143 jenkins\nERROR: Error fetching remote repo ‘origin’\n```\n这个报错是工程配置结束后进行构建后提示的，我当时搞这个发现远程代码明明是已经拉取到本地的，只是在拉取过程中会发生中断，本人在进行了将近50次试错后发现这个拉取到本地的代码率是变化的，先前以为是SSH帐号的问题，于是转头花了一天的时间搞了下SSH，后来SSH搞通后发现该问题仍然存在，后来终于在经历百度，谷歌，搜狗也用上的（不得不说有时候百度搜不出来的搜狗能搜到），发现了几篇有用的，后来解决，也算是不负辛苦，后面有踩坑的伙伴多注意，前车之鉴后事之师；\n\n[http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html][23]\n[https://issues.jenkins-ci.org/browse/JENKINS-20445][24]\n[https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh][25]\n\n解决方案就在于这个**Timeout**，相信你看了这个单词就知道是怎么回事了：\n![image_1c0qmnlafh2p1j571b4ettv1ncah6.png-74.3kB][26]\n\n另顺便粘一个code 128的链接，是个与该问题相关的问题，因为这些问题关键字有的重复，所以搜出来的文章有时会误导，所以请仔细辨别：\n```\nreturned status code 128 jenkins\nERROR: Error cloning remote repo 'origin'\nstderr: Permission denied (publickey).\n```\n[http://wantcoding.com/?p=293][27]\n[这个链接是附送的，进去多看看你会有惊喜，还有QQ群哦][28]\n\n\n\n  [1]: https://jenkins.io\n  [2]: http://static.zybuluo.com/usiege/uowhxmph61xngu3l2t4hxamh/image_1c0ptnl2j13mh1mn2hmk18qf7usp.png\n  [3]: http://static.zybuluo.com/usiege/s46xl40yzd7t5gijpwdippc9/image_1c0pu09in491qq31bqs25f1hbg26.png\n  [4]: localhost:8080\n  [5]: http://static.zybuluo.com/usiege/fn2f1wx006r3chny2t5u9atc/image_1c0pvjgjqfbg3i01c371uhc1ves2j.png\n  [6]: http://static.zybuluo.com/usiege/sfnjgdq201o27xta3ttqllkr/image_1c0pvl71n5dulcc413164i1hcp30.png\n  [7]: http://static.zybuluo.com/usiege/ltc8z86hbmzy78857uo767zr/image_1c0pvm8al1tce1iled5voi216ac3d.png\n  [8]: http://static.zybuluo.com/usiege/ub5cnhcl82hyed8j8aqghlna/image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png\n  [9]: http://static.zybuluo.com/usiege/ihh8n31m9fb1r9gomahd7l6d/image_1c0q0bnonde9a9omqa1092a1747.png\n  [10]: http://static.zybuluo.com/usiege/rmn1oao4inl6rvryb8ne596c/image_1c0q277tu152r9mg1dhg1edq8jp5q.png\n  [11]: http://static.zybuluo.com/usiege/v5zxzwu4pex59s78odynkkd6/image_1c0q3ukis1vlhib71uij1729ohs67.png\n  [12]: http://static.zybuluo.com/usiege/bxyfaeid922e3lf7dvuz9mh8/image_1c0q419b0164pqfe25d9br1fpt74.png\n  [13]: http://static.zybuluo.com/usiege/burf10v126vjx00u2ym0h2bn/image_1c0q42m3mvf41d8fjs21ptb1ae77h.png\n  [14]: http://static.zybuluo.com/usiege/kgy8eq7ug16g0o1o4eotp3bw/image_1c0qeblep1tcj4m319ap1bek783ah.png\n  [15]: http://static.zybuluo.com/usiege/ebpz8l8bnnvlrr6oi3a0423h/image_1c0qekdqp9v712rd1gefjdr1fdcbe.png\n  [16]: http://static.zybuluo.com/usiege/w9l7f921rn6he0vx1vcqmu6a/image_1c0qet898q8m118mk2s6kj1cq5eb.png\n  [17]: http://static.zybuluo.com/usiege/zc1wu103t1woz01fp07s80b7/image_1c0qf02rofnpc3r121c1nlb1mqteo.png\n  [18]: http://static.zybuluo.com/usiege/peonwampxc6wa9h3i2yuhfm5/image_1c0qkdte41j1rgq81k8v1bi19f4f5.png\n  [19]: http://static.zybuluo.com/usiege/v0firte6p13gwec9a133ixi1/image_1c0qkkk833p0nt18andthn9qfi.png\n  [20]: http://static.zybuluo.com/usiege/1ytel52lwidafke7uv5rmgb0/image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png\n  [21]: http://static.zybuluo.com/usiege/f6pv0rsip2oirn32m01agp1l/image_1c0qljaq610ljc02k6g1r821fs5gc.png\n  [22]: http://static.zybuluo.com/usiege/bzufeuzktht55r97i2bsem18/image_1c0qlt20313duogl2g51hp11nqsgp.png\n  [23]: http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html\n  [24]: https://issues.jenkins-ci.org/browse/JENKINS-20445\n  [25]: https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh\n  [26]: http://static.zybuluo.com/usiege/firl86lawiru1uvz1jhelb28/image_1c0qmnlafh2p1j571b4ettv1ncah6.png\n  [27]: http://wantcoding.com/?p=293\n  [28]: http://www.cnblogs.com/EasonJim/p/6266892.html","source":"_posts/Jenkins 100次构建失败踩坑全录（一）.md","raw":"title: Jenkins 100次构建失败踩坑全录（一）\ndate: 2017-12-09 20:53:00\ncategories: coder\ntags: [jenkins]\n-----------\n\n本文将以问题与解决方案的方式对Jenkins构建过程中的问题进行收录，后期会在评论中持续收集，如果有相同情况，请自行对照解决；\n<!-- more -->\n\n本文参考：\n手把手教你利用Jenkins持续集成iOS项目\nhttp://www.jianshu.com/p/41ecb06ae95f\n关于iOS-Jenkins进行持续集成项目部署\nhttp://www.jianshu.com/p/54c7daae6c94\niOS持续集成：Jenkins篇\nhttp://www.jianshu.com/p/faf879b3d182\n\n\n## 关卡1 ：\n安装Jenkins：首先你的电脑得有一个Java环境，接下来安装Jenkins。你可以直接去[Jenkins入口][1]网站，查看安装方式；\n当然你也可以使用以下方法：\n\n+ 安装homebrew\n```\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n+ 安装jenkins\n```\n$ brew install jenkins\n```\n安装成功后需要开启jenkins服务；\n\n## 关卡2 ：\n开启Jenkins服务：确认jenkins已安装，在终端进入到jenkins安装目录下，会有一个叫做jenkins.war的文件，\n```\n$ java -jar jenkins.war\n```\n或者在终端输入：\n```\n$ jenkins\n```\n当出现：\n![image_1c0ptnl2j13mh1mn2hmk18qf7usp.png-188.1kB][2]\n\n服务已经就位，可以开始进行配置了；\n\n这里还有两个命令用于jenkins开启和停用（Mac上）：\n```\n$ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n$ sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n如果是linux上也可以这样：\n```\n$ sudo systemctl status jenkins.service\n$ sudo systemctl start jenkins.service\n```\n不过实际操作过程中，可能会出现停用失败的情况，我的做法是直接打开活动监视器，在里面搜java服务，强制关闭掉；这里需要注意，如果服务没有停止再进行jenkins开启是不成功的，提示会告诉你已经在用：\n\n![image_1c0pu09in491qq31bqs25f1hbg26.png-222.9kB][3]\n\n如果你想查看是否jenkins在运行，使用命令查看：\n```\n$ ps aux | grep jenkins\n```\n\n## 关卡3 ：\n安装并开启完成就可以在浏览器里输入[localhost:8080][4]进行页面化配置了；\n安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入http://localhost:8080\n![image_1c0pvjgjqfbg3i01c371uhc1ves2j.png-27.6kB][5]\n\n这个时候可能会报一个错误。如果出现了这面的问题。出现这个问题的原因就是Java环境有问题，重启Java环境即可。\n\n这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开http://localhost:8080 会出现下图的重设初始密码的界面。\n\n![image_1c0pvl71n5dulcc413164i1hcp30.png-30.4kB][6]\n\n按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。\n\n![image_1c0pvm8al1tce1iled5voi216ac3d.png-200.2kB][7]\n\n打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图\n\n![image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png-99.6kB][8]\n\n一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。\n\n还是继续登录localhost:8080\n\n然而这一关还没有结束：\n写blog的时候我把自己设置的帐号注销了，然而当时设置的密码却忘记了，怎么都想不起来，怎么办呢？\n首先我想能不能用之前给的Jenkins帐户呢，经试错，未果；\n接下来上百度查了几种方法，有的方法很复杂，不打算用，我们只用最简单粗暴的；只要之前的帐号信息没有丢失，又可以进入系统就OK了，于是：\n\n![image_1c0q0bnonde9a9omqa1092a1747.png-85.9kB][9]\n\n注意实际操作过程中发现不是`/User/Shared/Jenkins/Home`下的config.xml，也不是`/User/Shared/Jenkins/Home/users`下的config.xml，而是**你自己用户目录**`~/.jenkins/`下的config.xml，具体原因可能是jenkins运行的工作空间是当前用户目录下的`.jenkins`，然后就是这样：\n\n![image_1c0q277tu152r9mg1dhg1edq8jp5q.png-55.9kB][10]\n\n经检验，无误，可进入，但是好像遗留了一个问题，就是这样进入的话就找不到管理用户的选项了；解决问题，勾选图中黄色圈，返回系统管理，出现管理用户（还是个隐藏道具）；\n![image_1c0q3ukis1vlhib71uij1729ohs67.png-33.1kB][11]\n\n![image_1c0q419b0164pqfe25d9br1fpt74.png-39.8kB][12]\n\n![image_1c0q42m3mvf41d8fjs21ptb1ae77h.png-11.4kB][13]\n\n搞的像是特工登录非授权帐户一样，不管怎么说，总算是攻破了，进入下一关；\n\n## 关卡 4：\n先不管工程构建里那一堆设置，我们先来搞一下证书Cer，钥匙Keychain，配置文件Provisioning Profiles的一些问题：\n首先去系统管理 -> 管理插件 -> 可选插件，搜索并安装Keychains and Provisioning Profiles Management插件；\n进入插件：\n![image_1c0qeblep1tcj4m319ap1bek783ah.png-31.1kB][14]\n\n不要关键去填下面的空，我会告诉你这是一道有选项的题目；进入文件目录，`Command + shift + G`，写下这样的路径`~/资源库/Keychains`，\n\n![image_1c0qekdqp9v712rd1gefjdr1fdcbe.png-62.2kB][15]\n\n这里我们把login.keychain-db上传到Jenkins里，但是Upload并不能上传这样后缀的文件，所以需要你手动把login.keychain-db修改成login.keychain（复制后再修改，以防止其他地方会引用到带-db）；上传完成后就会在下面出现你一些信息；然后打开你的钥匙串，这个知道在什么地方吧；\n\n![image_1c0qet898q8m118mk2s6kj1cq5eb.png-131kB][16]\n\n点击打包所用到的证书，将红色框中的名称复制出来，添加到identities中；\n\n![image_1c0qf02rofnpc3r121c1nlb1mqteo.png-42.7kB][17]\n\n如果有多个，则点击Add Code Signing Identity添加；\n\n然后是PP文件，这些文件需要我们从系统PP文件夹下复制到Jenkins资源文件夹下，如下图两个路径：\n这个是系统PP文件目录\n![image_1c0qkdte41j1rgq81k8v1bi19f4f5.png-144.2kB][18]\n这个是Jenkins PP文件目录\n![image_1c0qkkk833p0nt18andthn9qfi.png-79.2kB][19]\n\nProvisioning Profiles Directory Path 填写成，注意替换为自己的username：\n\n```\n/User/{USERNAME}/Library/MobileDevice/Provisioning Profiles\n```\n接着去你苹果帐号里去找你对应打包所需要的PP文件，然后点upload上传到Jenkins环境里；\n以上，证书部分解决；\n\n## 关卡 5\n创建项目过程我们会对各个需要的项进行逐个描述：\n点新建项目，输入项目名称，选择 构建一个自由风格的软件项目，然后确定，进入配置页面。\n![image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png-8.2kB][20]\n\n+ General\n这个部分的内容都很浅显，没有什么可以说的，根据需要自行填充；这里说一下GitLab connection选项，因为我自己的工程是用gitlab管理的代码，所以需要在Jenkins里下一个Gitlab的插件，然后在里面进行帐号配置，可以采用帐号密码以及SSH的方式，具体这个部分会有一个SSH的坑，先不作分析，后面会讲到，我这里先用帐号密码的方式进行构建，经检验发现SSH方式非必要；\n\n**Credentials**在这里配置：\n![image_1c0qljaq610ljc02k6g1r821fs5gc.png-78.2kB][21]\n\n+ 源码管理\n这里我选的Git，**Repository URL**填你工程的git地址，选用帐号密码的形式应该是以http或https开头的，**Credentials**填你在上一步中新建好的，\n![image_1c0qlt20313duogl2g51hp11nqsgp.png-73kB][22]\n**Branch Specifier (blank for 'any')**\t填你要进行构建的分支，我这里是`*/release`；\n\n这里我们PS一个隐藏BOSS：\n```\nreturned status code 143 jenkins\nERROR: Error fetching remote repo ‘origin’\n```\n这个报错是工程配置结束后进行构建后提示的，我当时搞这个发现远程代码明明是已经拉取到本地的，只是在拉取过程中会发生中断，本人在进行了将近50次试错后发现这个拉取到本地的代码率是变化的，先前以为是SSH帐号的问题，于是转头花了一天的时间搞了下SSH，后来SSH搞通后发现该问题仍然存在，后来终于在经历百度，谷歌，搜狗也用上的（不得不说有时候百度搜不出来的搜狗能搜到），发现了几篇有用的，后来解决，也算是不负辛苦，后面有踩坑的伙伴多注意，前车之鉴后事之师；\n\n[http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html][23]\n[https://issues.jenkins-ci.org/browse/JENKINS-20445][24]\n[https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh][25]\n\n解决方案就在于这个**Timeout**，相信你看了这个单词就知道是怎么回事了：\n![image_1c0qmnlafh2p1j571b4ettv1ncah6.png-74.3kB][26]\n\n另顺便粘一个code 128的链接，是个与该问题相关的问题，因为这些问题关键字有的重复，所以搜出来的文章有时会误导，所以请仔细辨别：\n```\nreturned status code 128 jenkins\nERROR: Error cloning remote repo 'origin'\nstderr: Permission denied (publickey).\n```\n[http://wantcoding.com/?p=293][27]\n[这个链接是附送的，进去多看看你会有惊喜，还有QQ群哦][28]\n\n\n\n  [1]: https://jenkins.io\n  [2]: http://static.zybuluo.com/usiege/uowhxmph61xngu3l2t4hxamh/image_1c0ptnl2j13mh1mn2hmk18qf7usp.png\n  [3]: http://static.zybuluo.com/usiege/s46xl40yzd7t5gijpwdippc9/image_1c0pu09in491qq31bqs25f1hbg26.png\n  [4]: localhost:8080\n  [5]: http://static.zybuluo.com/usiege/fn2f1wx006r3chny2t5u9atc/image_1c0pvjgjqfbg3i01c371uhc1ves2j.png\n  [6]: http://static.zybuluo.com/usiege/sfnjgdq201o27xta3ttqllkr/image_1c0pvl71n5dulcc413164i1hcp30.png\n  [7]: http://static.zybuluo.com/usiege/ltc8z86hbmzy78857uo767zr/image_1c0pvm8al1tce1iled5voi216ac3d.png\n  [8]: http://static.zybuluo.com/usiege/ub5cnhcl82hyed8j8aqghlna/image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png\n  [9]: http://static.zybuluo.com/usiege/ihh8n31m9fb1r9gomahd7l6d/image_1c0q0bnonde9a9omqa1092a1747.png\n  [10]: http://static.zybuluo.com/usiege/rmn1oao4inl6rvryb8ne596c/image_1c0q277tu152r9mg1dhg1edq8jp5q.png\n  [11]: http://static.zybuluo.com/usiege/v5zxzwu4pex59s78odynkkd6/image_1c0q3ukis1vlhib71uij1729ohs67.png\n  [12]: http://static.zybuluo.com/usiege/bxyfaeid922e3lf7dvuz9mh8/image_1c0q419b0164pqfe25d9br1fpt74.png\n  [13]: http://static.zybuluo.com/usiege/burf10v126vjx00u2ym0h2bn/image_1c0q42m3mvf41d8fjs21ptb1ae77h.png\n  [14]: http://static.zybuluo.com/usiege/kgy8eq7ug16g0o1o4eotp3bw/image_1c0qeblep1tcj4m319ap1bek783ah.png\n  [15]: http://static.zybuluo.com/usiege/ebpz8l8bnnvlrr6oi3a0423h/image_1c0qekdqp9v712rd1gefjdr1fdcbe.png\n  [16]: http://static.zybuluo.com/usiege/w9l7f921rn6he0vx1vcqmu6a/image_1c0qet898q8m118mk2s6kj1cq5eb.png\n  [17]: http://static.zybuluo.com/usiege/zc1wu103t1woz01fp07s80b7/image_1c0qf02rofnpc3r121c1nlb1mqteo.png\n  [18]: http://static.zybuluo.com/usiege/peonwampxc6wa9h3i2yuhfm5/image_1c0qkdte41j1rgq81k8v1bi19f4f5.png\n  [19]: http://static.zybuluo.com/usiege/v0firte6p13gwec9a133ixi1/image_1c0qkkk833p0nt18andthn9qfi.png\n  [20]: http://static.zybuluo.com/usiege/1ytel52lwidafke7uv5rmgb0/image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png\n  [21]: http://static.zybuluo.com/usiege/f6pv0rsip2oirn32m01agp1l/image_1c0qljaq610ljc02k6g1r821fs5gc.png\n  [22]: http://static.zybuluo.com/usiege/bzufeuzktht55r97i2bsem18/image_1c0qlt20313duogl2g51hp11nqsgp.png\n  [23]: http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html\n  [24]: https://issues.jenkins-ci.org/browse/JENKINS-20445\n  [25]: https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh\n  [26]: http://static.zybuluo.com/usiege/firl86lawiru1uvz1jhelb28/image_1c0qmnlafh2p1j571b4ettv1ncah6.png\n  [27]: http://wantcoding.com/?p=293\n  [28]: http://www.cnblogs.com/EasonJim/p/6266892.html","slug":"Jenkins 100次构建失败踩坑全录（一）","published":1,"updated":"2018-05-04T08:49:15.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinm00061v60yd2ajvp0","content":"<p>本文将以问题与解决方案的方式对Jenkins构建过程中的问题进行收录，后期会在评论中持续收集，如果有相同情况，请自行对照解决；<br><a id=\"more\"></a></p>\n<p>本文参考：<br>手把手教你利用Jenkins持续集成iOS项目<br><a href=\"http://www.jianshu.com/p/41ecb06ae95f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/41ecb06ae95f</a><br>关于iOS-Jenkins进行持续集成项目部署<br><a href=\"http://www.jianshu.com/p/54c7daae6c94\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/54c7daae6c94</a><br>iOS持续集成：Jenkins篇<br><a href=\"http://www.jianshu.com/p/faf879b3d182\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/faf879b3d182</a></p>\n<h2 id=\"关卡1-：\"><a href=\"#关卡1-：\" class=\"headerlink\" title=\"关卡1 ：\"></a>关卡1 ：</h2><p>安装Jenkins：首先你的电脑得有一个Java环境，接下来安装Jenkins。你可以直接去<a href=\"https://jenkins.io\" target=\"_blank\" rel=\"noopener\">Jenkins入口</a>网站，查看安装方式；<br>当然你也可以使用以下方法：</p>\n<ul>\n<li><p>安装homebrew</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>安装成功后需要开启jenkins服务；</p>\n<h2 id=\"关卡2-：\"><a href=\"#关卡2-：\" class=\"headerlink\" title=\"关卡2 ：\"></a>关卡2 ：</h2><p>开启Jenkins服务：确认jenkins已安装，在终端进入到jenkins安装目录下，会有一个叫做jenkins.war的文件，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -jar jenkins.war</span><br></pre></td></tr></table></figure></p>\n<p>或者在终端输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jenkins</span><br></pre></td></tr></table></figure></p>\n<p>当出现：<br><img src=\"http://static.zybuluo.com/usiege/uowhxmph61xngu3l2t4hxamh/image_1c0ptnl2j13mh1mn2hmk18qf7usp.png\" alt=\"image_1c0ptnl2j13mh1mn2hmk18qf7usp.png-188.1kB\"></p>\n<p>服务已经就位，可以开始进行配置了；</p>\n<p>这里还有两个命令用于jenkins开启和停用（Mac上）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</span><br><span class=\"line\">$ sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</span><br></pre></td></tr></table></figure></p>\n<p>如果是linux上也可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl status jenkins.service</span><br><span class=\"line\">$ sudo systemctl start jenkins.service</span><br></pre></td></tr></table></figure></p>\n<p>不过实际操作过程中，可能会出现停用失败的情况，我的做法是直接打开活动监视器，在里面搜java服务，强制关闭掉；这里需要注意，如果服务没有停止再进行jenkins开启是不成功的，提示会告诉你已经在用：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/s46xl40yzd7t5gijpwdippc9/image_1c0pu09in491qq31bqs25f1hbg26.png\" alt=\"image_1c0pu09in491qq31bqs25f1hbg26.png-222.9kB\"></p>\n<p>如果你想查看是否jenkins在运行，使用命令查看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | grep jenkins</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关卡3-：\"><a href=\"#关卡3-：\" class=\"headerlink\" title=\"关卡3 ：\"></a>关卡3 ：</h2><p>安装并开启完成就可以在浏览器里输入<a href=\"localhost:8080\" target=\"_blank\" rel=\"noopener\">localhost:8080</a>进行页面化配置了；<br>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a><br><img src=\"http://static.zybuluo.com/usiege/fn2f1wx006r3chny2t5u9atc/image_1c0pvjgjqfbg3i01c371uhc1ves2j.png\" alt=\"image_1c0pvjgjqfbg3i01c371uhc1ves2j.png-27.6kB\"></p>\n<p>这个时候可能会报一个错误。如果出现了这面的问题。出现这个问题的原因就是Java环境有问题，重启Java环境即可。</p>\n<p>这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 会出现下图的重设初始密码的界面。</p>\n<p><img src=\"http://static.zybuluo.com/usiege/sfnjgdq201o27xta3ttqllkr/image_1c0pvl71n5dulcc413164i1hcp30.png\" alt=\"image_1c0pvl71n5dulcc413164i1hcp30.png-30.4kB\"></p>\n<p>按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ltc8z86hbmzy78857uo767zr/image_1c0pvm8al1tce1iled5voi216ac3d.png\" alt=\"image_1c0pvm8al1tce1iled5voi216ac3d.png-200.2kB\"></p>\n<p>打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ub5cnhcl82hyed8j8aqghlna/image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png\" alt=\"image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png-99.6kB\"></p>\n<p>一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。</p>\n<p>还是继续登录localhost:8080</p>\n<p>然而这一关还没有结束：<br>写blog的时候我把自己设置的帐号注销了，然而当时设置的密码却忘记了，怎么都想不起来，怎么办呢？<br>首先我想能不能用之前给的Jenkins帐户呢，经试错，未果；<br>接下来上百度查了几种方法，有的方法很复杂，不打算用，我们只用最简单粗暴的；只要之前的帐号信息没有丢失，又可以进入系统就OK了，于是：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ihh8n31m9fb1r9gomahd7l6d/image_1c0q0bnonde9a9omqa1092a1747.png\" alt=\"image_1c0q0bnonde9a9omqa1092a1747.png-85.9kB\"></p>\n<p>注意实际操作过程中发现不是<code>/User/Shared/Jenkins/Home</code>下的config.xml，也不是<code>/User/Shared/Jenkins/Home/users</code>下的config.xml，而是<strong>你自己用户目录</strong><code>~/.jenkins/</code>下的config.xml，具体原因可能是jenkins运行的工作空间是当前用户目录下的<code>.jenkins</code>，然后就是这样：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/rmn1oao4inl6rvryb8ne596c/image_1c0q277tu152r9mg1dhg1edq8jp5q.png\" alt=\"image_1c0q277tu152r9mg1dhg1edq8jp5q.png-55.9kB\"></p>\n<p>经检验，无误，可进入，但是好像遗留了一个问题，就是这样进入的话就找不到管理用户的选项了；解决问题，勾选图中黄色圈，返回系统管理，出现管理用户（还是个隐藏道具）；<br><img src=\"http://static.zybuluo.com/usiege/v5zxzwu4pex59s78odynkkd6/image_1c0q3ukis1vlhib71uij1729ohs67.png\" alt=\"image_1c0q3ukis1vlhib71uij1729ohs67.png-33.1kB\"></p>\n<p><img src=\"http://static.zybuluo.com/usiege/bxyfaeid922e3lf7dvuz9mh8/image_1c0q419b0164pqfe25d9br1fpt74.png\" alt=\"image_1c0q419b0164pqfe25d9br1fpt74.png-39.8kB\"></p>\n<p><img src=\"http://static.zybuluo.com/usiege/burf10v126vjx00u2ym0h2bn/image_1c0q42m3mvf41d8fjs21ptb1ae77h.png\" alt=\"image_1c0q42m3mvf41d8fjs21ptb1ae77h.png-11.4kB\"></p>\n<p>搞的像是特工登录非授权帐户一样，不管怎么说，总算是攻破了，进入下一关；</p>\n<h2 id=\"关卡-4：\"><a href=\"#关卡-4：\" class=\"headerlink\" title=\"关卡 4：\"></a>关卡 4：</h2><p>先不管工程构建里那一堆设置，我们先来搞一下证书Cer，钥匙Keychain，配置文件Provisioning Profiles的一些问题：<br>首先去系统管理 -&gt; 管理插件 -&gt; 可选插件，搜索并安装Keychains and Provisioning Profiles Management插件；<br>进入插件：<br><img src=\"http://static.zybuluo.com/usiege/kgy8eq7ug16g0o1o4eotp3bw/image_1c0qeblep1tcj4m319ap1bek783ah.png\" alt=\"image_1c0qeblep1tcj4m319ap1bek783ah.png-31.1kB\"></p>\n<p>不要关键去填下面的空，我会告诉你这是一道有选项的题目；进入文件目录，<code>Command + shift + G</code>，写下这样的路径<code>~/资源库/Keychains</code>，</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ebpz8l8bnnvlrr6oi3a0423h/image_1c0qekdqp9v712rd1gefjdr1fdcbe.png\" alt=\"image_1c0qekdqp9v712rd1gefjdr1fdcbe.png-62.2kB\"></p>\n<p>这里我们把login.keychain-db上传到Jenkins里，但是Upload并不能上传这样后缀的文件，所以需要你手动把login.keychain-db修改成login.keychain（复制后再修改，以防止其他地方会引用到带-db）；上传完成后就会在下面出现你一些信息；然后打开你的钥匙串，这个知道在什么地方吧；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/w9l7f921rn6he0vx1vcqmu6a/image_1c0qet898q8m118mk2s6kj1cq5eb.png\" alt=\"image_1c0qet898q8m118mk2s6kj1cq5eb.png-131kB\"></p>\n<p>点击打包所用到的证书，将红色框中的名称复制出来，添加到identities中；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/zc1wu103t1woz01fp07s80b7/image_1c0qf02rofnpc3r121c1nlb1mqteo.png\" alt=\"image_1c0qf02rofnpc3r121c1nlb1mqteo.png-42.7kB\"></p>\n<p>如果有多个，则点击Add Code Signing Identity添加；</p>\n<p>然后是PP文件，这些文件需要我们从系统PP文件夹下复制到Jenkins资源文件夹下，如下图两个路径：<br>这个是系统PP文件目录<br><img src=\"http://static.zybuluo.com/usiege/peonwampxc6wa9h3i2yuhfm5/image_1c0qkdte41j1rgq81k8v1bi19f4f5.png\" alt=\"image_1c0qkdte41j1rgq81k8v1bi19f4f5.png-144.2kB\"><br>这个是Jenkins PP文件目录<br><img src=\"http://static.zybuluo.com/usiege/v0firte6p13gwec9a133ixi1/image_1c0qkkk833p0nt18andthn9qfi.png\" alt=\"image_1c0qkkk833p0nt18andthn9qfi.png-79.2kB\"></p>\n<p>Provisioning Profiles Directory Path 填写成，注意替换为自己的username：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/User/&#123;USERNAME&#125;/Library/MobileDevice/Provisioning Profiles</span><br></pre></td></tr></table></figure>\n<p>接着去你苹果帐号里去找你对应打包所需要的PP文件，然后点upload上传到Jenkins环境里；<br>以上，证书部分解决；</p>\n<h2 id=\"关卡-5\"><a href=\"#关卡-5\" class=\"headerlink\" title=\"关卡 5\"></a>关卡 5</h2><p>创建项目过程我们会对各个需要的项进行逐个描述：<br>点新建项目，输入项目名称，选择 构建一个自由风格的软件项目，然后确定，进入配置页面。<br><img src=\"http://static.zybuluo.com/usiege/1ytel52lwidafke7uv5rmgb0/image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png\" alt=\"image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png-8.2kB\"></p>\n<ul>\n<li>General<br>这个部分的内容都很浅显，没有什么可以说的，根据需要自行填充；这里说一下GitLab connection选项，因为我自己的工程是用gitlab管理的代码，所以需要在Jenkins里下一个Gitlab的插件，然后在里面进行帐号配置，可以采用帐号密码以及SSH的方式，具体这个部分会有一个SSH的坑，先不作分析，后面会讲到，我这里先用帐号密码的方式进行构建，经检验发现SSH方式非必要；</li>\n</ul>\n<p><strong>Credentials</strong>在这里配置：<br><img src=\"http://static.zybuluo.com/usiege/f6pv0rsip2oirn32m01agp1l/image_1c0qljaq610ljc02k6g1r821fs5gc.png\" alt=\"image_1c0qljaq610ljc02k6g1r821fs5gc.png-78.2kB\"></p>\n<ul>\n<li>源码管理<br>这里我选的Git，<strong>Repository URL</strong>填你工程的git地址，选用帐号密码的形式应该是以http或https开头的，<strong>Credentials</strong>填你在上一步中新建好的，<br><img src=\"http://static.zybuluo.com/usiege/bzufeuzktht55r97i2bsem18/image_1c0qlt20313duogl2g51hp11nqsgp.png\" alt=\"image_1c0qlt20313duogl2g51hp11nqsgp.png-73kB\"><br><strong>Branch Specifier (blank for ‘any’)</strong>    填你要进行构建的分支，我这里是<code>*/release</code>；</li>\n</ul>\n<p>这里我们PS一个隐藏BOSS：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returned status code 143 jenkins</span><br><span class=\"line\">ERROR: Error fetching remote repo ‘origin’</span><br></pre></td></tr></table></figure></p>\n<p>这个报错是工程配置结束后进行构建后提示的，我当时搞这个发现远程代码明明是已经拉取到本地的，只是在拉取过程中会发生中断，本人在进行了将近50次试错后发现这个拉取到本地的代码率是变化的，先前以为是SSH帐号的问题，于是转头花了一天的时间搞了下SSH，后来SSH搞通后发现该问题仍然存在，后来终于在经历百度，谷歌，搜狗也用上的（不得不说有时候百度搜不出来的搜狗能搜到），发现了几篇有用的，后来解决，也算是不负辛苦，后面有踩坑的伙伴多注意，前车之鉴后事之师；</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html</a><br><a href=\"https://issues.jenkins-ci.org/browse/JENKINS-20445\" target=\"_blank\" rel=\"noopener\">https://issues.jenkins-ci.org/browse/JENKINS-20445</a><br><a href=\"https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh</a></p>\n<p>解决方案就在于这个<strong>Timeout</strong>，相信你看了这个单词就知道是怎么回事了：<br><img src=\"http://static.zybuluo.com/usiege/firl86lawiru1uvz1jhelb28/image_1c0qmnlafh2p1j571b4ettv1ncah6.png\" alt=\"image_1c0qmnlafh2p1j571b4ettv1ncah6.png-74.3kB\"></p>\n<p>另顺便粘一个code 128的链接，是个与该问题相关的问题，因为这些问题关键字有的重复，所以搜出来的文章有时会误导，所以请仔细辨别：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returned status code 128 jenkins</span><br><span class=\"line\">ERROR: Error cloning remote repo &apos;origin&apos;</span><br><span class=\"line\">stderr: Permission denied (publickey).</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://wantcoding.com/?p=293\" target=\"_blank\" rel=\"noopener\">http://wantcoding.com/?p=293</a><br><a href=\"http://www.cnblogs.com/EasonJim/p/6266892.html\" target=\"_blank\" rel=\"noopener\">这个链接是附送的，进去多看看你会有惊喜，还有QQ群哦</a></p>\n","site":{"data":{}},"excerpt":"<p>本文将以问题与解决方案的方式对Jenkins构建过程中的问题进行收录，后期会在评论中持续收集，如果有相同情况，请自行对照解决；<br>","more":"</p>\n<p>本文参考：<br>手把手教你利用Jenkins持续集成iOS项目<br><a href=\"http://www.jianshu.com/p/41ecb06ae95f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/41ecb06ae95f</a><br>关于iOS-Jenkins进行持续集成项目部署<br><a href=\"http://www.jianshu.com/p/54c7daae6c94\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/54c7daae6c94</a><br>iOS持续集成：Jenkins篇<br><a href=\"http://www.jianshu.com/p/faf879b3d182\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/faf879b3d182</a></p>\n<h2 id=\"关卡1-：\"><a href=\"#关卡1-：\" class=\"headerlink\" title=\"关卡1 ：\"></a>关卡1 ：</h2><p>安装Jenkins：首先你的电脑得有一个Java环境，接下来安装Jenkins。你可以直接去<a href=\"https://jenkins.io\" target=\"_blank\" rel=\"noopener\">Jenkins入口</a>网站，查看安装方式；<br>当然你也可以使用以下方法：</p>\n<ul>\n<li><p>安装homebrew</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>安装成功后需要开启jenkins服务；</p>\n<h2 id=\"关卡2-：\"><a href=\"#关卡2-：\" class=\"headerlink\" title=\"关卡2 ：\"></a>关卡2 ：</h2><p>开启Jenkins服务：确认jenkins已安装，在终端进入到jenkins安装目录下，会有一个叫做jenkins.war的文件，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -jar jenkins.war</span><br></pre></td></tr></table></figure></p>\n<p>或者在终端输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jenkins</span><br></pre></td></tr></table></figure></p>\n<p>当出现：<br><img src=\"http://static.zybuluo.com/usiege/uowhxmph61xngu3l2t4hxamh/image_1c0ptnl2j13mh1mn2hmk18qf7usp.png\" alt=\"image_1c0ptnl2j13mh1mn2hmk18qf7usp.png-188.1kB\"></p>\n<p>服务已经就位，可以开始进行配置了；</p>\n<p>这里还有两个命令用于jenkins开启和停用（Mac上）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist</span><br><span class=\"line\">$ sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist</span><br></pre></td></tr></table></figure></p>\n<p>如果是linux上也可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl status jenkins.service</span><br><span class=\"line\">$ sudo systemctl start jenkins.service</span><br></pre></td></tr></table></figure></p>\n<p>不过实际操作过程中，可能会出现停用失败的情况，我的做法是直接打开活动监视器，在里面搜java服务，强制关闭掉；这里需要注意，如果服务没有停止再进行jenkins开启是不成功的，提示会告诉你已经在用：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/s46xl40yzd7t5gijpwdippc9/image_1c0pu09in491qq31bqs25f1hbg26.png\" alt=\"image_1c0pu09in491qq31bqs25f1hbg26.png-222.9kB\"></p>\n<p>如果你想查看是否jenkins在运行，使用命令查看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | grep jenkins</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关卡3-：\"><a href=\"#关卡3-：\" class=\"headerlink\" title=\"关卡3 ：\"></a>关卡3 ：</h2><p>安装并开启完成就可以在浏览器里输入<a href=\"localhost:8080\" target=\"_blank\" rel=\"noopener\">localhost:8080</a>进行页面化配置了；<br>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a><br><img src=\"http://static.zybuluo.com/usiege/fn2f1wx006r3chny2t5u9atc/image_1c0pvjgjqfbg3i01c371uhc1ves2j.png\" alt=\"image_1c0pvjgjqfbg3i01c371uhc1ves2j.png-27.6kB\"></p>\n<p>这个时候可能会报一个错误。如果出现了这面的问题。出现这个问题的原因就是Java环境有问题，重启Java环境即可。</p>\n<p>这个时候如果你重启电脑会发现Jenkins给你新增了一个用户，名字就叫Jenkins，不过这个时候你不知道密码。你可能会去试密码，肯定是是不对的，因为初始密码很复杂。这个时候正确做法是打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 会出现下图的重设初始密码的界面。</p>\n<p><img src=\"http://static.zybuluo.com/usiege/sfnjgdq201o27xta3ttqllkr/image_1c0pvl71n5dulcc413164i1hcp30.png\" alt=\"image_1c0pvl71n5dulcc413164i1hcp30.png-30.4kB\"></p>\n<p>按照提示，找到/Users/Shared/Jenkins/Home/ 这个目录下，这个目录虽然是共享目录，但是有权限的，非Jenkins用户/secrets/目录是没有读写权限的。</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ltc8z86hbmzy78857uo767zr/image_1c0pvm8al1tce1iled5voi216ac3d.png\" alt=\"image_1c0pvm8al1tce1iled5voi216ac3d.png-200.2kB\"></p>\n<p>打开initialAdminPassword文件，复制出密码，就可以填到网页上去重置密码了。如下图</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ub5cnhcl82hyed8j8aqghlna/image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png\" alt=\"image_1c0pvp2p01fon1h2mmvjs6s1fuj3q.png-99.6kB\"></p>\n<p>一路安装过来，输入用户名，密码，邮件这些，就算安装完成了。</p>\n<p>还是继续登录localhost:8080</p>\n<p>然而这一关还没有结束：<br>写blog的时候我把自己设置的帐号注销了，然而当时设置的密码却忘记了，怎么都想不起来，怎么办呢？<br>首先我想能不能用之前给的Jenkins帐户呢，经试错，未果；<br>接下来上百度查了几种方法，有的方法很复杂，不打算用，我们只用最简单粗暴的；只要之前的帐号信息没有丢失，又可以进入系统就OK了，于是：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ihh8n31m9fb1r9gomahd7l6d/image_1c0q0bnonde9a9omqa1092a1747.png\" alt=\"image_1c0q0bnonde9a9omqa1092a1747.png-85.9kB\"></p>\n<p>注意实际操作过程中发现不是<code>/User/Shared/Jenkins/Home</code>下的config.xml，也不是<code>/User/Shared/Jenkins/Home/users</code>下的config.xml，而是<strong>你自己用户目录</strong><code>~/.jenkins/</code>下的config.xml，具体原因可能是jenkins运行的工作空间是当前用户目录下的<code>.jenkins</code>，然后就是这样：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/rmn1oao4inl6rvryb8ne596c/image_1c0q277tu152r9mg1dhg1edq8jp5q.png\" alt=\"image_1c0q277tu152r9mg1dhg1edq8jp5q.png-55.9kB\"></p>\n<p>经检验，无误，可进入，但是好像遗留了一个问题，就是这样进入的话就找不到管理用户的选项了；解决问题，勾选图中黄色圈，返回系统管理，出现管理用户（还是个隐藏道具）；<br><img src=\"http://static.zybuluo.com/usiege/v5zxzwu4pex59s78odynkkd6/image_1c0q3ukis1vlhib71uij1729ohs67.png\" alt=\"image_1c0q3ukis1vlhib71uij1729ohs67.png-33.1kB\"></p>\n<p><img src=\"http://static.zybuluo.com/usiege/bxyfaeid922e3lf7dvuz9mh8/image_1c0q419b0164pqfe25d9br1fpt74.png\" alt=\"image_1c0q419b0164pqfe25d9br1fpt74.png-39.8kB\"></p>\n<p><img src=\"http://static.zybuluo.com/usiege/burf10v126vjx00u2ym0h2bn/image_1c0q42m3mvf41d8fjs21ptb1ae77h.png\" alt=\"image_1c0q42m3mvf41d8fjs21ptb1ae77h.png-11.4kB\"></p>\n<p>搞的像是特工登录非授权帐户一样，不管怎么说，总算是攻破了，进入下一关；</p>\n<h2 id=\"关卡-4：\"><a href=\"#关卡-4：\" class=\"headerlink\" title=\"关卡 4：\"></a>关卡 4：</h2><p>先不管工程构建里那一堆设置，我们先来搞一下证书Cer，钥匙Keychain，配置文件Provisioning Profiles的一些问题：<br>首先去系统管理 -&gt; 管理插件 -&gt; 可选插件，搜索并安装Keychains and Provisioning Profiles Management插件；<br>进入插件：<br><img src=\"http://static.zybuluo.com/usiege/kgy8eq7ug16g0o1o4eotp3bw/image_1c0qeblep1tcj4m319ap1bek783ah.png\" alt=\"image_1c0qeblep1tcj4m319ap1bek783ah.png-31.1kB\"></p>\n<p>不要关键去填下面的空，我会告诉你这是一道有选项的题目；进入文件目录，<code>Command + shift + G</code>，写下这样的路径<code>~/资源库/Keychains</code>，</p>\n<p><img src=\"http://static.zybuluo.com/usiege/ebpz8l8bnnvlrr6oi3a0423h/image_1c0qekdqp9v712rd1gefjdr1fdcbe.png\" alt=\"image_1c0qekdqp9v712rd1gefjdr1fdcbe.png-62.2kB\"></p>\n<p>这里我们把login.keychain-db上传到Jenkins里，但是Upload并不能上传这样后缀的文件，所以需要你手动把login.keychain-db修改成login.keychain（复制后再修改，以防止其他地方会引用到带-db）；上传完成后就会在下面出现你一些信息；然后打开你的钥匙串，这个知道在什么地方吧；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/w9l7f921rn6he0vx1vcqmu6a/image_1c0qet898q8m118mk2s6kj1cq5eb.png\" alt=\"image_1c0qet898q8m118mk2s6kj1cq5eb.png-131kB\"></p>\n<p>点击打包所用到的证书，将红色框中的名称复制出来，添加到identities中；</p>\n<p><img src=\"http://static.zybuluo.com/usiege/zc1wu103t1woz01fp07s80b7/image_1c0qf02rofnpc3r121c1nlb1mqteo.png\" alt=\"image_1c0qf02rofnpc3r121c1nlb1mqteo.png-42.7kB\"></p>\n<p>如果有多个，则点击Add Code Signing Identity添加；</p>\n<p>然后是PP文件，这些文件需要我们从系统PP文件夹下复制到Jenkins资源文件夹下，如下图两个路径：<br>这个是系统PP文件目录<br><img src=\"http://static.zybuluo.com/usiege/peonwampxc6wa9h3i2yuhfm5/image_1c0qkdte41j1rgq81k8v1bi19f4f5.png\" alt=\"image_1c0qkdte41j1rgq81k8v1bi19f4f5.png-144.2kB\"><br>这个是Jenkins PP文件目录<br><img src=\"http://static.zybuluo.com/usiege/v0firte6p13gwec9a133ixi1/image_1c0qkkk833p0nt18andthn9qfi.png\" alt=\"image_1c0qkkk833p0nt18andthn9qfi.png-79.2kB\"></p>\n<p>Provisioning Profiles Directory Path 填写成，注意替换为自己的username：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/User/&#123;USERNAME&#125;/Library/MobileDevice/Provisioning Profiles</span><br></pre></td></tr></table></figure>\n<p>接着去你苹果帐号里去找你对应打包所需要的PP文件，然后点upload上传到Jenkins环境里；<br>以上，证书部分解决；</p>\n<h2 id=\"关卡-5\"><a href=\"#关卡-5\" class=\"headerlink\" title=\"关卡 5\"></a>关卡 5</h2><p>创建项目过程我们会对各个需要的项进行逐个描述：<br>点新建项目，输入项目名称，选择 构建一个自由风格的软件项目，然后确定，进入配置页面。<br><img src=\"http://static.zybuluo.com/usiege/1ytel52lwidafke7uv5rmgb0/image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png\" alt=\"image_1c0ql3ppk1bht1b5ms4hcui1jpjfv.png-8.2kB\"></p>\n<ul>\n<li>General<br>这个部分的内容都很浅显，没有什么可以说的，根据需要自行填充；这里说一下GitLab connection选项，因为我自己的工程是用gitlab管理的代码，所以需要在Jenkins里下一个Gitlab的插件，然后在里面进行帐号配置，可以采用帐号密码以及SSH的方式，具体这个部分会有一个SSH的坑，先不作分析，后面会讲到，我这里先用帐号密码的方式进行构建，经检验发现SSH方式非必要；</li>\n</ul>\n<p><strong>Credentials</strong>在这里配置：<br><img src=\"http://static.zybuluo.com/usiege/f6pv0rsip2oirn32m01agp1l/image_1c0qljaq610ljc02k6g1r821fs5gc.png\" alt=\"image_1c0qljaq610ljc02k6g1r821fs5gc.png-78.2kB\"></p>\n<ul>\n<li>源码管理<br>这里我选的Git，<strong>Repository URL</strong>填你工程的git地址，选用帐号密码的形式应该是以http或https开头的，<strong>Credentials</strong>填你在上一步中新建好的，<br><img src=\"http://static.zybuluo.com/usiege/bzufeuzktht55r97i2bsem18/image_1c0qlt20313duogl2g51hp11nqsgp.png\" alt=\"image_1c0qlt20313duogl2g51hp11nqsgp.png-73kB\"><br><strong>Branch Specifier (blank for ‘any’)</strong>    填你要进行构建的分支，我这里是<code>*/release</code>；</li>\n</ul>\n<p>这里我们PS一个隐藏BOSS：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returned status code 143 jenkins</span><br><span class=\"line\">ERROR: Error fetching remote repo ‘origin’</span><br></pre></td></tr></table></figure></p>\n<p>这个报错是工程配置结束后进行构建后提示的，我当时搞这个发现远程代码明明是已经拉取到本地的，只是在拉取过程中会发生中断，本人在进行了将近50次试错后发现这个拉取到本地的代码率是变化的，先前以为是SSH帐号的问题，于是转头花了一天的时间搞了下SSH，后来SSH搞通后发现该问题仍然存在，后来终于在经历百度，谷歌，搜狗也用上的（不得不说有时候百度搜不出来的搜狗能搜到），发现了几篇有用的，后来解决，也算是不负辛苦，后面有踩坑的伙伴多注意，前车之鉴后事之师；</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_72ef7bea0102vo9w.html</a><br><a href=\"https://issues.jenkins-ci.org/browse/JENKINS-20445\" target=\"_blank\" rel=\"noopener\">https://issues.jenkins-ci.org/browse/JENKINS-20445</a><br><a href=\"https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/35069079/jenkins-git-plugin-timeout-when-try-to-pull-repositoty-using-ssh</a></p>\n<p>解决方案就在于这个<strong>Timeout</strong>，相信你看了这个单词就知道是怎么回事了：<br><img src=\"http://static.zybuluo.com/usiege/firl86lawiru1uvz1jhelb28/image_1c0qmnlafh2p1j571b4ettv1ncah6.png\" alt=\"image_1c0qmnlafh2p1j571b4ettv1ncah6.png-74.3kB\"></p>\n<p>另顺便粘一个code 128的链接，是个与该问题相关的问题，因为这些问题关键字有的重复，所以搜出来的文章有时会误导，所以请仔细辨别：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">returned status code 128 jenkins</span><br><span class=\"line\">ERROR: Error cloning remote repo &apos;origin&apos;</span><br><span class=\"line\">stderr: Permission denied (publickey).</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://wantcoding.com/?p=293\" target=\"_blank\" rel=\"noopener\">http://wantcoding.com/?p=293</a><br><a href=\"http://www.cnblogs.com/EasonJim/p/6266892.html\" target=\"_blank\" rel=\"noopener\">这个链接是附送的，进去多看看你会有惊喜，还有QQ群哦</a></p>"},{"title":"GLKView是如何工作的","date":"2016-05-06T17:04:00.000Z","_content":"\nSummary: 本篇通过一个AGLKView的示例来深入了解一下上篇中GLKView的工作原理，目的是为了消除GLKView、Core Animation、OpenGLES间交互的神秘感；\n<!-- more -->\n\n本例位于[点击此处下载本文例子](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch2_2)，建议将例子下下来，边看本文解析，边自己实现该例子；\n\n```OC\n+ (Class)layerClass\n{\n   return [CAEAGLLayer class];\n}\n```\n每个UIView都有一个相关联的Core Animation层；Cocoa Touch会调用该方法决定生成一个什么样的层;\nCAEAGLLayer会与一个OGE帧缓存共享它的像素仓库；CAEAGLLayer是Core Animation提供的标准层之一；\n>串行化(Serialization)是计算机科学中的一个概念，它是指将对象存储到介质（如文件、内存缓冲区等）中或是以二进制方式通过网络传输，在iOS中也叫做归档。\n\n\n```\n- (id)initWithCoder:(NSCoder*)coder\n{    \n   if ((self = [super initWithCoder:coder]))\n   {\n      CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;      \n      eaglLayer.drawableProperties = \n         [NSDictionary dictionaryWithObjectsAndKeys:\n             [NSNumber numberWithBool:NO], \n             kEAGLDrawablePropertyRetainedBacking, \n             kEAGLColorFormatRGBA8, \n             kEAGLDrawablePropertyColorFormat, \n             nil];          \n   }\n   return self;\n}\n\n```\n该方法是Cocoa Touch用于初始化对象的标准方法之一，Cocoa Touch会自动调用该方法，这是反归档先前归档入一个文件的对象过程的一部分；本例中AGLKView从storyboard文件中加载过程就是反归档；若用代码的话应该是调用*\"-initWithFrame:context:\"*方法；\n在这两个方法中，kEAGLDrawablePropertyRetainedBacking == NO 表示不使用保留背景，告诉Core Animation层任何部分需要在屏幕上显示的时候都需要绘制整个层的内容；kEAGLColorFormatRGBA8 使用8位来保存每个像素每个颜色的值；这段代码告诉Core Animation不要试图保留任何以前绘制的图像留作以后重用；\n\n```\n// This method sets the receiver's OpenGL ES Context. If the \n// receiver already has a different Context, this method deletes\n// OpenGL ES Frame Buffer resources in the old Context and the \n// recreates them in the new Context.\n- (void)setContext:(EAGLContext *)aContext\n{\n   if(context != aContext)\n   {  // Delete any buffers previously created in old Context\n      [EAGLContext setCurrentContext:context];\n      \n      if (0 != defaultFrameBuffer)\n      {\n         glDeleteFramebuffers(1, &defaultFrameBuffer); // Step 7\n         defaultFrameBuffer = 0;\n      }\n      \n      if (0 != colorRenderBuffer)\n      {\n         glDeleteRenderbuffers(1, &colorRenderBuffer); // Step 7\n         colorRenderBuffer = 0;\n      }\n      \n      if (0 != depthRenderBuffer)\n      {\n         glDeleteRenderbuffers(1, &depthRenderBuffer); // Step 7\n         depthRenderBuffer = 0;\n      }\n      \n      context = aContext;\n   \n      if(nil != context)\n      {  // Configure the new Context with required buffers\n         context = aContext;\n         [EAGLContext setCurrentContext:context];\n                   \n         glGenFramebuffers(1, &defaultFrameBuffer);    // Step 1\n         glBindFramebuffer(                            // Step 2\n            GL_FRAMEBUFFER,             \n            defaultFrameBuffer);\n\n         glGenRenderbuffers(1, &colorRenderBuffer);    // Step 1\n         glBindRenderbuffer(                           // Step 2\n            GL_RENDERBUFFER, \n            colorRenderBuffer);\n         \n         // Attach color render buffer to bound Frame Buffer\n         glFramebufferRenderbuffer(\n            GL_FRAMEBUFFER, \n            GL_COLOR_ATTACHMENT0, \n            GL_RENDERBUFFER, \n            colorRenderBuffer);\n\n         // Create any additional render buffers based on the\n         // drawable size of defaultFrameBuffer\n         [self layoutSubviews];\n      }\n   }\n}\n```\n\n修改视图的上下文会导致先前创建的所有缓存全部失效，需要配置新的缓存；glFramebufferRenderbuffer()用来配置当前绑定的帧缓存以便在colorRenderBuffer中保存渲染的像素颜色；\n\n```\n// Calling this method tells the receiver to redraw the contents \n// of its associated OpenGL ES Frame Buffer. This method \n// configures OpenGL ES and then calls -drawRect:\n- (void)display\n{\n   [EAGLContext setCurrentContext:self.context];\n   glViewport(0, 0, (GLint)self.drawableWidth, (GLint)self.drawableHeight);\n\n   [self drawRect:[self bounds]];\n   \n   [self.context presentRenderbuffer:GL_RENDERBUFFER];\n}\n\n// This method is called automatically whenever the receiver\n// needs to redraw the contents of its associated OpenGL ES\n// Frame Buffer. This method should not be called directly. Call\n// -display instead which configures OpenGL ES before calling\n// -drawRect:\n- (void)drawRect:(CGRect)rect\n{\n   if(delegate)\n   {\n      [self.delegate glkView:self drawInRect:[self bounds]];\n   }\n}\n```\n\n设置视图的上下文为当前上下文，告诉OGE让渲染填满整个帧缓存，调用“-drawRect:”进行真正给图，然后让上下文调整外观使用Core Animation合成器把帧缓存的像素颜色渲染缓存与其他相关层混合起来；\nglViewport()可以控制渲染至帧缓存的子集；\n\n\n```\n- (void)layoutSubviews\n{\n   CAEAGLLayer \t*eaglLayer = (CAEAGLLayer *)self.layer;\n   \n   // Make sure our context is current\n   [EAGLContext setCurrentContext:self.context];\n\n   // Initialize the current Frame Buffer’s pixel color buffer \n   // so that it shares the corresponding Core Animation Layer’s\n   // pixel color storage.\n   [self.context renderbufferStorage:GL_RENDERBUFFER \n      fromDrawable:eaglLayer];\n      \n   \n   if (0 != depthRenderBuffer)\n   {\n      glDeleteRenderbuffers(1, &depthRenderBuffer); // Step 7\n      depthRenderBuffer = 0;\n   }\n   \n   GLint currentDrawableWidth = (GLint)self.drawableWidth;\n   GLint currentDrawableHeight = (GLint)self.drawableHeight;\n   \n   if(self.drawableDepthFormat != \n      AGLKViewDrawableDepthFormatNone &&\n      0 < currentDrawableWidth &&\n      0 < currentDrawableHeight)\n   {\n      glGenRenderbuffers(1, &depthRenderBuffer); // Step 1\n      glBindRenderbuffer(GL_RENDERBUFFER,        // Step 2\n         depthRenderBuffer);\n      glRenderbufferStorage(GL_RENDERBUFFER,     // Step 3 \n         GL_DEPTH_COMPONENT16, \n         currentDrawableWidth, \n         currentDrawableHeight);\n      glFramebufferRenderbuffer(GL_FRAMEBUFFER,  // Step 4 \n         GL_DEPTH_ATTACHMENT, \n         GL_RENDERBUFFER, \n         depthRenderBuffer);\n   }\n   \n   // Check for any errors configuring the render buffer   \n   GLenum status = glCheckFramebufferStatus(\n      GL_FRAMEBUFFER) ;\n     \n   if(status != GL_FRAMEBUFFER_COMPLETE) {\n       NSLog(@\"failed to make complete frame buffer object %x\", status);\n   }\n\n   // Make the Color Render Buffer the current buffer for display\n   glBindRenderbuffer(GL_RENDERBUFFER, colorRenderBuffer);\n}\n\n```\n任何在接收到重新调整大小的消息时，Cocoa Touch都会调用下面的layoutSubviews；上下文的\"renderbufferStorage:fromDrawable\"方法会调整视图的缓存尺寸以匹配层的新尺寸；\n\n```\n// This method returns the width in pixels of current context's\n// Pixel Color Render Buffer\n- (NSInteger)drawableWidth;\n{\n   GLint          backingWidth;\n\n   glGetRenderbufferParameteriv(\n      GL_RENDERBUFFER, \n      GL_RENDERBUFFER_WIDTH, \n      &backingWidth);\n      \n   return (NSInteger)backingWidth;\n}\n\n\n/////////////////////////////////////////////////////////////////\n// This method returns the height in pixels of current context's\n// Pixel Color Render Buffer\n- (NSInteger)drawableHeight;\n{\n   GLint          backingHeight;\n\n   glGetRenderbufferParameteriv(\n      GL_RENDERBUFFER, \n      GL_RENDERBUFFER_HEIGHT, \n      &backingHeight);\n      \n   return (NSInteger)backingHeight;\n}\n```\n\n通过OpenGLES的glGetRenderbufferParameteriv()方法获取和返回当前上下文的帧缓存的像素颜色渲染缓存尺寸;\n\n接下来要说说*AGLKViewController*,它使用一个CADisplayLink对象来调度和执行与控制器相关联的视力的周期性的重绘；\nCADisplayLink本质上是一个用于显示更新的同步计时器，它能够被设置用来在每个显示更新或者其他更新时发送一个消息；\n显示更新频率通常是由嵌入设备硬件决定的，它代表一个帧缓存的内容每秒最多能够被在屏幕上通过的像素显示出来的次数；\n\n\n","source":"_posts/GLKView是如何工作的.md","raw":"title: GLKView是如何工作的\ndate: 2016-05-07 01:04:00\ncategories: coder\ntags: [opengles]\n-----------\n\nSummary: 本篇通过一个AGLKView的示例来深入了解一下上篇中GLKView的工作原理，目的是为了消除GLKView、Core Animation、OpenGLES间交互的神秘感；\n<!-- more -->\n\n本例位于[点击此处下载本文例子](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch2_2)，建议将例子下下来，边看本文解析，边自己实现该例子；\n\n```OC\n+ (Class)layerClass\n{\n   return [CAEAGLLayer class];\n}\n```\n每个UIView都有一个相关联的Core Animation层；Cocoa Touch会调用该方法决定生成一个什么样的层;\nCAEAGLLayer会与一个OGE帧缓存共享它的像素仓库；CAEAGLLayer是Core Animation提供的标准层之一；\n>串行化(Serialization)是计算机科学中的一个概念，它是指将对象存储到介质（如文件、内存缓冲区等）中或是以二进制方式通过网络传输，在iOS中也叫做归档。\n\n\n```\n- (id)initWithCoder:(NSCoder*)coder\n{    \n   if ((self = [super initWithCoder:coder]))\n   {\n      CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;      \n      eaglLayer.drawableProperties = \n         [NSDictionary dictionaryWithObjectsAndKeys:\n             [NSNumber numberWithBool:NO], \n             kEAGLDrawablePropertyRetainedBacking, \n             kEAGLColorFormatRGBA8, \n             kEAGLDrawablePropertyColorFormat, \n             nil];          \n   }\n   return self;\n}\n\n```\n该方法是Cocoa Touch用于初始化对象的标准方法之一，Cocoa Touch会自动调用该方法，这是反归档先前归档入一个文件的对象过程的一部分；本例中AGLKView从storyboard文件中加载过程就是反归档；若用代码的话应该是调用*\"-initWithFrame:context:\"*方法；\n在这两个方法中，kEAGLDrawablePropertyRetainedBacking == NO 表示不使用保留背景，告诉Core Animation层任何部分需要在屏幕上显示的时候都需要绘制整个层的内容；kEAGLColorFormatRGBA8 使用8位来保存每个像素每个颜色的值；这段代码告诉Core Animation不要试图保留任何以前绘制的图像留作以后重用；\n\n```\n// This method sets the receiver's OpenGL ES Context. If the \n// receiver already has a different Context, this method deletes\n// OpenGL ES Frame Buffer resources in the old Context and the \n// recreates them in the new Context.\n- (void)setContext:(EAGLContext *)aContext\n{\n   if(context != aContext)\n   {  // Delete any buffers previously created in old Context\n      [EAGLContext setCurrentContext:context];\n      \n      if (0 != defaultFrameBuffer)\n      {\n         glDeleteFramebuffers(1, &defaultFrameBuffer); // Step 7\n         defaultFrameBuffer = 0;\n      }\n      \n      if (0 != colorRenderBuffer)\n      {\n         glDeleteRenderbuffers(1, &colorRenderBuffer); // Step 7\n         colorRenderBuffer = 0;\n      }\n      \n      if (0 != depthRenderBuffer)\n      {\n         glDeleteRenderbuffers(1, &depthRenderBuffer); // Step 7\n         depthRenderBuffer = 0;\n      }\n      \n      context = aContext;\n   \n      if(nil != context)\n      {  // Configure the new Context with required buffers\n         context = aContext;\n         [EAGLContext setCurrentContext:context];\n                   \n         glGenFramebuffers(1, &defaultFrameBuffer);    // Step 1\n         glBindFramebuffer(                            // Step 2\n            GL_FRAMEBUFFER,             \n            defaultFrameBuffer);\n\n         glGenRenderbuffers(1, &colorRenderBuffer);    // Step 1\n         glBindRenderbuffer(                           // Step 2\n            GL_RENDERBUFFER, \n            colorRenderBuffer);\n         \n         // Attach color render buffer to bound Frame Buffer\n         glFramebufferRenderbuffer(\n            GL_FRAMEBUFFER, \n            GL_COLOR_ATTACHMENT0, \n            GL_RENDERBUFFER, \n            colorRenderBuffer);\n\n         // Create any additional render buffers based on the\n         // drawable size of defaultFrameBuffer\n         [self layoutSubviews];\n      }\n   }\n}\n```\n\n修改视图的上下文会导致先前创建的所有缓存全部失效，需要配置新的缓存；glFramebufferRenderbuffer()用来配置当前绑定的帧缓存以便在colorRenderBuffer中保存渲染的像素颜色；\n\n```\n// Calling this method tells the receiver to redraw the contents \n// of its associated OpenGL ES Frame Buffer. This method \n// configures OpenGL ES and then calls -drawRect:\n- (void)display\n{\n   [EAGLContext setCurrentContext:self.context];\n   glViewport(0, 0, (GLint)self.drawableWidth, (GLint)self.drawableHeight);\n\n   [self drawRect:[self bounds]];\n   \n   [self.context presentRenderbuffer:GL_RENDERBUFFER];\n}\n\n// This method is called automatically whenever the receiver\n// needs to redraw the contents of its associated OpenGL ES\n// Frame Buffer. This method should not be called directly. Call\n// -display instead which configures OpenGL ES before calling\n// -drawRect:\n- (void)drawRect:(CGRect)rect\n{\n   if(delegate)\n   {\n      [self.delegate glkView:self drawInRect:[self bounds]];\n   }\n}\n```\n\n设置视图的上下文为当前上下文，告诉OGE让渲染填满整个帧缓存，调用“-drawRect:”进行真正给图，然后让上下文调整外观使用Core Animation合成器把帧缓存的像素颜色渲染缓存与其他相关层混合起来；\nglViewport()可以控制渲染至帧缓存的子集；\n\n\n```\n- (void)layoutSubviews\n{\n   CAEAGLLayer \t*eaglLayer = (CAEAGLLayer *)self.layer;\n   \n   // Make sure our context is current\n   [EAGLContext setCurrentContext:self.context];\n\n   // Initialize the current Frame Buffer’s pixel color buffer \n   // so that it shares the corresponding Core Animation Layer’s\n   // pixel color storage.\n   [self.context renderbufferStorage:GL_RENDERBUFFER \n      fromDrawable:eaglLayer];\n      \n   \n   if (0 != depthRenderBuffer)\n   {\n      glDeleteRenderbuffers(1, &depthRenderBuffer); // Step 7\n      depthRenderBuffer = 0;\n   }\n   \n   GLint currentDrawableWidth = (GLint)self.drawableWidth;\n   GLint currentDrawableHeight = (GLint)self.drawableHeight;\n   \n   if(self.drawableDepthFormat != \n      AGLKViewDrawableDepthFormatNone &&\n      0 < currentDrawableWidth &&\n      0 < currentDrawableHeight)\n   {\n      glGenRenderbuffers(1, &depthRenderBuffer); // Step 1\n      glBindRenderbuffer(GL_RENDERBUFFER,        // Step 2\n         depthRenderBuffer);\n      glRenderbufferStorage(GL_RENDERBUFFER,     // Step 3 \n         GL_DEPTH_COMPONENT16, \n         currentDrawableWidth, \n         currentDrawableHeight);\n      glFramebufferRenderbuffer(GL_FRAMEBUFFER,  // Step 4 \n         GL_DEPTH_ATTACHMENT, \n         GL_RENDERBUFFER, \n         depthRenderBuffer);\n   }\n   \n   // Check for any errors configuring the render buffer   \n   GLenum status = glCheckFramebufferStatus(\n      GL_FRAMEBUFFER) ;\n     \n   if(status != GL_FRAMEBUFFER_COMPLETE) {\n       NSLog(@\"failed to make complete frame buffer object %x\", status);\n   }\n\n   // Make the Color Render Buffer the current buffer for display\n   glBindRenderbuffer(GL_RENDERBUFFER, colorRenderBuffer);\n}\n\n```\n任何在接收到重新调整大小的消息时，Cocoa Touch都会调用下面的layoutSubviews；上下文的\"renderbufferStorage:fromDrawable\"方法会调整视图的缓存尺寸以匹配层的新尺寸；\n\n```\n// This method returns the width in pixels of current context's\n// Pixel Color Render Buffer\n- (NSInteger)drawableWidth;\n{\n   GLint          backingWidth;\n\n   glGetRenderbufferParameteriv(\n      GL_RENDERBUFFER, \n      GL_RENDERBUFFER_WIDTH, \n      &backingWidth);\n      \n   return (NSInteger)backingWidth;\n}\n\n\n/////////////////////////////////////////////////////////////////\n// This method returns the height in pixels of current context's\n// Pixel Color Render Buffer\n- (NSInteger)drawableHeight;\n{\n   GLint          backingHeight;\n\n   glGetRenderbufferParameteriv(\n      GL_RENDERBUFFER, \n      GL_RENDERBUFFER_HEIGHT, \n      &backingHeight);\n      \n   return (NSInteger)backingHeight;\n}\n```\n\n通过OpenGLES的glGetRenderbufferParameteriv()方法获取和返回当前上下文的帧缓存的像素颜色渲染缓存尺寸;\n\n接下来要说说*AGLKViewController*,它使用一个CADisplayLink对象来调度和执行与控制器相关联的视力的周期性的重绘；\nCADisplayLink本质上是一个用于显示更新的同步计时器，它能够被设置用来在每个显示更新或者其他更新时发送一个消息；\n显示更新频率通常是由嵌入设备硬件决定的，它代表一个帧缓存的内容每秒最多能够被在屏幕上通过的像素显示出来的次数；\n\n\n","slug":"GLKView是如何工作的","published":1,"updated":"2018-05-04T10:26:01.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucino00081v60ssinzwlu","content":"<p>Summary: 本篇通过一个AGLKView的示例来深入了解一下上篇中GLKView的工作原理，目的是为了消除GLKView、Core Animation、OpenGLES间交互的神秘感；<br><a id=\"more\"></a></p>\n<p>本例位于<a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch2_2\" target=\"_blank\" rel=\"noopener\">点击此处下载本文例子</a>，建议将例子下下来，边看本文解析，边自己实现该例子；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)layerClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   return [CAEAGLLayer class];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个UIView都有一个相关联的Core Animation层；Cocoa Touch会调用该方法决定生成一个什么样的层;<br>CAEAGLLayer会与一个OGE帧缓存共享它的像素仓库；CAEAGLLayer是Core Animation提供的标准层之一；</p>\n<blockquote>\n<p>串行化(Serialization)是计算机科学中的一个概念，它是指将对象存储到介质（如文件、内存缓冲区等）中或是以二进制方式通过网络传输，在iOS中也叫做归档。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)initWithCoder:(NSCoder*)coder</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">   if ((self = [super initWithCoder:coder]))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;      </span><br><span class=\"line\">      eaglLayer.drawableProperties = </span><br><span class=\"line\">         [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class=\"line\">             [NSNumber numberWithBool:NO], </span><br><span class=\"line\">             kEAGLDrawablePropertyRetainedBacking, </span><br><span class=\"line\">             kEAGLColorFormatRGBA8, </span><br><span class=\"line\">             kEAGLDrawablePropertyColorFormat, </span><br><span class=\"line\">             nil];          </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法是Cocoa Touch用于初始化对象的标准方法之一，Cocoa Touch会自动调用该方法，这是反归档先前归档入一个文件的对象过程的一部分；本例中AGLKView从storyboard文件中加载过程就是反归档；若用代码的话应该是调用<em>“-initWithFrame:context:”</em>方法；<br>在这两个方法中，kEAGLDrawablePropertyRetainedBacking == NO 表示不使用保留背景，告诉Core Animation层任何部分需要在屏幕上显示的时候都需要绘制整个层的内容；kEAGLColorFormatRGBA8 使用8位来保存每个像素每个颜色的值；这段代码告诉Core Animation不要试图保留任何以前绘制的图像留作以后重用；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method sets the receiver&apos;s OpenGL ES Context. If the </span><br><span class=\"line\">// receiver already has a different Context, this method deletes</span><br><span class=\"line\">// OpenGL ES Frame Buffer resources in the old Context and the </span><br><span class=\"line\">// recreates them in the new Context.</span><br><span class=\"line\">- (void)setContext:(EAGLContext *)aContext</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   if(context != aContext)</span><br><span class=\"line\">   &#123;  // Delete any buffers previously created in old Context</span><br><span class=\"line\">      [EAGLContext setCurrentContext:context];</span><br><span class=\"line\">      </span><br><span class=\"line\">      if (0 != defaultFrameBuffer)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         glDeleteFramebuffers(1, &amp;defaultFrameBuffer); // Step 7</span><br><span class=\"line\">         defaultFrameBuffer = 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      if (0 != colorRenderBuffer)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         glDeleteRenderbuffers(1, &amp;colorRenderBuffer); // Step 7</span><br><span class=\"line\">         colorRenderBuffer = 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      if (0 != depthRenderBuffer)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         glDeleteRenderbuffers(1, &amp;depthRenderBuffer); // Step 7</span><br><span class=\"line\">         depthRenderBuffer = 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      context = aContext;</span><br><span class=\"line\">   </span><br><span class=\"line\">      if(nil != context)</span><br><span class=\"line\">      &#123;  // Configure the new Context with required buffers</span><br><span class=\"line\">         context = aContext;</span><br><span class=\"line\">         [EAGLContext setCurrentContext:context];</span><br><span class=\"line\">                   </span><br><span class=\"line\">         glGenFramebuffers(1, &amp;defaultFrameBuffer);    // Step 1</span><br><span class=\"line\">         glBindFramebuffer(                            // Step 2</span><br><span class=\"line\">            GL_FRAMEBUFFER,             </span><br><span class=\"line\">            defaultFrameBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">         glGenRenderbuffers(1, &amp;colorRenderBuffer);    // Step 1</span><br><span class=\"line\">         glBindRenderbuffer(                           // Step 2</span><br><span class=\"line\">            GL_RENDERBUFFER, </span><br><span class=\"line\">            colorRenderBuffer);</span><br><span class=\"line\">         </span><br><span class=\"line\">         // Attach color render buffer to bound Frame Buffer</span><br><span class=\"line\">         glFramebufferRenderbuffer(</span><br><span class=\"line\">            GL_FRAMEBUFFER, </span><br><span class=\"line\">            GL_COLOR_ATTACHMENT0, </span><br><span class=\"line\">            GL_RENDERBUFFER, </span><br><span class=\"line\">            colorRenderBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">         // Create any additional render buffers based on the</span><br><span class=\"line\">         // drawable size of defaultFrameBuffer</span><br><span class=\"line\">         [self layoutSubviews];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改视图的上下文会导致先前创建的所有缓存全部失效，需要配置新的缓存；glFramebufferRenderbuffer()用来配置当前绑定的帧缓存以便在colorRenderBuffer中保存渲染的像素颜色；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Calling this method tells the receiver to redraw the contents </span><br><span class=\"line\">// of its associated OpenGL ES Frame Buffer. This method </span><br><span class=\"line\">// configures OpenGL ES and then calls -drawRect:</span><br><span class=\"line\">- (void)display</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [EAGLContext setCurrentContext:self.context];</span><br><span class=\"line\">   glViewport(0, 0, (GLint)self.drawableWidth, (GLint)self.drawableHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">   [self drawRect:[self bounds]];</span><br><span class=\"line\">   </span><br><span class=\"line\">   [self.context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// This method is called automatically whenever the receiver</span><br><span class=\"line\">// needs to redraw the contents of its associated OpenGL ES</span><br><span class=\"line\">// Frame Buffer. This method should not be called directly. Call</span><br><span class=\"line\">// -display instead which configures OpenGL ES before calling</span><br><span class=\"line\">// -drawRect:</span><br><span class=\"line\">- (void)drawRect:(CGRect)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   if(delegate)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      [self.delegate glkView:self drawInRect:[self bounds]];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置视图的上下文为当前上下文，告诉OGE让渲染填满整个帧缓存，调用“-drawRect:”进行真正给图，然后让上下文调整外观使用Core Animation合成器把帧缓存的像素颜色渲染缓存与其他相关层混合起来；<br>glViewport()可以控制渲染至帧缓存的子集；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)layoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   CAEAGLLayer \t*eaglLayer = (CAEAGLLayer *)self.layer;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Make sure our context is current</span><br><span class=\"line\">   [EAGLContext setCurrentContext:self.context];</span><br><span class=\"line\"></span><br><span class=\"line\">   // Initialize the current Frame Buffer’s pixel color buffer </span><br><span class=\"line\">   // so that it shares the corresponding Core Animation Layer’s</span><br><span class=\"line\">   // pixel color storage.</span><br><span class=\"line\">   [self.context renderbufferStorage:GL_RENDERBUFFER </span><br><span class=\"line\">      fromDrawable:eaglLayer];</span><br><span class=\"line\">      </span><br><span class=\"line\">   </span><br><span class=\"line\">   if (0 != depthRenderBuffer)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      glDeleteRenderbuffers(1, &amp;depthRenderBuffer); // Step 7</span><br><span class=\"line\">      depthRenderBuffer = 0;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   GLint currentDrawableWidth = (GLint)self.drawableWidth;</span><br><span class=\"line\">   GLint currentDrawableHeight = (GLint)self.drawableHeight;</span><br><span class=\"line\">   </span><br><span class=\"line\">   if(self.drawableDepthFormat != </span><br><span class=\"line\">      AGLKViewDrawableDepthFormatNone &amp;&amp;</span><br><span class=\"line\">      0 &lt; currentDrawableWidth &amp;&amp;</span><br><span class=\"line\">      0 &lt; currentDrawableHeight)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      glGenRenderbuffers(1, &amp;depthRenderBuffer); // Step 1</span><br><span class=\"line\">      glBindRenderbuffer(GL_RENDERBUFFER,        // Step 2</span><br><span class=\"line\">         depthRenderBuffer);</span><br><span class=\"line\">      glRenderbufferStorage(GL_RENDERBUFFER,     // Step 3 </span><br><span class=\"line\">         GL_DEPTH_COMPONENT16, </span><br><span class=\"line\">         currentDrawableWidth, </span><br><span class=\"line\">         currentDrawableHeight);</span><br><span class=\"line\">      glFramebufferRenderbuffer(GL_FRAMEBUFFER,  // Step 4 </span><br><span class=\"line\">         GL_DEPTH_ATTACHMENT, </span><br><span class=\"line\">         GL_RENDERBUFFER, </span><br><span class=\"line\">         depthRenderBuffer);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Check for any errors configuring the render buffer   </span><br><span class=\"line\">   GLenum status = glCheckFramebufferStatus(</span><br><span class=\"line\">      GL_FRAMEBUFFER) ;</span><br><span class=\"line\">     </span><br><span class=\"line\">   if(status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class=\"line\">       NSLog(@&quot;failed to make complete frame buffer object %x&quot;, status);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Make the Color Render Buffer the current buffer for display</span><br><span class=\"line\">   glBindRenderbuffer(GL_RENDERBUFFER, colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任何在接收到重新调整大小的消息时，Cocoa Touch都会调用下面的layoutSubviews；上下文的”renderbufferStorage:fromDrawable”方法会调整视图的缓存尺寸以匹配层的新尺寸；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method returns the width in pixels of current context&apos;s</span><br><span class=\"line\">// Pixel Color Render Buffer</span><br><span class=\"line\">- (NSInteger)drawableWidth;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLint          backingWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">   glGetRenderbufferParameteriv(</span><br><span class=\"line\">      GL_RENDERBUFFER, </span><br><span class=\"line\">      GL_RENDERBUFFER_WIDTH, </span><br><span class=\"line\">      &amp;backingWidth);</span><br><span class=\"line\">      </span><br><span class=\"line\">   return (NSInteger)backingWidth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/////////////////////////////////////////////////////////////////</span><br><span class=\"line\">// This method returns the height in pixels of current context&apos;s</span><br><span class=\"line\">// Pixel Color Render Buffer</span><br><span class=\"line\">- (NSInteger)drawableHeight;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLint          backingHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   glGetRenderbufferParameteriv(</span><br><span class=\"line\">      GL_RENDERBUFFER, </span><br><span class=\"line\">      GL_RENDERBUFFER_HEIGHT, </span><br><span class=\"line\">      &amp;backingHeight);</span><br><span class=\"line\">      </span><br><span class=\"line\">   return (NSInteger)backingHeight;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过OpenGLES的glGetRenderbufferParameteriv()方法获取和返回当前上下文的帧缓存的像素颜色渲染缓存尺寸;</p>\n<p>接下来要说说<em>AGLKViewController</em>,它使用一个CADisplayLink对象来调度和执行与控制器相关联的视力的周期性的重绘；<br>CADisplayLink本质上是一个用于显示更新的同步计时器，它能够被设置用来在每个显示更新或者其他更新时发送一个消息；<br>显示更新频率通常是由嵌入设备硬件决定的，它代表一个帧缓存的内容每秒最多能够被在屏幕上通过的像素显示出来的次数；</p>\n","site":{"data":{}},"excerpt":"<p>Summary: 本篇通过一个AGLKView的示例来深入了解一下上篇中GLKView的工作原理，目的是为了消除GLKView、Core Animation、OpenGLES间交互的神秘感；<br>","more":"</p>\n<p>本例位于<a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch2_2\" target=\"_blank\" rel=\"noopener\">点击此处下载本文例子</a>，建议将例子下下来，边看本文解析，边自己实现该例子；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)layerClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   return [CAEAGLLayer class];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个UIView都有一个相关联的Core Animation层；Cocoa Touch会调用该方法决定生成一个什么样的层;<br>CAEAGLLayer会与一个OGE帧缓存共享它的像素仓库；CAEAGLLayer是Core Animation提供的标准层之一；</p>\n<blockquote>\n<p>串行化(Serialization)是计算机科学中的一个概念，它是指将对象存储到介质（如文件、内存缓冲区等）中或是以二进制方式通过网络传输，在iOS中也叫做归档。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)initWithCoder:(NSCoder*)coder</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\">   if ((self = [super initWithCoder:coder]))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;      </span><br><span class=\"line\">      eaglLayer.drawableProperties = </span><br><span class=\"line\">         [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class=\"line\">             [NSNumber numberWithBool:NO], </span><br><span class=\"line\">             kEAGLDrawablePropertyRetainedBacking, </span><br><span class=\"line\">             kEAGLColorFormatRGBA8, </span><br><span class=\"line\">             kEAGLDrawablePropertyColorFormat, </span><br><span class=\"line\">             nil];          </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法是Cocoa Touch用于初始化对象的标准方法之一，Cocoa Touch会自动调用该方法，这是反归档先前归档入一个文件的对象过程的一部分；本例中AGLKView从storyboard文件中加载过程就是反归档；若用代码的话应该是调用<em>“-initWithFrame:context:”</em>方法；<br>在这两个方法中，kEAGLDrawablePropertyRetainedBacking == NO 表示不使用保留背景，告诉Core Animation层任何部分需要在屏幕上显示的时候都需要绘制整个层的内容；kEAGLColorFormatRGBA8 使用8位来保存每个像素每个颜色的值；这段代码告诉Core Animation不要试图保留任何以前绘制的图像留作以后重用；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method sets the receiver&apos;s OpenGL ES Context. If the </span><br><span class=\"line\">// receiver already has a different Context, this method deletes</span><br><span class=\"line\">// OpenGL ES Frame Buffer resources in the old Context and the </span><br><span class=\"line\">// recreates them in the new Context.</span><br><span class=\"line\">- (void)setContext:(EAGLContext *)aContext</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   if(context != aContext)</span><br><span class=\"line\">   &#123;  // Delete any buffers previously created in old Context</span><br><span class=\"line\">      [EAGLContext setCurrentContext:context];</span><br><span class=\"line\">      </span><br><span class=\"line\">      if (0 != defaultFrameBuffer)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         glDeleteFramebuffers(1, &amp;defaultFrameBuffer); // Step 7</span><br><span class=\"line\">         defaultFrameBuffer = 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      if (0 != colorRenderBuffer)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         glDeleteRenderbuffers(1, &amp;colorRenderBuffer); // Step 7</span><br><span class=\"line\">         colorRenderBuffer = 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      if (0 != depthRenderBuffer)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         glDeleteRenderbuffers(1, &amp;depthRenderBuffer); // Step 7</span><br><span class=\"line\">         depthRenderBuffer = 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      context = aContext;</span><br><span class=\"line\">   </span><br><span class=\"line\">      if(nil != context)</span><br><span class=\"line\">      &#123;  // Configure the new Context with required buffers</span><br><span class=\"line\">         context = aContext;</span><br><span class=\"line\">         [EAGLContext setCurrentContext:context];</span><br><span class=\"line\">                   </span><br><span class=\"line\">         glGenFramebuffers(1, &amp;defaultFrameBuffer);    // Step 1</span><br><span class=\"line\">         glBindFramebuffer(                            // Step 2</span><br><span class=\"line\">            GL_FRAMEBUFFER,             </span><br><span class=\"line\">            defaultFrameBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">         glGenRenderbuffers(1, &amp;colorRenderBuffer);    // Step 1</span><br><span class=\"line\">         glBindRenderbuffer(                           // Step 2</span><br><span class=\"line\">            GL_RENDERBUFFER, </span><br><span class=\"line\">            colorRenderBuffer);</span><br><span class=\"line\">         </span><br><span class=\"line\">         // Attach color render buffer to bound Frame Buffer</span><br><span class=\"line\">         glFramebufferRenderbuffer(</span><br><span class=\"line\">            GL_FRAMEBUFFER, </span><br><span class=\"line\">            GL_COLOR_ATTACHMENT0, </span><br><span class=\"line\">            GL_RENDERBUFFER, </span><br><span class=\"line\">            colorRenderBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">         // Create any additional render buffers based on the</span><br><span class=\"line\">         // drawable size of defaultFrameBuffer</span><br><span class=\"line\">         [self layoutSubviews];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改视图的上下文会导致先前创建的所有缓存全部失效，需要配置新的缓存；glFramebufferRenderbuffer()用来配置当前绑定的帧缓存以便在colorRenderBuffer中保存渲染的像素颜色；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Calling this method tells the receiver to redraw the contents </span><br><span class=\"line\">// of its associated OpenGL ES Frame Buffer. This method </span><br><span class=\"line\">// configures OpenGL ES and then calls -drawRect:</span><br><span class=\"line\">- (void)display</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [EAGLContext setCurrentContext:self.context];</span><br><span class=\"line\">   glViewport(0, 0, (GLint)self.drawableWidth, (GLint)self.drawableHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">   [self drawRect:[self bounds]];</span><br><span class=\"line\">   </span><br><span class=\"line\">   [self.context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// This method is called automatically whenever the receiver</span><br><span class=\"line\">// needs to redraw the contents of its associated OpenGL ES</span><br><span class=\"line\">// Frame Buffer. This method should not be called directly. Call</span><br><span class=\"line\">// -display instead which configures OpenGL ES before calling</span><br><span class=\"line\">// -drawRect:</span><br><span class=\"line\">- (void)drawRect:(CGRect)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   if(delegate)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      [self.delegate glkView:self drawInRect:[self bounds]];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置视图的上下文为当前上下文，告诉OGE让渲染填满整个帧缓存，调用“-drawRect:”进行真正给图，然后让上下文调整外观使用Core Animation合成器把帧缓存的像素颜色渲染缓存与其他相关层混合起来；<br>glViewport()可以控制渲染至帧缓存的子集；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)layoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   CAEAGLLayer \t*eaglLayer = (CAEAGLLayer *)self.layer;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Make sure our context is current</span><br><span class=\"line\">   [EAGLContext setCurrentContext:self.context];</span><br><span class=\"line\"></span><br><span class=\"line\">   // Initialize the current Frame Buffer’s pixel color buffer </span><br><span class=\"line\">   // so that it shares the corresponding Core Animation Layer’s</span><br><span class=\"line\">   // pixel color storage.</span><br><span class=\"line\">   [self.context renderbufferStorage:GL_RENDERBUFFER </span><br><span class=\"line\">      fromDrawable:eaglLayer];</span><br><span class=\"line\">      </span><br><span class=\"line\">   </span><br><span class=\"line\">   if (0 != depthRenderBuffer)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      glDeleteRenderbuffers(1, &amp;depthRenderBuffer); // Step 7</span><br><span class=\"line\">      depthRenderBuffer = 0;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   GLint currentDrawableWidth = (GLint)self.drawableWidth;</span><br><span class=\"line\">   GLint currentDrawableHeight = (GLint)self.drawableHeight;</span><br><span class=\"line\">   </span><br><span class=\"line\">   if(self.drawableDepthFormat != </span><br><span class=\"line\">      AGLKViewDrawableDepthFormatNone &amp;&amp;</span><br><span class=\"line\">      0 &lt; currentDrawableWidth &amp;&amp;</span><br><span class=\"line\">      0 &lt; currentDrawableHeight)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      glGenRenderbuffers(1, &amp;depthRenderBuffer); // Step 1</span><br><span class=\"line\">      glBindRenderbuffer(GL_RENDERBUFFER,        // Step 2</span><br><span class=\"line\">         depthRenderBuffer);</span><br><span class=\"line\">      glRenderbufferStorage(GL_RENDERBUFFER,     // Step 3 </span><br><span class=\"line\">         GL_DEPTH_COMPONENT16, </span><br><span class=\"line\">         currentDrawableWidth, </span><br><span class=\"line\">         currentDrawableHeight);</span><br><span class=\"line\">      glFramebufferRenderbuffer(GL_FRAMEBUFFER,  // Step 4 </span><br><span class=\"line\">         GL_DEPTH_ATTACHMENT, </span><br><span class=\"line\">         GL_RENDERBUFFER, </span><br><span class=\"line\">         depthRenderBuffer);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Check for any errors configuring the render buffer   </span><br><span class=\"line\">   GLenum status = glCheckFramebufferStatus(</span><br><span class=\"line\">      GL_FRAMEBUFFER) ;</span><br><span class=\"line\">     </span><br><span class=\"line\">   if(status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class=\"line\">       NSLog(@&quot;failed to make complete frame buffer object %x&quot;, status);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   // Make the Color Render Buffer the current buffer for display</span><br><span class=\"line\">   glBindRenderbuffer(GL_RENDERBUFFER, colorRenderBuffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任何在接收到重新调整大小的消息时，Cocoa Touch都会调用下面的layoutSubviews；上下文的”renderbufferStorage:fromDrawable”方法会调整视图的缓存尺寸以匹配层的新尺寸；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method returns the width in pixels of current context&apos;s</span><br><span class=\"line\">// Pixel Color Render Buffer</span><br><span class=\"line\">- (NSInteger)drawableWidth;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLint          backingWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">   glGetRenderbufferParameteriv(</span><br><span class=\"line\">      GL_RENDERBUFFER, </span><br><span class=\"line\">      GL_RENDERBUFFER_WIDTH, </span><br><span class=\"line\">      &amp;backingWidth);</span><br><span class=\"line\">      </span><br><span class=\"line\">   return (NSInteger)backingWidth;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/////////////////////////////////////////////////////////////////</span><br><span class=\"line\">// This method returns the height in pixels of current context&apos;s</span><br><span class=\"line\">// Pixel Color Render Buffer</span><br><span class=\"line\">- (NSInteger)drawableHeight;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLint          backingHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">   glGetRenderbufferParameteriv(</span><br><span class=\"line\">      GL_RENDERBUFFER, </span><br><span class=\"line\">      GL_RENDERBUFFER_HEIGHT, </span><br><span class=\"line\">      &amp;backingHeight);</span><br><span class=\"line\">      </span><br><span class=\"line\">   return (NSInteger)backingHeight;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过OpenGLES的glGetRenderbufferParameteriv()方法获取和返回当前上下文的帧缓存的像素颜色渲染缓存尺寸;</p>\n<p>接下来要说说<em>AGLKViewController</em>,它使用一个CADisplayLink对象来调度和执行与控制器相关联的视力的周期性的重绘；<br>CADisplayLink本质上是一个用于显示更新的同步计时器，它能够被设置用来在每个显示更新或者其他更新时发送一个消息；<br>显示更新频率通常是由嵌入设备硬件决定的，它代表一个帧缓存的内容每秒最多能够被在屏幕上通过的像素显示出来的次数；</p>"},{"title":"Jenkins 构建之脚本篇","date":"2017-12-12T12:53:00.000Z","_content":"\n之前一直纠结Xcode 9之后用Jenkins导出.ipa文件失败，后经朋友指点终于成功，在此结出终级解决之法；\n<!-- more -->\n\n大致思路是这样的：Jenkins在网页中的配置大多会在之后进行整理，最终在终端生成shell脚本，然后每完成一项就会在构建结果中显示成功，如有一步错，则整个构建过程将会失败，所以这就解释了之前构建一直卡在了Achiver成功之后。\n\n基于上面的思路，则弃用之前的Jenkins配置，取消Jenkins项目中构建过程，Xcode配置全部清空，使用脚本配置，以下我会具体贴出，并适当讲解：\n\n```\n#!/bin/bash -l\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\nexport LC_ALL=en_US.UTF-8\n\n#以下PROJECT_NAME为项目工程名称\npod install --verbose --no-repo-update\nopen PROJECT_NAME.xcworkspace\n\n#以下USER_NAME为用户名\nproject_path=\"/Users/USER_NAME/.jenkins/workspace/PROJECT_NAME\"\n\n#指定项目地址\nworkspace_path=\"$project_path/PROJECT_NAME.xcworkspace\"\n\n#取当前时间字符串添加到文件夹结尾\nnow=$(date +\"%Y_%m_%d_%H_%M_%S\")\n\n#指定项目的scheme名称\nscheme=\"PROJECT_NAME\"\n#指定要打包的配置名\nconfiguration=\"Release\"\n#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数\nexport_method='enterprise'\n\n\n#指定输出路径\noutput_path=\"$project_path/build/PROJECT_NAME{now}\"\n#指定输出归档文件地址\narchive_path=\"$output_path/PROJECT_NAME.xcarchive\"\n#指定输出ipa名称\nipa_name=\"PROJECT_NAME{now}.ipa\"\n\n#指定输出ipa地址\nipa_path=\"$output_path/${ipa_name}\"\n#指定打包配置\nexport_plist_path=\"$project_path/ExportOptions.plist\"\n#获取执行命令时的commit message\n#commit_msg=\"$(cat $project_path/build_log.txt)\"\n\n#输出设定的变量值\necho \"===workspace path: ${workspace_path}===\"\necho \"===archive path: ${archive_path}===\"\necho \"===ipa path: ${ipa_path}===\"\necho \"===export method: ${export_method}===\"\n#echo \"===commit msg: ${commit_msg}===\"\n\n#先清空前一次build\nxcodebuild clean -workspace ${workspace_path} -scheme ${scheme} -configuration ${configuration}\n\n#归档\nxcodebuild archive -workspace ${workspace_path} -scheme ${scheme} -archivePath ${archive_path}\n\n#导出\nxcodebuild -exportArchive -archivePath ${archive_path} -exportPath ${output_path} -exportOptionsPlist ${export_plist_path}\n```\n\n依此上秘法，会获得Xcode 9下构建成功之案例，.ipa文件也会导出，至于之后上传到平台上，请到各平台下自行找文档整理，不做赘述。\n\n今天新年，祝大家新年快乐，2018，代码不出bug，新技术很快上手，妹子泡到手软，工资涨的飞快，人生乐的飞起！！！\n\n","source":"_posts/Jenkins 构建之脚本篇.md","raw":"title: Jenkins 构建之脚本篇\ndate: 2017-12-12 20:53:00\ncategories: coder\ntags: [jenkins]\n-----------\n\n之前一直纠结Xcode 9之后用Jenkins导出.ipa文件失败，后经朋友指点终于成功，在此结出终级解决之法；\n<!-- more -->\n\n大致思路是这样的：Jenkins在网页中的配置大多会在之后进行整理，最终在终端生成shell脚本，然后每完成一项就会在构建结果中显示成功，如有一步错，则整个构建过程将会失败，所以这就解释了之前构建一直卡在了Achiver成功之后。\n\n基于上面的思路，则弃用之前的Jenkins配置，取消Jenkins项目中构建过程，Xcode配置全部清空，使用脚本配置，以下我会具体贴出，并适当讲解：\n\n```\n#!/bin/bash -l\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\nexport LC_ALL=en_US.UTF-8\n\n#以下PROJECT_NAME为项目工程名称\npod install --verbose --no-repo-update\nopen PROJECT_NAME.xcworkspace\n\n#以下USER_NAME为用户名\nproject_path=\"/Users/USER_NAME/.jenkins/workspace/PROJECT_NAME\"\n\n#指定项目地址\nworkspace_path=\"$project_path/PROJECT_NAME.xcworkspace\"\n\n#取当前时间字符串添加到文件夹结尾\nnow=$(date +\"%Y_%m_%d_%H_%M_%S\")\n\n#指定项目的scheme名称\nscheme=\"PROJECT_NAME\"\n#指定要打包的配置名\nconfiguration=\"Release\"\n#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数\nexport_method='enterprise'\n\n\n#指定输出路径\noutput_path=\"$project_path/build/PROJECT_NAME{now}\"\n#指定输出归档文件地址\narchive_path=\"$output_path/PROJECT_NAME.xcarchive\"\n#指定输出ipa名称\nipa_name=\"PROJECT_NAME{now}.ipa\"\n\n#指定输出ipa地址\nipa_path=\"$output_path/${ipa_name}\"\n#指定打包配置\nexport_plist_path=\"$project_path/ExportOptions.plist\"\n#获取执行命令时的commit message\n#commit_msg=\"$(cat $project_path/build_log.txt)\"\n\n#输出设定的变量值\necho \"===workspace path: ${workspace_path}===\"\necho \"===archive path: ${archive_path}===\"\necho \"===ipa path: ${ipa_path}===\"\necho \"===export method: ${export_method}===\"\n#echo \"===commit msg: ${commit_msg}===\"\n\n#先清空前一次build\nxcodebuild clean -workspace ${workspace_path} -scheme ${scheme} -configuration ${configuration}\n\n#归档\nxcodebuild archive -workspace ${workspace_path} -scheme ${scheme} -archivePath ${archive_path}\n\n#导出\nxcodebuild -exportArchive -archivePath ${archive_path} -exportPath ${output_path} -exportOptionsPlist ${export_plist_path}\n```\n\n依此上秘法，会获得Xcode 9下构建成功之案例，.ipa文件也会导出，至于之后上传到平台上，请到各平台下自行找文档整理，不做赘述。\n\n今天新年，祝大家新年快乐，2018，代码不出bug，新技术很快上手，妹子泡到手软，工资涨的飞快，人生乐的飞起！！！\n\n","slug":"Jenkins 构建之脚本篇","published":1,"updated":"2018-05-04T08:49:13.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinq00091v60h4p5ig4n","content":"<p>之前一直纠结Xcode 9之后用Jenkins导出.ipa文件失败，后经朋友指点终于成功，在此结出终级解决之法；<br><a id=\"more\"></a></p>\n<p>大致思路是这样的：Jenkins在网页中的配置大多会在之后进行整理，最终在终端生成shell脚本，然后每完成一项就会在构建结果中显示成功，如有一步错，则整个构建过程将会失败，所以这就解释了之前构建一直卡在了Achiver成功之后。</p>\n<p>基于上面的思路，则弃用之前的Jenkins配置，取消Jenkins项目中构建过程，Xcode配置全部清空，使用脚本配置，以下我会具体贴出，并适当讲解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -l</span><br><span class=\"line\">export LANG=en_US.UTF-8</span><br><span class=\"line\">export LANGUAGE=en_US.UTF-8</span><br><span class=\"line\">export LC_ALL=en_US.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">#以下PROJECT_NAME为项目工程名称</span><br><span class=\"line\">pod install --verbose --no-repo-update</span><br><span class=\"line\">open PROJECT_NAME.xcworkspace</span><br><span class=\"line\"></span><br><span class=\"line\">#以下USER_NAME为用户名</span><br><span class=\"line\">project_path=&quot;/Users/USER_NAME/.jenkins/workspace/PROJECT_NAME&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#指定项目地址</span><br><span class=\"line\">workspace_path=&quot;$project_path/PROJECT_NAME.xcworkspace&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#取当前时间字符串添加到文件夹结尾</span><br><span class=\"line\">now=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">#指定项目的scheme名称</span><br><span class=\"line\">scheme=&quot;PROJECT_NAME&quot;</span><br><span class=\"line\">#指定要打包的配置名</span><br><span class=\"line\">configuration=&quot;Release&quot;</span><br><span class=\"line\">#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数</span><br><span class=\"line\">export_method=&apos;enterprise&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#指定输出路径</span><br><span class=\"line\">output_path=&quot;$project_path/build/PROJECT_NAME&#123;now&#125;&quot;</span><br><span class=\"line\">#指定输出归档文件地址</span><br><span class=\"line\">archive_path=&quot;$output_path/PROJECT_NAME.xcarchive&quot;</span><br><span class=\"line\">#指定输出ipa名称</span><br><span class=\"line\">ipa_name=&quot;PROJECT_NAME&#123;now&#125;.ipa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#指定输出ipa地址</span><br><span class=\"line\">ipa_path=&quot;$output_path/$&#123;ipa_name&#125;&quot;</span><br><span class=\"line\">#指定打包配置</span><br><span class=\"line\">export_plist_path=&quot;$project_path/ExportOptions.plist&quot;</span><br><span class=\"line\">#获取执行命令时的commit message</span><br><span class=\"line\">#commit_msg=&quot;$(cat $project_path/build_log.txt)&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#输出设定的变量值</span><br><span class=\"line\">echo &quot;===workspace path: $&#123;workspace_path&#125;===&quot;</span><br><span class=\"line\">echo &quot;===archive path: $&#123;archive_path&#125;===&quot;</span><br><span class=\"line\">echo &quot;===ipa path: $&#123;ipa_path&#125;===&quot;</span><br><span class=\"line\">echo &quot;===export method: $&#123;export_method&#125;===&quot;</span><br><span class=\"line\">#echo &quot;===commit msg: $&#123;commit_msg&#125;===&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#先清空前一次build</span><br><span class=\"line\">xcodebuild clean -workspace $&#123;workspace_path&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configuration&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#归档</span><br><span class=\"line\">xcodebuild archive -workspace $&#123;workspace_path&#125; -scheme $&#123;scheme&#125; -archivePath $&#123;archive_path&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#导出</span><br><span class=\"line\">xcodebuild -exportArchive -archivePath $&#123;archive_path&#125; -exportPath $&#123;output_path&#125; -exportOptionsPlist $&#123;export_plist_path&#125;</span><br></pre></td></tr></table></figure>\n<p>依此上秘法，会获得Xcode 9下构建成功之案例，.ipa文件也会导出，至于之后上传到平台上，请到各平台下自行找文档整理，不做赘述。</p>\n<p>今天新年，祝大家新年快乐，2018，代码不出bug，新技术很快上手，妹子泡到手软，工资涨的飞快，人生乐的飞起！！！</p>\n","site":{"data":{}},"excerpt":"<p>之前一直纠结Xcode 9之后用Jenkins导出.ipa文件失败，后经朋友指点终于成功，在此结出终级解决之法；<br>","more":"</p>\n<p>大致思路是这样的：Jenkins在网页中的配置大多会在之后进行整理，最终在终端生成shell脚本，然后每完成一项就会在构建结果中显示成功，如有一步错，则整个构建过程将会失败，所以这就解释了之前构建一直卡在了Achiver成功之后。</p>\n<p>基于上面的思路，则弃用之前的Jenkins配置，取消Jenkins项目中构建过程，Xcode配置全部清空，使用脚本配置，以下我会具体贴出，并适当讲解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash -l</span><br><span class=\"line\">export LANG=en_US.UTF-8</span><br><span class=\"line\">export LANGUAGE=en_US.UTF-8</span><br><span class=\"line\">export LC_ALL=en_US.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">#以下PROJECT_NAME为项目工程名称</span><br><span class=\"line\">pod install --verbose --no-repo-update</span><br><span class=\"line\">open PROJECT_NAME.xcworkspace</span><br><span class=\"line\"></span><br><span class=\"line\">#以下USER_NAME为用户名</span><br><span class=\"line\">project_path=&quot;/Users/USER_NAME/.jenkins/workspace/PROJECT_NAME&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#指定项目地址</span><br><span class=\"line\">workspace_path=&quot;$project_path/PROJECT_NAME.xcworkspace&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#取当前时间字符串添加到文件夹结尾</span><br><span class=\"line\">now=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">#指定项目的scheme名称</span><br><span class=\"line\">scheme=&quot;PROJECT_NAME&quot;</span><br><span class=\"line\">#指定要打包的配置名</span><br><span class=\"line\">configuration=&quot;Release&quot;</span><br><span class=\"line\">#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数</span><br><span class=\"line\">export_method=&apos;enterprise&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#指定输出路径</span><br><span class=\"line\">output_path=&quot;$project_path/build/PROJECT_NAME&#123;now&#125;&quot;</span><br><span class=\"line\">#指定输出归档文件地址</span><br><span class=\"line\">archive_path=&quot;$output_path/PROJECT_NAME.xcarchive&quot;</span><br><span class=\"line\">#指定输出ipa名称</span><br><span class=\"line\">ipa_name=&quot;PROJECT_NAME&#123;now&#125;.ipa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#指定输出ipa地址</span><br><span class=\"line\">ipa_path=&quot;$output_path/$&#123;ipa_name&#125;&quot;</span><br><span class=\"line\">#指定打包配置</span><br><span class=\"line\">export_plist_path=&quot;$project_path/ExportOptions.plist&quot;</span><br><span class=\"line\">#获取执行命令时的commit message</span><br><span class=\"line\">#commit_msg=&quot;$(cat $project_path/build_log.txt)&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#输出设定的变量值</span><br><span class=\"line\">echo &quot;===workspace path: $&#123;workspace_path&#125;===&quot;</span><br><span class=\"line\">echo &quot;===archive path: $&#123;archive_path&#125;===&quot;</span><br><span class=\"line\">echo &quot;===ipa path: $&#123;ipa_path&#125;===&quot;</span><br><span class=\"line\">echo &quot;===export method: $&#123;export_method&#125;===&quot;</span><br><span class=\"line\">#echo &quot;===commit msg: $&#123;commit_msg&#125;===&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#先清空前一次build</span><br><span class=\"line\">xcodebuild clean -workspace $&#123;workspace_path&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configuration&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#归档</span><br><span class=\"line\">xcodebuild archive -workspace $&#123;workspace_path&#125; -scheme $&#123;scheme&#125; -archivePath $&#123;archive_path&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#导出</span><br><span class=\"line\">xcodebuild -exportArchive -archivePath $&#123;archive_path&#125; -exportPath $&#123;output_path&#125; -exportOptionsPlist $&#123;export_plist_path&#125;</span><br></pre></td></tr></table></figure>\n<p>依此上秘法，会获得Xcode 9下构建成功之案例，.ipa文件也会导出，至于之后上传到平台上，请到各平台下自行找文档整理，不做赘述。</p>\n<p>今天新年，祝大家新年快乐，2018，代码不出bug，新技术很快上手，妹子泡到手软，工资涨的飞快，人生乐的飞起！！！</p>"},{"title":"Mac下Android Studio环境搭建","date":"2016-04-27T00:25:00.000Z","_content":"\n本篇还原了本人在Macbook pro上安装Android Studio2.0的过程，安装环境是OS X EI Capitan 10.11.4；\n<!-- more -->\n\n下载Java SDK包，Android Studio安装包，android SDK包，这些资源在http://www.android-studio.org/index.php/download这个网站上都可以找到；\n\n![网站标题](http://upload-images.jianshu.io/upload_images/1429775-80f5a33c449dec04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先安装Java SDK包，这个安装的时候比较容易，直接双击点开的包就可以了；\n\n![JDK](http://upload-images.jianshu.io/upload_images/1429775-be1726d680728df3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装Android Studio，打开安装包装包拖入到自己Applications中，\n\n![SDK](http://upload-images.jianshu.io/upload_images/1429775-ec89f55cd82937b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装完成后双击，它会提示你要不要打开，这个时候先不要打开，在Applications中右击显示包内容，在Contents/bin下打开idea.properties文件，在文件末尾添加一行：\n\n`disable.android.first.run=true`\n\n这是因为Android Studio会去获取 android sdk 组件信息，这个过程相当慢，还经常加载失败，导致Android Studio启动不起开。解决办法就是不去获取android sdk 组件信息。这个慢的原因，是因为android网站被墙了，必须翻墙才能访问到！所以如果你的电脑已经翻墙了，那么完全可以跳过这一步。\n\n接下来点打开，如果是先打开后修改的话它会提示你的包已经损坏，并让你删除；\n\n然后就是配置android SDK的目录了，我们把下载下来的包放到一个不经常修改的目录下，然后记住它的目录，我的是\n\n![SDK放在这里](http://upload-images.jianshu.io/upload_images/1429775-76fee3c672cffe2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nAndroid SDK Location就写你的SDK放置的路径，\n\n![image](http://upload-images.jianshu.io/upload_images/1429775-a4f081f44e57151c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后点Next就可以了，点完之后电脑会反应一会，时间会比较长，不要以为它什么都没有在干，等一会就好了。\n\n下一步我们来安装SDK，进入到设置好的SDK目录下，使用命令行进入tools目录，输入`./android sdk`请出SDK Manager图形界面，点击顶部菜单栏Android SDK Manager -> Preferences...\n\n进入配置页面，http proxy server这里填写： mirrors.neusoft.edu.cn （感谢东软搭建国内的镜像服务器，为广大程序员造福无数），如果以上填写的不能下载，也可以试着填写mirrors.opencas.ac.cn（这个也是从网上找的，感谢这些人的贡献）\n\n端口填写80，然后把Force https:// 前的勾勾上，然后点击mac顶部菜单Tools->Manage Add-on Site，把下面这堆网址：\n\nhttp://mirrors.neusoft.edu.cn/android/repository/addon-6.xml\n\n \nhttp://mirrors.neusoft.edu.cn/android/repository/addon.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/repository-10.xml\n\n\n\n全手动New加进去，然后就可以下载了\n\n![image](http://upload-images.jianshu.io/upload_images/1429775-769d654f67efd23f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来点击安装，下面是我安装过程中截的图：\n\n![等待良人归来那一秒。。。](http://upload-images.jianshu.io/upload_images/1429775-08a78264896a3537?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n接下来，你需要的是漫长的等待。。。。。。\n\n你的Android Studio就安装完成了。\n\n\n","source":"_posts/Mac下Android Studio环境搭建.md","raw":"title: Mac下Android Studio环境搭建\ndate: 2016-04-27 08:25:00\ncategories: coder\ntags: [Android Studio, mac]\n-----------\n\n本篇还原了本人在Macbook pro上安装Android Studio2.0的过程，安装环境是OS X EI Capitan 10.11.4；\n<!-- more -->\n\n下载Java SDK包，Android Studio安装包，android SDK包，这些资源在http://www.android-studio.org/index.php/download这个网站上都可以找到；\n\n![网站标题](http://upload-images.jianshu.io/upload_images/1429775-80f5a33c449dec04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先安装Java SDK包，这个安装的时候比较容易，直接双击点开的包就可以了；\n\n![JDK](http://upload-images.jianshu.io/upload_images/1429775-be1726d680728df3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装Android Studio，打开安装包装包拖入到自己Applications中，\n\n![SDK](http://upload-images.jianshu.io/upload_images/1429775-ec89f55cd82937b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装完成后双击，它会提示你要不要打开，这个时候先不要打开，在Applications中右击显示包内容，在Contents/bin下打开idea.properties文件，在文件末尾添加一行：\n\n`disable.android.first.run=true`\n\n这是因为Android Studio会去获取 android sdk 组件信息，这个过程相当慢，还经常加载失败，导致Android Studio启动不起开。解决办法就是不去获取android sdk 组件信息。这个慢的原因，是因为android网站被墙了，必须翻墙才能访问到！所以如果你的电脑已经翻墙了，那么完全可以跳过这一步。\n\n接下来点打开，如果是先打开后修改的话它会提示你的包已经损坏，并让你删除；\n\n然后就是配置android SDK的目录了，我们把下载下来的包放到一个不经常修改的目录下，然后记住它的目录，我的是\n\n![SDK放在这里](http://upload-images.jianshu.io/upload_images/1429775-76fee3c672cffe2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nAndroid SDK Location就写你的SDK放置的路径，\n\n![image](http://upload-images.jianshu.io/upload_images/1429775-a4f081f44e57151c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后点Next就可以了，点完之后电脑会反应一会，时间会比较长，不要以为它什么都没有在干，等一会就好了。\n\n下一步我们来安装SDK，进入到设置好的SDK目录下，使用命令行进入tools目录，输入`./android sdk`请出SDK Manager图形界面，点击顶部菜单栏Android SDK Manager -> Preferences...\n\n进入配置页面，http proxy server这里填写： mirrors.neusoft.edu.cn （感谢东软搭建国内的镜像服务器，为广大程序员造福无数），如果以上填写的不能下载，也可以试着填写mirrors.opencas.ac.cn（这个也是从网上找的，感谢这些人的贡献）\n\n端口填写80，然后把Force https:// 前的勾勾上，然后点击mac顶部菜单Tools->Manage Add-on Site，把下面这堆网址：\n\nhttp://mirrors.neusoft.edu.cn/android/repository/addon-6.xml\n\n \nhttp://mirrors.neusoft.edu.cn/android/repository/addon.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml \n\n\nhttp://mirrors.neusoft.edu.cn/android/repository/repository-10.xml\n\n\n\n全手动New加进去，然后就可以下载了\n\n![image](http://upload-images.jianshu.io/upload_images/1429775-769d654f67efd23f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来点击安装，下面是我安装过程中截的图：\n\n![等待良人归来那一秒。。。](http://upload-images.jianshu.io/upload_images/1429775-08a78264896a3537?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n接下来，你需要的是漫长的等待。。。。。。\n\n你的Android Studio就安装完成了。\n\n\n","slug":"Mac下Android Studio环境搭建","published":1,"updated":"2018-05-04T08:49:17.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinu000c1v60lev8bt7l","content":"<p>本篇还原了本人在Macbook pro上安装Android Studio2.0的过程，安装环境是OS X EI Capitan 10.11.4；<br><a id=\"more\"></a></p>\n<p>下载Java SDK包，Android Studio安装包，android SDK包，这些资源在<a href=\"http://www.android-studio.org/index.php/download这个网站上都可以找到；\" target=\"_blank\" rel=\"noopener\">http://www.android-studio.org/index.php/download这个网站上都可以找到；</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-80f5a33c449dec04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网站标题\"></p>\n<p>首先安装Java SDK包，这个安装的时候比较容易，直接双击点开的包就可以了；</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-be1726d680728df3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK\"></p>\n<p>安装Android Studio，打开安装包装包拖入到自己Applications中，</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-ec89f55cd82937b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SDK\"></p>\n<p>安装完成后双击，它会提示你要不要打开，这个时候先不要打开，在Applications中右击显示包内容，在Contents/bin下打开idea.properties文件，在文件末尾添加一行：</p>\n<p><code>disable.android.first.run=true</code></p>\n<p>这是因为Android Studio会去获取 android sdk 组件信息，这个过程相当慢，还经常加载失败，导致Android Studio启动不起开。解决办法就是不去获取android sdk 组件信息。这个慢的原因，是因为android网站被墙了，必须翻墙才能访问到！所以如果你的电脑已经翻墙了，那么完全可以跳过这一步。</p>\n<p>接下来点打开，如果是先打开后修改的话它会提示你的包已经损坏，并让你删除；</p>\n<p>然后就是配置android SDK的目录了，我们把下载下来的包放到一个不经常修改的目录下，然后记住它的目录，我的是</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-76fee3c672cffe2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SDK放在这里\"></p>\n<p>Android SDK Location就写你的SDK放置的路径，</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-a4f081f44e57151c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后点Next就可以了，点完之后电脑会反应一会，时间会比较长，不要以为它什么都没有在干，等一会就好了。</p>\n<p>下一步我们来安装SDK，进入到设置好的SDK目录下，使用命令行进入tools目录，输入<code>./android sdk</code>请出SDK Manager图形界面，点击顶部菜单栏Android SDK Manager -&gt; Preferences…</p>\n<p>进入配置页面，http proxy server这里填写： mirrors.neusoft.edu.cn （感谢东软搭建国内的镜像服务器，为广大程序员造福无数），如果以上填写的不能下载，也可以试着填写mirrors.opencas.ac.cn（这个也是从网上找的，感谢这些人的贡献）</p>\n<p>端口填写80，然后把Force https:// 前的勾勾上，然后点击mac顶部菜单Tools-&gt;Manage Add-on Site，把下面这堆网址：</p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/addon-6.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/addon-6.xml</a></p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/addon.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/addon.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/repository-10.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/repository-10.xml</a></p>\n<p>全手动New加进去，然后就可以下载了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-769d654f67efd23f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>接下来点击安装，下面是我安装过程中截的图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-08a78264896a3537?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"等待良人归来那一秒。。。\"></p>\n<p>接下来，你需要的是漫长的等待。。。。。。</p>\n<p>你的Android Studio就安装完成了。</p>\n","site":{"data":{}},"excerpt":"<p>本篇还原了本人在Macbook pro上安装Android Studio2.0的过程，安装环境是OS X EI Capitan 10.11.4；<br>","more":"</p>\n<p>下载Java SDK包，Android Studio安装包，android SDK包，这些资源在<a href=\"http://www.android-studio.org/index.php/download这个网站上都可以找到；\" target=\"_blank\" rel=\"noopener\">http://www.android-studio.org/index.php/download这个网站上都可以找到；</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-80f5a33c449dec04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网站标题\"></p>\n<p>首先安装Java SDK包，这个安装的时候比较容易，直接双击点开的包就可以了；</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-be1726d680728df3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK\"></p>\n<p>安装Android Studio，打开安装包装包拖入到自己Applications中，</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-ec89f55cd82937b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SDK\"></p>\n<p>安装完成后双击，它会提示你要不要打开，这个时候先不要打开，在Applications中右击显示包内容，在Contents/bin下打开idea.properties文件，在文件末尾添加一行：</p>\n<p><code>disable.android.first.run=true</code></p>\n<p>这是因为Android Studio会去获取 android sdk 组件信息，这个过程相当慢，还经常加载失败，导致Android Studio启动不起开。解决办法就是不去获取android sdk 组件信息。这个慢的原因，是因为android网站被墙了，必须翻墙才能访问到！所以如果你的电脑已经翻墙了，那么完全可以跳过这一步。</p>\n<p>接下来点打开，如果是先打开后修改的话它会提示你的包已经损坏，并让你删除；</p>\n<p>然后就是配置android SDK的目录了，我们把下载下来的包放到一个不经常修改的目录下，然后记住它的目录，我的是</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-76fee3c672cffe2b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SDK放在这里\"></p>\n<p>Android SDK Location就写你的SDK放置的路径，</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-a4f081f44e57151c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>然后点Next就可以了，点完之后电脑会反应一会，时间会比较长，不要以为它什么都没有在干，等一会就好了。</p>\n<p>下一步我们来安装SDK，进入到设置好的SDK目录下，使用命令行进入tools目录，输入<code>./android sdk</code>请出SDK Manager图形界面，点击顶部菜单栏Android SDK Manager -&gt; Preferences…</p>\n<p>进入配置页面，http proxy server这里填写： mirrors.neusoft.edu.cn （感谢东软搭建国内的镜像服务器，为广大程序员造福无数），如果以上填写的不能下载，也可以试着填写mirrors.opencas.ac.cn（这个也是从网上找的，感谢这些人的贡献）</p>\n<p>端口填写80，然后把Force https:// 前的勾勾上，然后点击mac顶部菜单Tools-&gt;Manage Add-on Site，把下面这堆网址：</p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/addon-6.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/addon-6.xml</a></p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/addon.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/addon.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/extras/intel/addon.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-tv/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android-wear/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/android/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/google_apis/sys-img.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/sys-img/x86/addon-x86.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/addons_list-2.xml</a> </p>\n<p><a href=\"http://mirrors.neusoft.edu.cn/android/repository/repository-10.xml\" target=\"_blank\" rel=\"noopener\">http://mirrors.neusoft.edu.cn/android/repository/repository-10.xml</a></p>\n<p>全手动New加进去，然后就可以下载了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-769d654f67efd23f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>接下来点击安装，下面是我安装过程中截的图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-08a78264896a3537?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"等待良人归来那一秒。。。\"></p>\n<p>接下来，你需要的是漫长的等待。。。。。。</p>\n<p>你的Android Studio就安装完成了。</p>"},{"title":"MGJRouter代码分析","date":"2018-01-07T09:21:00.000Z","_content":"\n今天来聊聊组件化，之前一直听说大厂在搞，什么淘宝架构，什么蘑菇街，既然谈到了架构的问题，那必属重中之重。接下来分析一下蘑菇街开源的代码，自己做个总结。\n<!-- more -->\n\n### 引入\n\n类书本的文章个人感觉还是写不来的，再搬到自己写的东西这来也不合适，所以直接上一链接，通过链接文章大致可了解下它的前身后世，产生原因，以及整体宏观架构设计，而我接下来要做的是细化，以及转化，便于自己吸收  \n---------> [组件化架构漫谈][1]\n\n1. 话不多说，先看入口：\n\n![image_1c25qj3m5ejq111g1v5lvkgjek9.png-7.7kB][2]\n```\n@interface MGJRouter ()\n/**\n *  保存了所有已注册的 URL\n *  结构类似 @{@\"beauty\": @{@\":id\": {@\"_\", [block copy]}}}\n */\n@property (nonatomic) NSMutableDictionary *routes;\n@end\n\n+ (instancetype)sharedInstance\n{\n    static MGJRouter *instance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        instance = [[self alloc] init];\n    });\n    return instance;\n}\n```\n很明显，蘑菇街架构（以下简称MGJ）通过该单例作管理，统一进行调配，而该单例仅有一个变量，就是**routes**，实际上它仅仅是管理了一个字典的结构，具体字典内有哪些内容，我们慢慢看；\n\n2. 回调Block的定义\n\n```\n/**\n *  routerParameters 里内置的几个参数会用到上面定义的 string\n */\ntypedef void (^MGJRouterHandler)(NSDictionary *routerParameters);\n\n/**\n *  需要返回一个 object，配合 objectForURL: 使用\n */\ntypedef id (^MGJRouterObjectHandler)(NSDictionary *routerParameters);\n```\n上面这两个block定义是MGJ注册URL的回调，一个带返回值，另一个不带，在这里我们说一下**带返回值的block用法**；如下举例 ------>\n![WX20180107-134538@2x.png-37.5kB][3]\n```\n//声明\ntypedef UIViewController *(^ViewControllerHandler)();\n\n//作参数\n@interface DemoListViewController : UIViewController\n+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler;\n@end\n\n//定义\n@implementation DemoListViewController\n+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler\n{\n    UIViewController* vc = handler()\n}\n@end\n\n//在别处调用\n@implementation DemoDetailViewController\n[DemoListViewController registerWithTitle:@\"基本使用\" handler:^UIViewController *{\n        return DemoDetailViewController();\n}];\n@end\n```\n如上，我们把`ViewControllerHandler`的运行延迟到了实际调用的时刻，并且我们可以在这个handler的实现中带入很多信息；\n\n3. MGJ数据结构管理\n\n```\nextern NSString *const MGJRouterParameterURL;\nextern NSString *const MGJRouterParameterCompletion;\nextern NSString *const MGJRouterParameterUserInfo;\n//*************************************************\nstatic NSString * const MGJ_ROUTER_WILDCARD_CHARACTER = @\"~\";  //这是一个占位符\nstatic NSString *specialCharacters = @\"/?&.\";\n\nNSString *const MGJRouterParameterURL = @\"MGJRouterParameterURL\";\nNSString *const MGJRouterParameterCompletion = @\"MGJRouterParameterCompletion\";\nNSString *const MGJRouterParameterUserInfo = @\"MGJRouterParameterUserInfo\";\n```\n从这里我们可以看出，MGJ的路由管理，实际上是一个解析url以及对应的管理，我们举几个URL来看一下：\n```\n@\"mgj://\"\n@\"mgj://foo/bar/none/exists\"\n@\"mgj://foo/bar\" \n@\"mgj://category/家居\"\n@\"mgj://category/travel\"\n@\"mgj://search/:query\"\n@\"mgj://detail\"\n@\"mgj://search/:keyword\"\n@\"mgj://search_top_bar\"\n```\n通过上面的URL我们可以看出，路由的管理实际上就是url的解析过程，下面我们来具体看一下解析过程；\n\n4. URL解析\n\n- route url\n\n![WX20180107-150437@2x.png-59.1kB][4]\n```\n- (NSArray*)pathComponentsFromURL:(NSString*)URL\n{\n    NSMutableArray *pathComponents = [NSMutableArray array];\n    if ([URL rangeOfString:@\"://\"].location != NSNotFound) {\n        NSArray *pathSegments = [URL componentsSeparatedByString:@\"://\"];\n        // 如果 URL 包含协议，那么把协议作为第一个元素放进去\n        [pathComponents addObject:pathSegments[0]];\n        \n        // 如果只有协议，那么放一个占位符\n        URL = pathSegments.lastObject;\n        if (!URL.length) {\n            [pathComponents addObject:MGJ_ROUTER_WILDCARD_CHARACTER];\n        }\n    }\n\n    for (NSString *pathComponent in [[NSURL URLWithString:URL] pathComponents]) {\n        if ([pathComponent isEqualToString:@\"/\"]) continue;\n        if ([[pathComponent substringToIndex:1] isEqualToString:@\"?\"]) break;\n        [pathComponents addObject:pathComponent];\n    }\n    return [pathComponents copy];\n}\n```\n\n- key-value\n![WX20180107-151956@2x.png-111.8kB][5]\n```\n- (NSMutableDictionary *)addURLPattern:(NSString *)URLPattern\n{\n    NSArray *pathComponents = [self pathComponentsFromURL:URLPattern];\n\n    NSMutableDictionary* subRoutes = self.routes;\n    \n    for (NSString* pathComponent in pathComponents) {\n        if (![subRoutes objectForKey:pathComponent]) {\n            subRoutes[pathComponent] = [[NSMutableDictionary alloc] init];\n        }\n        subRoutes = subRoutes[pathComponent];\n    }\n    return subRoutes;\n}\n```\n- 核心url解析\n\n![WX20180107-160319@2x.png-147.8kB][6]\n```\n- (NSMutableDictionary *)extractParametersFromURL:(NSString *)url\n{\n    NSMutableDictionary* parameters = [NSMutableDictionary dictionary];\n    \n    parameters[MGJRouterParameterURL] = url;\n    \n    NSMutableDictionary* subRoutes = self.routes;\n    NSArray* pathComponents = [self pathComponentsFromURL:url];\n    \n    BOOL found = NO;\n    // borrowed from HHRouter(https://github.com/Huohua/HHRouter)\n    for (NSString* pathComponent in pathComponents) {\n        \n        // 对 key 进行排序，这样可以把 ~ 放到最后\n        NSArray *subRoutesKeys =[subRoutes.allKeys sortedArrayUsingComparator:^NSComparisonResult(NSString *obj1, NSString *obj2) {\n            return [obj1 compare:obj2];\n        }];\n        \n        for (NSString* key in subRoutesKeys) {\n            if ([key isEqualToString:pathComponent] || [key isEqualToString:MGJ_ROUTER_WILDCARD_CHARACTER]) {\n                found = YES;\n                subRoutes = subRoutes[key];\n                break;\n            } else if ([key hasPrefix:@\":\"]) {\n                found = YES;\n                subRoutes = subRoutes[key];\n                NSString *newKey = [key substringFromIndex:1];\n                NSString *newPathComponent = pathComponent;\n                // 再做一下特殊处理，比如 :id.html -> :id\n                if ([self.class checkIfContainsSpecialCharacter:key]) {\n                    NSCharacterSet *specialCharacterSet = [NSCharacterSet characterSetWithCharactersInString:specialCharacters];\n                    NSRange range = [key rangeOfCharacterFromSet:specialCharacterSet];\n                    if (range.location != NSNotFound) {\n                        // 把 pathComponent 后面的部分也去掉\n                        newKey = [newKey substringToIndex:range.location - 1];\n                        NSString *suffixToStrip = [key substringFromIndex:range.location];\n                        newPathComponent = [newPathComponent stringByReplacingOccurrencesOfString:suffixToStrip withString:@\"\"];\n                    }\n                }\n                parameters[newKey] = newPathComponent;\n                break;\n            }\n        }\n        \n        // 如果没有找到该 pathComponent 对应的 handler，则以上一层的 handler 作为 fallback\n        if (!found && !subRoutes[@\"_\"]) {\n            return nil;\n        }\n    }\n    \n    // Extract Params From Query.\n    NSArray<NSURLQueryItem *> *queryItems = [[NSURLComponents alloc] initWithURL:[[NSURL alloc] initWithString:url] resolvingAgainstBaseURL:false].queryItems;\n    \n    for (NSURLQueryItem *item in queryItems) {\n        parameters[item.name] = item.value;\n    }\n\n    if (subRoutes[@\"_\"]) {\n        parameters[@\"block\"] = [subRoutes[@\"_\"] copy];\n    }\n    \n    return parameters;\n}\n```\n\n```\n+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion\n{\n    URL = [URL stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n    NSMutableDictionary *parameters = [[self sharedInstance] extractParametersFromURL:URL];\n    \n    [parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) {\n        if ([obj isKindOfClass:[NSString class]]) {\n            parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n        }\n    }];\n    \n    if (parameters) {\n        MGJRouterHandler handler = parameters[@\"block\"];\n        if (completion) {\n            parameters[MGJRouterParameterCompletion] = completion;\n        }\n        if (userInfo) {\n            parameters[MGJRouterParameterUserInfo] = userInfo;\n        }\n        //所以注册路由时的回调是在这里才调用到的\n        //也就是openURL响应了register的回调\n        if (handler) {\n            [parameters removeObjectForKey:@\"block\"];\n            handler(parameters);\n        }\n    }\n}\n```\n\n5. 后续？\n\n\n[1]: https://www.jianshu.com/p/67a6004f6930\n[2]: http://static.zybuluo.com/usiege/f0dci325k3jmmrh2l9uy51s4/image_1c25qj3m5ejq111g1v5lvkgjek9.png\n[3]: http://static.zybuluo.com/usiege/xn1r7ergmr6xr6msy2p5tyrh/WX20180107-134538@2x.png\n[4]: http://static.zybuluo.com/usiege/wr5j4jwfcaov7yfmx3u82nyk/WX20180107-150437@2x.png\n[5]: http://static.zybuluo.com/usiege/j23e7t541u0wcoohza0ktqmb/WX20180107-151956@2x.png\n[6]: http://static.zybuluo.com/usiege/cbn7v2xkwlfy3c19m322o7mg/WX20180107-160319@2x.png","source":"_posts/MGJRouter代码分析.md","raw":"title: MGJRouter代码分析\ndate: 2018-01-07 17:21:00\ncategories: coder\ntags: [iOS, modularization]\n-----------\n\n今天来聊聊组件化，之前一直听说大厂在搞，什么淘宝架构，什么蘑菇街，既然谈到了架构的问题，那必属重中之重。接下来分析一下蘑菇街开源的代码，自己做个总结。\n<!-- more -->\n\n### 引入\n\n类书本的文章个人感觉还是写不来的，再搬到自己写的东西这来也不合适，所以直接上一链接，通过链接文章大致可了解下它的前身后世，产生原因，以及整体宏观架构设计，而我接下来要做的是细化，以及转化，便于自己吸收  \n---------> [组件化架构漫谈][1]\n\n1. 话不多说，先看入口：\n\n![image_1c25qj3m5ejq111g1v5lvkgjek9.png-7.7kB][2]\n```\n@interface MGJRouter ()\n/**\n *  保存了所有已注册的 URL\n *  结构类似 @{@\"beauty\": @{@\":id\": {@\"_\", [block copy]}}}\n */\n@property (nonatomic) NSMutableDictionary *routes;\n@end\n\n+ (instancetype)sharedInstance\n{\n    static MGJRouter *instance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        instance = [[self alloc] init];\n    });\n    return instance;\n}\n```\n很明显，蘑菇街架构（以下简称MGJ）通过该单例作管理，统一进行调配，而该单例仅有一个变量，就是**routes**，实际上它仅仅是管理了一个字典的结构，具体字典内有哪些内容，我们慢慢看；\n\n2. 回调Block的定义\n\n```\n/**\n *  routerParameters 里内置的几个参数会用到上面定义的 string\n */\ntypedef void (^MGJRouterHandler)(NSDictionary *routerParameters);\n\n/**\n *  需要返回一个 object，配合 objectForURL: 使用\n */\ntypedef id (^MGJRouterObjectHandler)(NSDictionary *routerParameters);\n```\n上面这两个block定义是MGJ注册URL的回调，一个带返回值，另一个不带，在这里我们说一下**带返回值的block用法**；如下举例 ------>\n![WX20180107-134538@2x.png-37.5kB][3]\n```\n//声明\ntypedef UIViewController *(^ViewControllerHandler)();\n\n//作参数\n@interface DemoListViewController : UIViewController\n+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler;\n@end\n\n//定义\n@implementation DemoListViewController\n+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler\n{\n    UIViewController* vc = handler()\n}\n@end\n\n//在别处调用\n@implementation DemoDetailViewController\n[DemoListViewController registerWithTitle:@\"基本使用\" handler:^UIViewController *{\n        return DemoDetailViewController();\n}];\n@end\n```\n如上，我们把`ViewControllerHandler`的运行延迟到了实际调用的时刻，并且我们可以在这个handler的实现中带入很多信息；\n\n3. MGJ数据结构管理\n\n```\nextern NSString *const MGJRouterParameterURL;\nextern NSString *const MGJRouterParameterCompletion;\nextern NSString *const MGJRouterParameterUserInfo;\n//*************************************************\nstatic NSString * const MGJ_ROUTER_WILDCARD_CHARACTER = @\"~\";  //这是一个占位符\nstatic NSString *specialCharacters = @\"/?&.\";\n\nNSString *const MGJRouterParameterURL = @\"MGJRouterParameterURL\";\nNSString *const MGJRouterParameterCompletion = @\"MGJRouterParameterCompletion\";\nNSString *const MGJRouterParameterUserInfo = @\"MGJRouterParameterUserInfo\";\n```\n从这里我们可以看出，MGJ的路由管理，实际上是一个解析url以及对应的管理，我们举几个URL来看一下：\n```\n@\"mgj://\"\n@\"mgj://foo/bar/none/exists\"\n@\"mgj://foo/bar\" \n@\"mgj://category/家居\"\n@\"mgj://category/travel\"\n@\"mgj://search/:query\"\n@\"mgj://detail\"\n@\"mgj://search/:keyword\"\n@\"mgj://search_top_bar\"\n```\n通过上面的URL我们可以看出，路由的管理实际上就是url的解析过程，下面我们来具体看一下解析过程；\n\n4. URL解析\n\n- route url\n\n![WX20180107-150437@2x.png-59.1kB][4]\n```\n- (NSArray*)pathComponentsFromURL:(NSString*)URL\n{\n    NSMutableArray *pathComponents = [NSMutableArray array];\n    if ([URL rangeOfString:@\"://\"].location != NSNotFound) {\n        NSArray *pathSegments = [URL componentsSeparatedByString:@\"://\"];\n        // 如果 URL 包含协议，那么把协议作为第一个元素放进去\n        [pathComponents addObject:pathSegments[0]];\n        \n        // 如果只有协议，那么放一个占位符\n        URL = pathSegments.lastObject;\n        if (!URL.length) {\n            [pathComponents addObject:MGJ_ROUTER_WILDCARD_CHARACTER];\n        }\n    }\n\n    for (NSString *pathComponent in [[NSURL URLWithString:URL] pathComponents]) {\n        if ([pathComponent isEqualToString:@\"/\"]) continue;\n        if ([[pathComponent substringToIndex:1] isEqualToString:@\"?\"]) break;\n        [pathComponents addObject:pathComponent];\n    }\n    return [pathComponents copy];\n}\n```\n\n- key-value\n![WX20180107-151956@2x.png-111.8kB][5]\n```\n- (NSMutableDictionary *)addURLPattern:(NSString *)URLPattern\n{\n    NSArray *pathComponents = [self pathComponentsFromURL:URLPattern];\n\n    NSMutableDictionary* subRoutes = self.routes;\n    \n    for (NSString* pathComponent in pathComponents) {\n        if (![subRoutes objectForKey:pathComponent]) {\n            subRoutes[pathComponent] = [[NSMutableDictionary alloc] init];\n        }\n        subRoutes = subRoutes[pathComponent];\n    }\n    return subRoutes;\n}\n```\n- 核心url解析\n\n![WX20180107-160319@2x.png-147.8kB][6]\n```\n- (NSMutableDictionary *)extractParametersFromURL:(NSString *)url\n{\n    NSMutableDictionary* parameters = [NSMutableDictionary dictionary];\n    \n    parameters[MGJRouterParameterURL] = url;\n    \n    NSMutableDictionary* subRoutes = self.routes;\n    NSArray* pathComponents = [self pathComponentsFromURL:url];\n    \n    BOOL found = NO;\n    // borrowed from HHRouter(https://github.com/Huohua/HHRouter)\n    for (NSString* pathComponent in pathComponents) {\n        \n        // 对 key 进行排序，这样可以把 ~ 放到最后\n        NSArray *subRoutesKeys =[subRoutes.allKeys sortedArrayUsingComparator:^NSComparisonResult(NSString *obj1, NSString *obj2) {\n            return [obj1 compare:obj2];\n        }];\n        \n        for (NSString* key in subRoutesKeys) {\n            if ([key isEqualToString:pathComponent] || [key isEqualToString:MGJ_ROUTER_WILDCARD_CHARACTER]) {\n                found = YES;\n                subRoutes = subRoutes[key];\n                break;\n            } else if ([key hasPrefix:@\":\"]) {\n                found = YES;\n                subRoutes = subRoutes[key];\n                NSString *newKey = [key substringFromIndex:1];\n                NSString *newPathComponent = pathComponent;\n                // 再做一下特殊处理，比如 :id.html -> :id\n                if ([self.class checkIfContainsSpecialCharacter:key]) {\n                    NSCharacterSet *specialCharacterSet = [NSCharacterSet characterSetWithCharactersInString:specialCharacters];\n                    NSRange range = [key rangeOfCharacterFromSet:specialCharacterSet];\n                    if (range.location != NSNotFound) {\n                        // 把 pathComponent 后面的部分也去掉\n                        newKey = [newKey substringToIndex:range.location - 1];\n                        NSString *suffixToStrip = [key substringFromIndex:range.location];\n                        newPathComponent = [newPathComponent stringByReplacingOccurrencesOfString:suffixToStrip withString:@\"\"];\n                    }\n                }\n                parameters[newKey] = newPathComponent;\n                break;\n            }\n        }\n        \n        // 如果没有找到该 pathComponent 对应的 handler，则以上一层的 handler 作为 fallback\n        if (!found && !subRoutes[@\"_\"]) {\n            return nil;\n        }\n    }\n    \n    // Extract Params From Query.\n    NSArray<NSURLQueryItem *> *queryItems = [[NSURLComponents alloc] initWithURL:[[NSURL alloc] initWithString:url] resolvingAgainstBaseURL:false].queryItems;\n    \n    for (NSURLQueryItem *item in queryItems) {\n        parameters[item.name] = item.value;\n    }\n\n    if (subRoutes[@\"_\"]) {\n        parameters[@\"block\"] = [subRoutes[@\"_\"] copy];\n    }\n    \n    return parameters;\n}\n```\n\n```\n+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion\n{\n    URL = [URL stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n    NSMutableDictionary *parameters = [[self sharedInstance] extractParametersFromURL:URL];\n    \n    [parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) {\n        if ([obj isKindOfClass:[NSString class]]) {\n            parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n        }\n    }];\n    \n    if (parameters) {\n        MGJRouterHandler handler = parameters[@\"block\"];\n        if (completion) {\n            parameters[MGJRouterParameterCompletion] = completion;\n        }\n        if (userInfo) {\n            parameters[MGJRouterParameterUserInfo] = userInfo;\n        }\n        //所以注册路由时的回调是在这里才调用到的\n        //也就是openURL响应了register的回调\n        if (handler) {\n            [parameters removeObjectForKey:@\"block\"];\n            handler(parameters);\n        }\n    }\n}\n```\n\n5. 后续？\n\n\n[1]: https://www.jianshu.com/p/67a6004f6930\n[2]: http://static.zybuluo.com/usiege/f0dci325k3jmmrh2l9uy51s4/image_1c25qj3m5ejq111g1v5lvkgjek9.png\n[3]: http://static.zybuluo.com/usiege/xn1r7ergmr6xr6msy2p5tyrh/WX20180107-134538@2x.png\n[4]: http://static.zybuluo.com/usiege/wr5j4jwfcaov7yfmx3u82nyk/WX20180107-150437@2x.png\n[5]: http://static.zybuluo.com/usiege/j23e7t541u0wcoohza0ktqmb/WX20180107-151956@2x.png\n[6]: http://static.zybuluo.com/usiege/cbn7v2xkwlfy3c19m322o7mg/WX20180107-160319@2x.png","slug":"MGJRouter代码分析","published":1,"updated":"2018-05-04T08:49:19.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinx000d1v60fnrq9si2","content":"<p>今天来聊聊组件化，之前一直听说大厂在搞，什么淘宝架构，什么蘑菇街，既然谈到了架构的问题，那必属重中之重。接下来分析一下蘑菇街开源的代码，自己做个总结。<br><a id=\"more\"></a></p>\n<h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><p>类书本的文章个人感觉还是写不来的，再搬到自己写的东西这来也不合适，所以直接上一链接，通过链接文章大致可了解下它的前身后世，产生原因，以及整体宏观架构设计，而我接下来要做的是细化，以及转化，便于自己吸收<br>———&gt; <a href=\"https://www.jianshu.com/p/67a6004f6930\" target=\"_blank\" rel=\"noopener\">组件化架构漫谈</a></p>\n<ol>\n<li>话不多说，先看入口：</li>\n</ol>\n<p><img src=\"http://static.zybuluo.com/usiege/f0dci325k3jmmrh2l9uy51s4/image_1c25qj3m5ejq111g1v5lvkgjek9.png\" alt=\"image_1c25qj3m5ejq111g1v5lvkgjek9.png-7.7kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface MGJRouter ()</span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  保存了所有已注册的 URL</span><br><span class=\"line\"> *  结构类似 @&#123;@&quot;beauty&quot;: @&#123;@&quot;:id&quot;: &#123;@&quot;_&quot;, [block copy]&#125;&#125;&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">@property (nonatomic) NSMutableDictionary *routes;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static MGJRouter *instance = nil;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        instance = [[self alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很明显，蘑菇街架构（以下简称MGJ）通过该单例作管理，统一进行调配，而该单例仅有一个变量，就是<strong>routes</strong>，实际上它仅仅是管理了一个字典的结构，具体字典内有哪些内容，我们慢慢看；</p>\n<ol start=\"2\">\n<li>回调Block的定义</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  routerParameters 里内置的几个参数会用到上面定义的 string</span><br><span class=\"line\"> */</span><br><span class=\"line\">typedef void (^MGJRouterHandler)(NSDictionary *routerParameters);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  需要返回一个 object，配合 objectForURL: 使用</span><br><span class=\"line\"> */</span><br><span class=\"line\">typedef id (^MGJRouterObjectHandler)(NSDictionary *routerParameters);</span><br></pre></td></tr></table></figure>\n<p>上面这两个block定义是MGJ注册URL的回调，一个带返回值，另一个不带，在这里我们说一下<strong>带返回值的block用法</strong>；如下举例 ——&gt;<br><img src=\"http://static.zybuluo.com/usiege/xn1r7ergmr6xr6msy2p5tyrh/WX20180107-134538@2x.png\" alt=\"WX20180107-134538@2x.png-37.5kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明</span><br><span class=\"line\">typedef UIViewController *(^ViewControllerHandler)();</span><br><span class=\"line\"></span><br><span class=\"line\">//作参数</span><br><span class=\"line\">@interface DemoListViewController : UIViewController</span><br><span class=\"line\">+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//定义</span><br><span class=\"line\">@implementation DemoListViewController</span><br><span class=\"line\">+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UIViewController* vc = handler()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//在别处调用</span><br><span class=\"line\">@implementation DemoDetailViewController</span><br><span class=\"line\">[DemoListViewController registerWithTitle:@&quot;基本使用&quot; handler:^UIViewController *&#123;</span><br><span class=\"line\">        return DemoDetailViewController();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>如上，我们把<code>ViewControllerHandler</code>的运行延迟到了实际调用的时刻，并且我们可以在这个handler的实现中带入很多信息；</p>\n<ol start=\"3\">\n<li>MGJ数据结构管理</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern NSString *const MGJRouterParameterURL;</span><br><span class=\"line\">extern NSString *const MGJRouterParameterCompletion;</span><br><span class=\"line\">extern NSString *const MGJRouterParameterUserInfo;</span><br><span class=\"line\">//*************************************************</span><br><span class=\"line\">static NSString * const MGJ_ROUTER_WILDCARD_CHARACTER = @&quot;~&quot;;  //这是一个占位符</span><br><span class=\"line\">static NSString *specialCharacters = @&quot;/?&amp;.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString *const MGJRouterParameterURL = @&quot;MGJRouterParameterURL&quot;;</span><br><span class=\"line\">NSString *const MGJRouterParameterCompletion = @&quot;MGJRouterParameterCompletion&quot;;</span><br><span class=\"line\">NSString *const MGJRouterParameterUserInfo = @&quot;MGJRouterParameterUserInfo&quot;;</span><br></pre></td></tr></table></figure>\n<p>从这里我们可以看出，MGJ的路由管理，实际上是一个解析url以及对应的管理，我们举几个URL来看一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&quot;mgj://&quot;</span><br><span class=\"line\">@&quot;mgj://foo/bar/none/exists&quot;</span><br><span class=\"line\">@&quot;mgj://foo/bar&quot; </span><br><span class=\"line\">@&quot;mgj://category/家居&quot;</span><br><span class=\"line\">@&quot;mgj://category/travel&quot;</span><br><span class=\"line\">@&quot;mgj://search/:query&quot;</span><br><span class=\"line\">@&quot;mgj://detail&quot;</span><br><span class=\"line\">@&quot;mgj://search/:keyword&quot;</span><br><span class=\"line\">@&quot;mgj://search_top_bar&quot;</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的URL我们可以看出，路由的管理实际上就是url的解析过程，下面我们来具体看一下解析过程；</p>\n<ol start=\"4\">\n<li>URL解析</li>\n</ol>\n<ul>\n<li>route url</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/usiege/wr5j4jwfcaov7yfmx3u82nyk/WX20180107-150437@2x.png\" alt=\"WX20180107-150437@2x.png-59.1kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray*)pathComponentsFromURL:(NSString*)URL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *pathComponents = [NSMutableArray array];</span><br><span class=\"line\">    if ([URL rangeOfString:@&quot;://&quot;].location != NSNotFound) &#123;</span><br><span class=\"line\">        NSArray *pathSegments = [URL componentsSeparatedByString:@&quot;://&quot;];</span><br><span class=\"line\">        // 如果 URL 包含协议，那么把协议作为第一个元素放进去</span><br><span class=\"line\">        [pathComponents addObject:pathSegments[0]];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 如果只有协议，那么放一个占位符</span><br><span class=\"line\">        URL = pathSegments.lastObject;</span><br><span class=\"line\">        if (!URL.length) &#123;</span><br><span class=\"line\">            [pathComponents addObject:MGJ_ROUTER_WILDCARD_CHARACTER];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (NSString *pathComponent in [[NSURL URLWithString:URL] pathComponents]) &#123;</span><br><span class=\"line\">        if ([pathComponent isEqualToString:@&quot;/&quot;]) continue;</span><br><span class=\"line\">        if ([[pathComponent substringToIndex:1] isEqualToString:@&quot;?&quot;]) break;</span><br><span class=\"line\">        [pathComponents addObject:pathComponent];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [pathComponents copy];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>key-value<br><img src=\"http://static.zybuluo.com/usiege/j23e7t541u0wcoohza0ktqmb/WX20180107-151956@2x.png\" alt=\"WX20180107-151956@2x.png-111.8kB\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSMutableDictionary *)addURLPattern:(NSString *)URLPattern</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSArray *pathComponents = [self pathComponentsFromURL:URLPattern];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSMutableDictionary* subRoutes = self.routes;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (NSString* pathComponent in pathComponents) &#123;</span><br><span class=\"line\">        if (![subRoutes objectForKey:pathComponent]) &#123;</span><br><span class=\"line\">            subRoutes[pathComponent] = [[NSMutableDictionary alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subRoutes = subRoutes[pathComponent];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return subRoutes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>核心url解析</p>\n</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/usiege/cbn7v2xkwlfy3c19m322o7mg/WX20180107-160319@2x.png\" alt=\"WX20180107-160319@2x.png-147.8kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSMutableDictionary *)extractParametersFromURL:(NSString *)url</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableDictionary* parameters = [NSMutableDictionary dictionary];</span><br><span class=\"line\">    </span><br><span class=\"line\">    parameters[MGJRouterParameterURL] = url;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableDictionary* subRoutes = self.routes;</span><br><span class=\"line\">    NSArray* pathComponents = [self pathComponentsFromURL:url];</span><br><span class=\"line\">    </span><br><span class=\"line\">    BOOL found = NO;</span><br><span class=\"line\">    // borrowed from HHRouter(https://github.com/Huohua/HHRouter)</span><br><span class=\"line\">    for (NSString* pathComponent in pathComponents) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 对 key 进行排序，这样可以把 ~ 放到最后</span><br><span class=\"line\">        NSArray *subRoutesKeys =[subRoutes.allKeys sortedArrayUsingComparator:^NSComparisonResult(NSString *obj1, NSString *obj2) &#123;</span><br><span class=\"line\">            return [obj1 compare:obj2];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (NSString* key in subRoutesKeys) &#123;</span><br><span class=\"line\">            if ([key isEqualToString:pathComponent] || [key isEqualToString:MGJ_ROUTER_WILDCARD_CHARACTER]) &#123;</span><br><span class=\"line\">                found = YES;</span><br><span class=\"line\">                subRoutes = subRoutes[key];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125; else if ([key hasPrefix:@&quot;:&quot;]) &#123;</span><br><span class=\"line\">                found = YES;</span><br><span class=\"line\">                subRoutes = subRoutes[key];</span><br><span class=\"line\">                NSString *newKey = [key substringFromIndex:1];</span><br><span class=\"line\">                NSString *newPathComponent = pathComponent;</span><br><span class=\"line\">                // 再做一下特殊处理，比如 :id.html -&gt; :id</span><br><span class=\"line\">                if ([self.class checkIfContainsSpecialCharacter:key]) &#123;</span><br><span class=\"line\">                    NSCharacterSet *specialCharacterSet = [NSCharacterSet characterSetWithCharactersInString:specialCharacters];</span><br><span class=\"line\">                    NSRange range = [key rangeOfCharacterFromSet:specialCharacterSet];</span><br><span class=\"line\">                    if (range.location != NSNotFound) &#123;</span><br><span class=\"line\">                        // 把 pathComponent 后面的部分也去掉</span><br><span class=\"line\">                        newKey = [newKey substringToIndex:range.location - 1];</span><br><span class=\"line\">                        NSString *suffixToStrip = [key substringFromIndex:range.location];</span><br><span class=\"line\">                        newPathComponent = [newPathComponent stringByReplacingOccurrencesOfString:suffixToStrip withString:@&quot;&quot;];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                parameters[newKey] = newPathComponent;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 如果没有找到该 pathComponent 对应的 handler，则以上一层的 handler 作为 fallback</span><br><span class=\"line\">        if (!found &amp;&amp; !subRoutes[@&quot;_&quot;]) &#123;</span><br><span class=\"line\">            return nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Extract Params From Query.</span><br><span class=\"line\">    NSArray&lt;NSURLQueryItem *&gt; *queryItems = [[NSURLComponents alloc] initWithURL:[[NSURL alloc] initWithString:url] resolvingAgainstBaseURL:false].queryItems;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (NSURLQueryItem *item in queryItems) &#123;</span><br><span class=\"line\">        parameters[item.name] = item.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (subRoutes[@&quot;_&quot;]) &#123;</span><br><span class=\"line\">        parameters[@&quot;block&quot;] = [subRoutes[@&quot;_&quot;] copy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return parameters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    URL = [URL stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\">    NSMutableDictionary *parameters = [[self sharedInstance] extractParametersFromURL:URL];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) &#123;</span><br><span class=\"line\">        if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class=\"line\">            parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (parameters) &#123;</span><br><span class=\"line\">        MGJRouterHandler handler = parameters[@&quot;block&quot;];</span><br><span class=\"line\">        if (completion) &#123;</span><br><span class=\"line\">            parameters[MGJRouterParameterCompletion] = completion;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (userInfo) &#123;</span><br><span class=\"line\">            parameters[MGJRouterParameterUserInfo] = userInfo;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //所以注册路由时的回调是在这里才调用到的</span><br><span class=\"line\">        //也就是openURL响应了register的回调</span><br><span class=\"line\">        if (handler) &#123;</span><br><span class=\"line\">            [parameters removeObjectForKey:@&quot;block&quot;];</span><br><span class=\"line\">            handler(parameters);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>后续？</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>今天来聊聊组件化，之前一直听说大厂在搞，什么淘宝架构，什么蘑菇街，既然谈到了架构的问题，那必属重中之重。接下来分析一下蘑菇街开源的代码，自己做个总结。<br>","more":"</p>\n<h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><p>类书本的文章个人感觉还是写不来的，再搬到自己写的东西这来也不合适，所以直接上一链接，通过链接文章大致可了解下它的前身后世，产生原因，以及整体宏观架构设计，而我接下来要做的是细化，以及转化，便于自己吸收<br>———&gt; <a href=\"https://www.jianshu.com/p/67a6004f6930\" target=\"_blank\" rel=\"noopener\">组件化架构漫谈</a></p>\n<ol>\n<li>话不多说，先看入口：</li>\n</ol>\n<p><img src=\"http://static.zybuluo.com/usiege/f0dci325k3jmmrh2l9uy51s4/image_1c25qj3m5ejq111g1v5lvkgjek9.png\" alt=\"image_1c25qj3m5ejq111g1v5lvkgjek9.png-7.7kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface MGJRouter ()</span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  保存了所有已注册的 URL</span><br><span class=\"line\"> *  结构类似 @&#123;@&quot;beauty&quot;: @&#123;@&quot;:id&quot;: &#123;@&quot;_&quot;, [block copy]&#125;&#125;&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">@property (nonatomic) NSMutableDictionary *routes;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedInstance</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static MGJRouter *instance = nil;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        instance = [[self alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很明显，蘑菇街架构（以下简称MGJ）通过该单例作管理，统一进行调配，而该单例仅有一个变量，就是<strong>routes</strong>，实际上它仅仅是管理了一个字典的结构，具体字典内有哪些内容，我们慢慢看；</p>\n<ol start=\"2\">\n<li>回调Block的定义</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  routerParameters 里内置的几个参数会用到上面定义的 string</span><br><span class=\"line\"> */</span><br><span class=\"line\">typedef void (^MGJRouterHandler)(NSDictionary *routerParameters);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  需要返回一个 object，配合 objectForURL: 使用</span><br><span class=\"line\"> */</span><br><span class=\"line\">typedef id (^MGJRouterObjectHandler)(NSDictionary *routerParameters);</span><br></pre></td></tr></table></figure>\n<p>上面这两个block定义是MGJ注册URL的回调，一个带返回值，另一个不带，在这里我们说一下<strong>带返回值的block用法</strong>；如下举例 ——&gt;<br><img src=\"http://static.zybuluo.com/usiege/xn1r7ergmr6xr6msy2p5tyrh/WX20180107-134538@2x.png\" alt=\"WX20180107-134538@2x.png-37.5kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声明</span><br><span class=\"line\">typedef UIViewController *(^ViewControllerHandler)();</span><br><span class=\"line\"></span><br><span class=\"line\">//作参数</span><br><span class=\"line\">@interface DemoListViewController : UIViewController</span><br><span class=\"line\">+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//定义</span><br><span class=\"line\">@implementation DemoListViewController</span><br><span class=\"line\">+ (void)registerWithTitle:(NSString *)title handler:(ViewControllerHandler)handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UIViewController* vc = handler()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">//在别处调用</span><br><span class=\"line\">@implementation DemoDetailViewController</span><br><span class=\"line\">[DemoListViewController registerWithTitle:@&quot;基本使用&quot; handler:^UIViewController *&#123;</span><br><span class=\"line\">        return DemoDetailViewController();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>如上，我们把<code>ViewControllerHandler</code>的运行延迟到了实际调用的时刻，并且我们可以在这个handler的实现中带入很多信息；</p>\n<ol start=\"3\">\n<li>MGJ数据结构管理</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern NSString *const MGJRouterParameterURL;</span><br><span class=\"line\">extern NSString *const MGJRouterParameterCompletion;</span><br><span class=\"line\">extern NSString *const MGJRouterParameterUserInfo;</span><br><span class=\"line\">//*************************************************</span><br><span class=\"line\">static NSString * const MGJ_ROUTER_WILDCARD_CHARACTER = @&quot;~&quot;;  //这是一个占位符</span><br><span class=\"line\">static NSString *specialCharacters = @&quot;/?&amp;.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString *const MGJRouterParameterURL = @&quot;MGJRouterParameterURL&quot;;</span><br><span class=\"line\">NSString *const MGJRouterParameterCompletion = @&quot;MGJRouterParameterCompletion&quot;;</span><br><span class=\"line\">NSString *const MGJRouterParameterUserInfo = @&quot;MGJRouterParameterUserInfo&quot;;</span><br></pre></td></tr></table></figure>\n<p>从这里我们可以看出，MGJ的路由管理，实际上是一个解析url以及对应的管理，我们举几个URL来看一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@&quot;mgj://&quot;</span><br><span class=\"line\">@&quot;mgj://foo/bar/none/exists&quot;</span><br><span class=\"line\">@&quot;mgj://foo/bar&quot; </span><br><span class=\"line\">@&quot;mgj://category/家居&quot;</span><br><span class=\"line\">@&quot;mgj://category/travel&quot;</span><br><span class=\"line\">@&quot;mgj://search/:query&quot;</span><br><span class=\"line\">@&quot;mgj://detail&quot;</span><br><span class=\"line\">@&quot;mgj://search/:keyword&quot;</span><br><span class=\"line\">@&quot;mgj://search_top_bar&quot;</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的URL我们可以看出，路由的管理实际上就是url的解析过程，下面我们来具体看一下解析过程；</p>\n<ol start=\"4\">\n<li>URL解析</li>\n</ol>\n<ul>\n<li>route url</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/usiege/wr5j4jwfcaov7yfmx3u82nyk/WX20180107-150437@2x.png\" alt=\"WX20180107-150437@2x.png-59.1kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray*)pathComponentsFromURL:(NSString*)URL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *pathComponents = [NSMutableArray array];</span><br><span class=\"line\">    if ([URL rangeOfString:@&quot;://&quot;].location != NSNotFound) &#123;</span><br><span class=\"line\">        NSArray *pathSegments = [URL componentsSeparatedByString:@&quot;://&quot;];</span><br><span class=\"line\">        // 如果 URL 包含协议，那么把协议作为第一个元素放进去</span><br><span class=\"line\">        [pathComponents addObject:pathSegments[0]];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 如果只有协议，那么放一个占位符</span><br><span class=\"line\">        URL = pathSegments.lastObject;</span><br><span class=\"line\">        if (!URL.length) &#123;</span><br><span class=\"line\">            [pathComponents addObject:MGJ_ROUTER_WILDCARD_CHARACTER];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (NSString *pathComponent in [[NSURL URLWithString:URL] pathComponents]) &#123;</span><br><span class=\"line\">        if ([pathComponent isEqualToString:@&quot;/&quot;]) continue;</span><br><span class=\"line\">        if ([[pathComponent substringToIndex:1] isEqualToString:@&quot;?&quot;]) break;</span><br><span class=\"line\">        [pathComponents addObject:pathComponent];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [pathComponents copy];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>key-value<br><img src=\"http://static.zybuluo.com/usiege/j23e7t541u0wcoohza0ktqmb/WX20180107-151956@2x.png\" alt=\"WX20180107-151956@2x.png-111.8kB\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSMutableDictionary *)addURLPattern:(NSString *)URLPattern</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSArray *pathComponents = [self pathComponentsFromURL:URLPattern];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSMutableDictionary* subRoutes = self.routes;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (NSString* pathComponent in pathComponents) &#123;</span><br><span class=\"line\">        if (![subRoutes objectForKey:pathComponent]) &#123;</span><br><span class=\"line\">            subRoutes[pathComponent] = [[NSMutableDictionary alloc] init];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        subRoutes = subRoutes[pathComponent];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return subRoutes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>核心url解析</p>\n</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/usiege/cbn7v2xkwlfy3c19m322o7mg/WX20180107-160319@2x.png\" alt=\"WX20180107-160319@2x.png-147.8kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSMutableDictionary *)extractParametersFromURL:(NSString *)url</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableDictionary* parameters = [NSMutableDictionary dictionary];</span><br><span class=\"line\">    </span><br><span class=\"line\">    parameters[MGJRouterParameterURL] = url;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableDictionary* subRoutes = self.routes;</span><br><span class=\"line\">    NSArray* pathComponents = [self pathComponentsFromURL:url];</span><br><span class=\"line\">    </span><br><span class=\"line\">    BOOL found = NO;</span><br><span class=\"line\">    // borrowed from HHRouter(https://github.com/Huohua/HHRouter)</span><br><span class=\"line\">    for (NSString* pathComponent in pathComponents) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 对 key 进行排序，这样可以把 ~ 放到最后</span><br><span class=\"line\">        NSArray *subRoutesKeys =[subRoutes.allKeys sortedArrayUsingComparator:^NSComparisonResult(NSString *obj1, NSString *obj2) &#123;</span><br><span class=\"line\">            return [obj1 compare:obj2];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (NSString* key in subRoutesKeys) &#123;</span><br><span class=\"line\">            if ([key isEqualToString:pathComponent] || [key isEqualToString:MGJ_ROUTER_WILDCARD_CHARACTER]) &#123;</span><br><span class=\"line\">                found = YES;</span><br><span class=\"line\">                subRoutes = subRoutes[key];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125; else if ([key hasPrefix:@&quot;:&quot;]) &#123;</span><br><span class=\"line\">                found = YES;</span><br><span class=\"line\">                subRoutes = subRoutes[key];</span><br><span class=\"line\">                NSString *newKey = [key substringFromIndex:1];</span><br><span class=\"line\">                NSString *newPathComponent = pathComponent;</span><br><span class=\"line\">                // 再做一下特殊处理，比如 :id.html -&gt; :id</span><br><span class=\"line\">                if ([self.class checkIfContainsSpecialCharacter:key]) &#123;</span><br><span class=\"line\">                    NSCharacterSet *specialCharacterSet = [NSCharacterSet characterSetWithCharactersInString:specialCharacters];</span><br><span class=\"line\">                    NSRange range = [key rangeOfCharacterFromSet:specialCharacterSet];</span><br><span class=\"line\">                    if (range.location != NSNotFound) &#123;</span><br><span class=\"line\">                        // 把 pathComponent 后面的部分也去掉</span><br><span class=\"line\">                        newKey = [newKey substringToIndex:range.location - 1];</span><br><span class=\"line\">                        NSString *suffixToStrip = [key substringFromIndex:range.location];</span><br><span class=\"line\">                        newPathComponent = [newPathComponent stringByReplacingOccurrencesOfString:suffixToStrip withString:@&quot;&quot;];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                parameters[newKey] = newPathComponent;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 如果没有找到该 pathComponent 对应的 handler，则以上一层的 handler 作为 fallback</span><br><span class=\"line\">        if (!found &amp;&amp; !subRoutes[@&quot;_&quot;]) &#123;</span><br><span class=\"line\">            return nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Extract Params From Query.</span><br><span class=\"line\">    NSArray&lt;NSURLQueryItem *&gt; *queryItems = [[NSURLComponents alloc] initWithURL:[[NSURL alloc] initWithString:url] resolvingAgainstBaseURL:false].queryItems;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (NSURLQueryItem *item in queryItems) &#123;</span><br><span class=\"line\">        parameters[item.name] = item.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (subRoutes[@&quot;_&quot;]) &#123;</span><br><span class=\"line\">        parameters[@&quot;block&quot;] = [subRoutes[@&quot;_&quot;] copy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return parameters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)openURL:(NSString *)URL withUserInfo:(NSDictionary *)userInfo completion:(void (^)(id result))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    URL = [URL stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\">    NSMutableDictionary *parameters = [[self sharedInstance] extractParametersFromURL:URL];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) &#123;</span><br><span class=\"line\">        if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class=\"line\">            parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (parameters) &#123;</span><br><span class=\"line\">        MGJRouterHandler handler = parameters[@&quot;block&quot;];</span><br><span class=\"line\">        if (completion) &#123;</span><br><span class=\"line\">            parameters[MGJRouterParameterCompletion] = completion;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (userInfo) &#123;</span><br><span class=\"line\">            parameters[MGJRouterParameterUserInfo] = userInfo;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //所以注册路由时的回调是在这里才调用到的</span><br><span class=\"line\">        //也就是openURL响应了register的回调</span><br><span class=\"line\">        if (handler) &#123;</span><br><span class=\"line\">            [parameters removeObjectForKey:@&quot;block&quot;];</span><br><span class=\"line\">            handler(parameters);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>后续？</li>\n</ol>"},{"title":"OpenGL-初识","date":"2016-06-15T02:00:00.000Z","_content":"\n看了OpenGLES已经有一段时间了，大致对这个3D库有了一些了解，之后就开始对这套API进行一下深入的研究学习。\n<!-- more -->\n\n学习主要是通过《计算机图形学》一书开展的，网上有什么红宝书蓝皮书什么的回头再看吧，学习要专注，你懂得。\n\n首先要先了解一下GL和GLUT的概念，自己详细Google下，总之你得先了解你所要用的库以及库的功能，在这里简单提一下，GL是3D库的主要API框架，而GLUT则是一些工具，我们在x86_64或i386架构下使用Xcode所对应的头文件是：\n\n## GLUT\n\n```\n#include <OpenGL/gl.h>\n#include <GLUT/GLUT.h>\n```\nGLUT在这里会提供一些创建桌面窗口之类的工具，用于显示opengl画出图的效果；话不多说，直接上例子。\n\n```\n#include <iostream>\n#include <GLUT/GLUT.h>\n\nint main(int argc, char * argv[]) {\n    // insert code here...\n    std::cout << \"Hello, World!\\n\";\n    \n    glutInit(&argc, argv);\n    glutInitWindowPosition(100, 100); //初始位置\n    glutInitWindowSize(600, 450);//大小\n    glutCreateWindow(\"显示图元\");\n    \n    gluOrtho2D(0, 200, 0, 150);\n    \n    //只调用最后一次的\n    glutDisplayFunc(drawLine);\n    glutDisplayFunc(drawPolyline);\n    glutMainLoop();\n    \n    return 0;\n}\n\n```\n\n先不着急，一点一点解释：\n\n\n`glutInit`\n\nglut初始化，在这里提一下第二个参数，因为之前用xcode创建例子的时候，函数主入口是这样的：\n```\nint main(int argc, const char * argv[])\n```\n然而进行传参时，`glutInit(&argc,argv)`提示没有匹配的函数，经查证后得知是参数传错了，理由是：指向const的指针不能被赋给指向非const的指针；解决办法倒不是没有，应该用strcpy，也就是另开一块内存，把字符一个个复制过去，但是这样太麻烦了，索性直接改掉main()的参数好了；\n\n\n`glutInitWindowPosition`\n\n设置窗口的初始位置，以桌面左上角为零点；\n\n`glutInitWindowSize`\n\n设置窗口的大小；\n\n`glutCreateWindow`\n\n创建窗口，给定一个窗口标题；\n\n`gluOrtho2D`\n\n接下来的这个函数是在<OpenGL/glu.h>中的，这个函数给定了一个坐标系，该坐标系将与上面设置的坐标系对齐，具体对齐规则书中暂时还没有说到，后面会详细讲，这里先大致清楚它是在做一件什么事情就好了,gl画图的函数坐标将以该坐标系为基准进行画图；\n\n`glutDisplayFunc`\n\n接下来要进行画图了，这个函数接收一个函数指针，类型为`void (*func)(void)`;很明显是传入的将是一系列的画图动作，这个形式有点类似于OC的SEL，显然是GPU内部的回调；还有一点是我试图重复调用该函数，结果会发现它并不是会对两个函数分别调用，实验显示只对最后一次的调用起作用。\n\n`glutMainLoop()`\n\n这是一个运行循环，貌似所有交互系统都是需要有一个死循环的，否则无法进行交互处理。说到“交互”，这真是一个神奇的词语。\n\n然后就进入我们今天的重点，画图，先上代码；\n\n## GL\n\n画一条线：\n\n```\nvoid drawLine(void){\n    printf(\"画一条线\\n\");\n    \n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    glMatrixMode(GL_PROJECTION);\n    \n    glColor3f(0, 1, 0);\n    \n    int point1[] = {0,0};\n    int point2[] = {200,150};\n    int point3[] = {0,200};\n    \n    glBegin(GL_LINES);\n    glVertex2iv(point1);\n    glVertex2iv(point2);\n    glVertex2iv(point3);\n    glEnd();\n    /**\n     *  如果列出的端点数为奇数，则最后一个端点被忽略；\n     */\n    glFlush();\n}\n\n```\n\n`glClearColor`\n\n使用该函数设置图形背景颜色，四个参数分别是我们熟悉的RGBA；然而该函数只是将颜色值保存在了颜色缓存中，必须要通过调用`glClear`才能将颜色值取出来；\n\n`glColor3f`\n\n使用该函数设置的颜色对要进行画的像素着色；如果是一条线，它将是线的颜色；\n\n```\nglBegin(GL_LINES);\n\t\nglEnd();\n```\n\n画图需要被包含在以上两个函数之间，`glBegin`的参数将决定画的是什么图形，各图形画图时有各自的规则，之后慢慢讲解；画点函数`glVertex*`，在Vertex后的2,3,4数字表示维数（在几维的空间坐标系中）；之后接的是类型，表示浮点还是整形等；最后如果加v的话，表示传入的将是一个用数组表示的点，本例中就是这样表示的；\n\n`glFlush`\n\n最后这个函数非常重要，没有它，之前所做的一切都白费了；原文解释，该函数强制由计算机系统存放在不同位置的缓存中的OpenGL函数执行，其位置依赖于OpenGL的实现，暂时还不是能太搞懂，之后可能会详细介绍，本章只是做了一个引入。\n\n另外如果要画一个点则可以这样做：\n\n```\nglBegin(GL_POINTS);\nglVertex2i(x, y);\nglEnd();\n```\n\n这样可以通过循环，画一些不规则的图形，如果你自己设计算法，也许圆也可以画的出来；另外如果要从一个像素点上取得颜色，则需要使用`getPixel`。\n\n\n画一条折线：\n\n```\nvoid drawPolyline(void){\n    printf(\"画折线\");\n    \n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    glColor3f(0, 0, 1);\n    int point[5][2] = {{0,0},{100,20},{30,100},{150,10},{150,150}};\n    \n    glBegin(GL_LINE_STRIP);//strip条状，剥去\n    for (int i=0; i<5; i++) {\n        glVertex2iv(point[i]);\n    }\n    glEnd();\n    /**\n     *  使用图元常量GL_LINE_STRIP可获得折线；\n     *  如果不列出至少两个点，则什么也不显示；\n     *\n     */\n    \n    glColor3f(1, 0, 0);\n    int pointLoop[5][2] = {{100,100},{20,20},{50,50},{150,10},{70,10}};\n    \n    glBegin(GL_LINE_LOOP);\n    for (int i=0; i<5; i++) {\n        glVertex2iv(pointLoop[i]);\n    }\n    glEnd();\n    /**\n     *  使用图元常量GL_LINE_LOOP可获得闭合折线；\n     *  如果不列出至少两个点，则什么也不显示；\n     *  最后一个端点与第一个端点相连接；\n     *\n     */\n\n    \n    glFlush();\n}\n```\n\n上面的例子会教你如何画一条折线或者闭合折线，注意看里面的注释。\n\n本篇就讲到这里，持续学习并更新中...\n","source":"_posts/OpenGL-初识.md","raw":"title: OpenGL-初识\ndate: 2016-06-15 10:00:00\ncategories: coder\ntags: [opengl, glut]\n-----------\n\n看了OpenGLES已经有一段时间了，大致对这个3D库有了一些了解，之后就开始对这套API进行一下深入的研究学习。\n<!-- more -->\n\n学习主要是通过《计算机图形学》一书开展的，网上有什么红宝书蓝皮书什么的回头再看吧，学习要专注，你懂得。\n\n首先要先了解一下GL和GLUT的概念，自己详细Google下，总之你得先了解你所要用的库以及库的功能，在这里简单提一下，GL是3D库的主要API框架，而GLUT则是一些工具，我们在x86_64或i386架构下使用Xcode所对应的头文件是：\n\n## GLUT\n\n```\n#include <OpenGL/gl.h>\n#include <GLUT/GLUT.h>\n```\nGLUT在这里会提供一些创建桌面窗口之类的工具，用于显示opengl画出图的效果；话不多说，直接上例子。\n\n```\n#include <iostream>\n#include <GLUT/GLUT.h>\n\nint main(int argc, char * argv[]) {\n    // insert code here...\n    std::cout << \"Hello, World!\\n\";\n    \n    glutInit(&argc, argv);\n    glutInitWindowPosition(100, 100); //初始位置\n    glutInitWindowSize(600, 450);//大小\n    glutCreateWindow(\"显示图元\");\n    \n    gluOrtho2D(0, 200, 0, 150);\n    \n    //只调用最后一次的\n    glutDisplayFunc(drawLine);\n    glutDisplayFunc(drawPolyline);\n    glutMainLoop();\n    \n    return 0;\n}\n\n```\n\n先不着急，一点一点解释：\n\n\n`glutInit`\n\nglut初始化，在这里提一下第二个参数，因为之前用xcode创建例子的时候，函数主入口是这样的：\n```\nint main(int argc, const char * argv[])\n```\n然而进行传参时，`glutInit(&argc,argv)`提示没有匹配的函数，经查证后得知是参数传错了，理由是：指向const的指针不能被赋给指向非const的指针；解决办法倒不是没有，应该用strcpy，也就是另开一块内存，把字符一个个复制过去，但是这样太麻烦了，索性直接改掉main()的参数好了；\n\n\n`glutInitWindowPosition`\n\n设置窗口的初始位置，以桌面左上角为零点；\n\n`glutInitWindowSize`\n\n设置窗口的大小；\n\n`glutCreateWindow`\n\n创建窗口，给定一个窗口标题；\n\n`gluOrtho2D`\n\n接下来的这个函数是在<OpenGL/glu.h>中的，这个函数给定了一个坐标系，该坐标系将与上面设置的坐标系对齐，具体对齐规则书中暂时还没有说到，后面会详细讲，这里先大致清楚它是在做一件什么事情就好了,gl画图的函数坐标将以该坐标系为基准进行画图；\n\n`glutDisplayFunc`\n\n接下来要进行画图了，这个函数接收一个函数指针，类型为`void (*func)(void)`;很明显是传入的将是一系列的画图动作，这个形式有点类似于OC的SEL，显然是GPU内部的回调；还有一点是我试图重复调用该函数，结果会发现它并不是会对两个函数分别调用，实验显示只对最后一次的调用起作用。\n\n`glutMainLoop()`\n\n这是一个运行循环，貌似所有交互系统都是需要有一个死循环的，否则无法进行交互处理。说到“交互”，这真是一个神奇的词语。\n\n然后就进入我们今天的重点，画图，先上代码；\n\n## GL\n\n画一条线：\n\n```\nvoid drawLine(void){\n    printf(\"画一条线\\n\");\n    \n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    glMatrixMode(GL_PROJECTION);\n    \n    glColor3f(0, 1, 0);\n    \n    int point1[] = {0,0};\n    int point2[] = {200,150};\n    int point3[] = {0,200};\n    \n    glBegin(GL_LINES);\n    glVertex2iv(point1);\n    glVertex2iv(point2);\n    glVertex2iv(point3);\n    glEnd();\n    /**\n     *  如果列出的端点数为奇数，则最后一个端点被忽略；\n     */\n    glFlush();\n}\n\n```\n\n`glClearColor`\n\n使用该函数设置图形背景颜色，四个参数分别是我们熟悉的RGBA；然而该函数只是将颜色值保存在了颜色缓存中，必须要通过调用`glClear`才能将颜色值取出来；\n\n`glColor3f`\n\n使用该函数设置的颜色对要进行画的像素着色；如果是一条线，它将是线的颜色；\n\n```\nglBegin(GL_LINES);\n\t\nglEnd();\n```\n\n画图需要被包含在以上两个函数之间，`glBegin`的参数将决定画的是什么图形，各图形画图时有各自的规则，之后慢慢讲解；画点函数`glVertex*`，在Vertex后的2,3,4数字表示维数（在几维的空间坐标系中）；之后接的是类型，表示浮点还是整形等；最后如果加v的话，表示传入的将是一个用数组表示的点，本例中就是这样表示的；\n\n`glFlush`\n\n最后这个函数非常重要，没有它，之前所做的一切都白费了；原文解释，该函数强制由计算机系统存放在不同位置的缓存中的OpenGL函数执行，其位置依赖于OpenGL的实现，暂时还不是能太搞懂，之后可能会详细介绍，本章只是做了一个引入。\n\n另外如果要画一个点则可以这样做：\n\n```\nglBegin(GL_POINTS);\nglVertex2i(x, y);\nglEnd();\n```\n\n这样可以通过循环，画一些不规则的图形，如果你自己设计算法，也许圆也可以画的出来；另外如果要从一个像素点上取得颜色，则需要使用`getPixel`。\n\n\n画一条折线：\n\n```\nvoid drawPolyline(void){\n    printf(\"画折线\");\n    \n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    glColor3f(0, 0, 1);\n    int point[5][2] = {{0,0},{100,20},{30,100},{150,10},{150,150}};\n    \n    glBegin(GL_LINE_STRIP);//strip条状，剥去\n    for (int i=0; i<5; i++) {\n        glVertex2iv(point[i]);\n    }\n    glEnd();\n    /**\n     *  使用图元常量GL_LINE_STRIP可获得折线；\n     *  如果不列出至少两个点，则什么也不显示；\n     *\n     */\n    \n    glColor3f(1, 0, 0);\n    int pointLoop[5][2] = {{100,100},{20,20},{50,50},{150,10},{70,10}};\n    \n    glBegin(GL_LINE_LOOP);\n    for (int i=0; i<5; i++) {\n        glVertex2iv(pointLoop[i]);\n    }\n    glEnd();\n    /**\n     *  使用图元常量GL_LINE_LOOP可获得闭合折线；\n     *  如果不列出至少两个点，则什么也不显示；\n     *  最后一个端点与第一个端点相连接；\n     *\n     */\n\n    \n    glFlush();\n}\n```\n\n上面的例子会教你如何画一条折线或者闭合折线，注意看里面的注释。\n\n本篇就讲到这里，持续学习并更新中...\n","slug":"OpenGL-初识","published":1,"updated":"2018-05-04T10:53:00.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucinz000h1v60l8caqn0x","content":"<p>看了OpenGLES已经有一段时间了，大致对这个3D库有了一些了解，之后就开始对这套API进行一下深入的研究学习。<br><a id=\"more\"></a></p>\n<p>学习主要是通过《计算机图形学》一书开展的，网上有什么红宝书蓝皮书什么的回头再看吧，学习要专注，你懂得。</p>\n<p>首先要先了解一下GL和GLUT的概念，自己详细Google下，总之你得先了解你所要用的库以及库的功能，在这里简单提一下，GL是3D库的主要API框架，而GLUT则是一些工具，我们在x86_64或i386架构下使用Xcode所对应的头文件是：</p>\n<h2 id=\"GLUT\"><a href=\"#GLUT\" class=\"headerlink\" title=\"GLUT\"></a>GLUT</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;OpenGL/gl.h&gt;</span><br><span class=\"line\">#include &lt;GLUT/GLUT.h&gt;</span><br></pre></td></tr></table></figure>\n<p>GLUT在这里会提供一些创建桌面窗口之类的工具，用于显示opengl画出图的效果；话不多说，直接上例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;GLUT/GLUT.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    // insert code here...</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;Hello, World!\\n&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glutInit(&amp;argc, argv);</span><br><span class=\"line\">    glutInitWindowPosition(100, 100); //初始位置</span><br><span class=\"line\">    glutInitWindowSize(600, 450);//大小</span><br><span class=\"line\">    glutCreateWindow(&quot;显示图元&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    gluOrtho2D(0, 200, 0, 150);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //只调用最后一次的</span><br><span class=\"line\">    glutDisplayFunc(drawLine);</span><br><span class=\"line\">    glutDisplayFunc(drawPolyline);</span><br><span class=\"line\">    glutMainLoop();</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先不着急，一点一点解释：</p>\n<p><code>glutInit</code></p>\n<p>glut初始化，在这里提一下第二个参数，因为之前用xcode创建例子的时候，函数主入口是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, const char * argv[])</span><br></pre></td></tr></table></figure></p>\n<p>然而进行传参时，<code>glutInit(&amp;argc,argv)</code>提示没有匹配的函数，经查证后得知是参数传错了，理由是：指向const的指针不能被赋给指向非const的指针；解决办法倒不是没有，应该用strcpy，也就是另开一块内存，把字符一个个复制过去，但是这样太麻烦了，索性直接改掉main()的参数好了；</p>\n<p><code>glutInitWindowPosition</code></p>\n<p>设置窗口的初始位置，以桌面左上角为零点；</p>\n<p><code>glutInitWindowSize</code></p>\n<p>设置窗口的大小；</p>\n<p><code>glutCreateWindow</code></p>\n<p>创建窗口，给定一个窗口标题；</p>\n<p><code>gluOrtho2D</code></p>\n<p>接下来的这个函数是在&lt;OpenGL/glu.h&gt;中的，这个函数给定了一个坐标系，该坐标系将与上面设置的坐标系对齐，具体对齐规则书中暂时还没有说到，后面会详细讲，这里先大致清楚它是在做一件什么事情就好了,gl画图的函数坐标将以该坐标系为基准进行画图；</p>\n<p><code>glutDisplayFunc</code></p>\n<p>接下来要进行画图了，这个函数接收一个函数指针，类型为<code>void (*func)(void)</code>;很明显是传入的将是一系列的画图动作，这个形式有点类似于OC的SEL，显然是GPU内部的回调；还有一点是我试图重复调用该函数，结果会发现它并不是会对两个函数分别调用，实验显示只对最后一次的调用起作用。</p>\n<p><code>glutMainLoop()</code></p>\n<p>这是一个运行循环，貌似所有交互系统都是需要有一个死循环的，否则无法进行交互处理。说到“交互”，这真是一个神奇的词语。</p>\n<p>然后就进入我们今天的重点，画图，先上代码；</p>\n<h2 id=\"GL\"><a href=\"#GL\" class=\"headerlink\" title=\"GL\"></a>GL</h2><p>画一条线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void drawLine(void)&#123;</span><br><span class=\"line\">    printf(&quot;画一条线\\n&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClearColor(0, 0, 0, 1);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    glMatrixMode(GL_PROJECTION);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glColor3f(0, 1, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    int point1[] = &#123;0,0&#125;;</span><br><span class=\"line\">    int point2[] = &#123;200,150&#125;;</span><br><span class=\"line\">    int point3[] = &#123;0,200&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBegin(GL_LINES);</span><br><span class=\"line\">    glVertex2iv(point1);</span><br><span class=\"line\">    glVertex2iv(point2);</span><br><span class=\"line\">    glVertex2iv(point3);</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  如果列出的端点数为奇数，则最后一个端点被忽略；</span><br><span class=\"line\">     */</span><br><span class=\"line\">    glFlush();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glClearColor</code></p>\n<p>使用该函数设置图形背景颜色，四个参数分别是我们熟悉的RGBA；然而该函数只是将颜色值保存在了颜色缓存中，必须要通过调用<code>glClear</code>才能将颜色值取出来；</p>\n<p><code>glColor3f</code></p>\n<p>使用该函数设置的颜色对要进行画的像素着色；如果是一条线，它将是线的颜色；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBegin(GL_LINES);</span><br><span class=\"line\">\t</span><br><span class=\"line\">glEnd();</span><br></pre></td></tr></table></figure>\n<p>画图需要被包含在以上两个函数之间，<code>glBegin</code>的参数将决定画的是什么图形，各图形画图时有各自的规则，之后慢慢讲解；画点函数<code>glVertex*</code>，在Vertex后的2,3,4数字表示维数（在几维的空间坐标系中）；之后接的是类型，表示浮点还是整形等；最后如果加v的话，表示传入的将是一个用数组表示的点，本例中就是这样表示的；</p>\n<p><code>glFlush</code></p>\n<p>最后这个函数非常重要，没有它，之前所做的一切都白费了；原文解释，该函数强制由计算机系统存放在不同位置的缓存中的OpenGL函数执行，其位置依赖于OpenGL的实现，暂时还不是能太搞懂，之后可能会详细介绍，本章只是做了一个引入。</p>\n<p>另外如果要画一个点则可以这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBegin(GL_POINTS);</span><br><span class=\"line\">glVertex2i(x, y);</span><br><span class=\"line\">glEnd();</span><br></pre></td></tr></table></figure>\n<p>这样可以通过循环，画一些不规则的图形，如果你自己设计算法，也许圆也可以画的出来；另外如果要从一个像素点上取得颜色，则需要使用<code>getPixel</code>。</p>\n<p>画一条折线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void drawPolyline(void)&#123;</span><br><span class=\"line\">    printf(&quot;画折线&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClearColor(0, 0, 0, 1);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glColor3f(0, 0, 1);</span><br><span class=\"line\">    int point[5][2] = &#123;&#123;0,0&#125;,&#123;100,20&#125;,&#123;30,100&#125;,&#123;150,10&#125;,&#123;150,150&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBegin(GL_LINE_STRIP);//strip条状，剥去</span><br><span class=\"line\">    for (int i=0; i&lt;5; i++) &#123;</span><br><span class=\"line\">        glVertex2iv(point[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  使用图元常量GL_LINE_STRIP可获得折线；</span><br><span class=\"line\">     *  如果不列出至少两个点，则什么也不显示；</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\">    </span><br><span class=\"line\">    glColor3f(1, 0, 0);</span><br><span class=\"line\">    int pointLoop[5][2] = &#123;&#123;100,100&#125;,&#123;20,20&#125;,&#123;50,50&#125;,&#123;150,10&#125;,&#123;70,10&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBegin(GL_LINE_LOOP);</span><br><span class=\"line\">    for (int i=0; i&lt;5; i++) &#123;</span><br><span class=\"line\">        glVertex2iv(pointLoop[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  使用图元常量GL_LINE_LOOP可获得闭合折线；</span><br><span class=\"line\">     *  如果不列出至少两个点，则什么也不显示；</span><br><span class=\"line\">     *  最后一个端点与第一个端点相连接；</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    glFlush();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会教你如何画一条折线或者闭合折线，注意看里面的注释。</p>\n<p>本篇就讲到这里，持续学习并更新中…</p>\n","site":{"data":{}},"excerpt":"<p>看了OpenGLES已经有一段时间了，大致对这个3D库有了一些了解，之后就开始对这套API进行一下深入的研究学习。<br>","more":"</p>\n<p>学习主要是通过《计算机图形学》一书开展的，网上有什么红宝书蓝皮书什么的回头再看吧，学习要专注，你懂得。</p>\n<p>首先要先了解一下GL和GLUT的概念，自己详细Google下，总之你得先了解你所要用的库以及库的功能，在这里简单提一下，GL是3D库的主要API框架，而GLUT则是一些工具，我们在x86_64或i386架构下使用Xcode所对应的头文件是：</p>\n<h2 id=\"GLUT\"><a href=\"#GLUT\" class=\"headerlink\" title=\"GLUT\"></a>GLUT</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;OpenGL/gl.h&gt;</span><br><span class=\"line\">#include &lt;GLUT/GLUT.h&gt;</span><br></pre></td></tr></table></figure>\n<p>GLUT在这里会提供一些创建桌面窗口之类的工具，用于显示opengl画出图的效果；话不多说，直接上例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;GLUT/GLUT.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    // insert code here...</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;Hello, World!\\n&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glutInit(&amp;argc, argv);</span><br><span class=\"line\">    glutInitWindowPosition(100, 100); //初始位置</span><br><span class=\"line\">    glutInitWindowSize(600, 450);//大小</span><br><span class=\"line\">    glutCreateWindow(&quot;显示图元&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    gluOrtho2D(0, 200, 0, 150);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //只调用最后一次的</span><br><span class=\"line\">    glutDisplayFunc(drawLine);</span><br><span class=\"line\">    glutDisplayFunc(drawPolyline);</span><br><span class=\"line\">    glutMainLoop();</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先不着急，一点一点解释：</p>\n<p><code>glutInit</code></p>\n<p>glut初始化，在这里提一下第二个参数，因为之前用xcode创建例子的时候，函数主入口是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, const char * argv[])</span><br></pre></td></tr></table></figure></p>\n<p>然而进行传参时，<code>glutInit(&amp;argc,argv)</code>提示没有匹配的函数，经查证后得知是参数传错了，理由是：指向const的指针不能被赋给指向非const的指针；解决办法倒不是没有，应该用strcpy，也就是另开一块内存，把字符一个个复制过去，但是这样太麻烦了，索性直接改掉main()的参数好了；</p>\n<p><code>glutInitWindowPosition</code></p>\n<p>设置窗口的初始位置，以桌面左上角为零点；</p>\n<p><code>glutInitWindowSize</code></p>\n<p>设置窗口的大小；</p>\n<p><code>glutCreateWindow</code></p>\n<p>创建窗口，给定一个窗口标题；</p>\n<p><code>gluOrtho2D</code></p>\n<p>接下来的这个函数是在&lt;OpenGL/glu.h&gt;中的，这个函数给定了一个坐标系，该坐标系将与上面设置的坐标系对齐，具体对齐规则书中暂时还没有说到，后面会详细讲，这里先大致清楚它是在做一件什么事情就好了,gl画图的函数坐标将以该坐标系为基准进行画图；</p>\n<p><code>glutDisplayFunc</code></p>\n<p>接下来要进行画图了，这个函数接收一个函数指针，类型为<code>void (*func)(void)</code>;很明显是传入的将是一系列的画图动作，这个形式有点类似于OC的SEL，显然是GPU内部的回调；还有一点是我试图重复调用该函数，结果会发现它并不是会对两个函数分别调用，实验显示只对最后一次的调用起作用。</p>\n<p><code>glutMainLoop()</code></p>\n<p>这是一个运行循环，貌似所有交互系统都是需要有一个死循环的，否则无法进行交互处理。说到“交互”，这真是一个神奇的词语。</p>\n<p>然后就进入我们今天的重点，画图，先上代码；</p>\n<h2 id=\"GL\"><a href=\"#GL\" class=\"headerlink\" title=\"GL\"></a>GL</h2><p>画一条线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void drawLine(void)&#123;</span><br><span class=\"line\">    printf(&quot;画一条线\\n&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClearColor(0, 0, 0, 1);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    glMatrixMode(GL_PROJECTION);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glColor3f(0, 1, 0);</span><br><span class=\"line\">    </span><br><span class=\"line\">    int point1[] = &#123;0,0&#125;;</span><br><span class=\"line\">    int point2[] = &#123;200,150&#125;;</span><br><span class=\"line\">    int point3[] = &#123;0,200&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBegin(GL_LINES);</span><br><span class=\"line\">    glVertex2iv(point1);</span><br><span class=\"line\">    glVertex2iv(point2);</span><br><span class=\"line\">    glVertex2iv(point3);</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  如果列出的端点数为奇数，则最后一个端点被忽略；</span><br><span class=\"line\">     */</span><br><span class=\"line\">    glFlush();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glClearColor</code></p>\n<p>使用该函数设置图形背景颜色，四个参数分别是我们熟悉的RGBA；然而该函数只是将颜色值保存在了颜色缓存中，必须要通过调用<code>glClear</code>才能将颜色值取出来；</p>\n<p><code>glColor3f</code></p>\n<p>使用该函数设置的颜色对要进行画的像素着色；如果是一条线，它将是线的颜色；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBegin(GL_LINES);</span><br><span class=\"line\">\t</span><br><span class=\"line\">glEnd();</span><br></pre></td></tr></table></figure>\n<p>画图需要被包含在以上两个函数之间，<code>glBegin</code>的参数将决定画的是什么图形，各图形画图时有各自的规则，之后慢慢讲解；画点函数<code>glVertex*</code>，在Vertex后的2,3,4数字表示维数（在几维的空间坐标系中）；之后接的是类型，表示浮点还是整形等；最后如果加v的话，表示传入的将是一个用数组表示的点，本例中就是这样表示的；</p>\n<p><code>glFlush</code></p>\n<p>最后这个函数非常重要，没有它，之前所做的一切都白费了；原文解释，该函数强制由计算机系统存放在不同位置的缓存中的OpenGL函数执行，其位置依赖于OpenGL的实现，暂时还不是能太搞懂，之后可能会详细介绍，本章只是做了一个引入。</p>\n<p>另外如果要画一个点则可以这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBegin(GL_POINTS);</span><br><span class=\"line\">glVertex2i(x, y);</span><br><span class=\"line\">glEnd();</span><br></pre></td></tr></table></figure>\n<p>这样可以通过循环，画一些不规则的图形，如果你自己设计算法，也许圆也可以画的出来；另外如果要从一个像素点上取得颜色，则需要使用<code>getPixel</code>。</p>\n<p>画一条折线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void drawPolyline(void)&#123;</span><br><span class=\"line\">    printf(&quot;画折线&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glClearColor(0, 0, 0, 1);</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glColor3f(0, 0, 1);</span><br><span class=\"line\">    int point[5][2] = &#123;&#123;0,0&#125;,&#123;100,20&#125;,&#123;30,100&#125;,&#123;150,10&#125;,&#123;150,150&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBegin(GL_LINE_STRIP);//strip条状，剥去</span><br><span class=\"line\">    for (int i=0; i&lt;5; i++) &#123;</span><br><span class=\"line\">        glVertex2iv(point[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  使用图元常量GL_LINE_STRIP可获得折线；</span><br><span class=\"line\">     *  如果不列出至少两个点，则什么也不显示；</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\">    </span><br><span class=\"line\">    glColor3f(1, 0, 0);</span><br><span class=\"line\">    int pointLoop[5][2] = &#123;&#123;100,100&#125;,&#123;20,20&#125;,&#123;50,50&#125;,&#123;150,10&#125;,&#123;70,10&#125;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBegin(GL_LINE_LOOP);</span><br><span class=\"line\">    for (int i=0; i&lt;5; i++) &#123;</span><br><span class=\"line\">        glVertex2iv(pointLoop[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glEnd();</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  使用图元常量GL_LINE_LOOP可获得闭合折线；</span><br><span class=\"line\">     *  如果不列出至少两个点，则什么也不显示；</span><br><span class=\"line\">     *  最后一个端点与第一个端点相连接；</span><br><span class=\"line\">     *</span><br><span class=\"line\">     */</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    glFlush();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会教你如何画一条折线或者闭合折线，注意看里面的注释。</p>\n<p>本篇就讲到这里，持续学习并更新中…</p>"},{"title":"OpenGL-由实例理解概念","date":"2016-07-10T14:00:00.000Z","_content":"\nSummary:本篇讲一下关于OpenGL图形管线的一些基础知识，刚开始的内容会比较枯燥，后面会用几个例子讲解几种渲染方法，下载git上的例子可以在xcode上看到几种渲染的效果。可展示的效果有，正面和背面剔除、深度测试、多边形偏移、裁剪、混合、多重采样。\n<!-- more -->\n\n\ngit地址：[点击这里](https://github.com/usiege/OpenGL_S/tree/master/OpenGL_03_基础渲染/OGL_03_BaseRender)（这里做一下说明，在研究例子的过程中，请无视掉GLTools库，该库是原书作者对gl的一次封装，内部实现接下来会逐层展开，我们现在只讨论与gl有关的内容，后期的话我们可以自己实现封装。）\n\n## 将点连接起来\n\n上篇讲了运用gl画线函数画出直线与折线，本篇作一些补充。\n\n- 点的大小\n\n`void glPointSize(GLfloat size);`\n\n该函数可以指定绘制点的像素，不过并不是所有点的大小都能够支持，使用前请确认指定的点大小是可用的；利用下面这段代码可以获得点大小的范围，以及最小间隔：\n\n```\nGLfloat sizes[2];\t//存储支持的点的大小范围\nGLfloat step;\t\t\t//存储支持点的大小增量\n\n//获取支持的点的大小范围和增量\nglGetFloatv(GL_POINT_SIZE_RANGE,sizes);\nglGetFloatv(GL_POINT_SIZE_GRANULARITY,&step);\n```\n点总是正方形的像素，改变点大小情况也如此；\n\n另外还可以通过使用程序点大小模式来设置点大小，这样的话需要在顶点着色器或几何着色器代码中设置点的大小，这两种编程方法将在后面讲到；\n\n```\nglEnable(GL_PROGRAM_POINT_SIZE);\n//该模式允许通过着色器程序修改点大小\ngl_PointSize = 5.0;\n//在着色器程序中，修改该内建变量的值\n```\n\n- 线的宽度\n\n`void glLineWidth(GLfloat width);`\n\n该函数可以指定线段的宽度，它是改变线段宽度的唯一方式；\n\n- 线带\n\n连续的从一个顶点绘制线段，以形成一个连接起来的线带，使用`GL_LINE_STRIP`可绘制一组连接起来的线段；\n\n- 线环\n\n如果想要使上面的线带是闭合的，那么使用`GL_LINE_LOOP`会是不错的选择；\n\n- 三角形环绕\n\n>指定三角形时，点绘制的顺序与方向是不同的，使用这种结合来指定的方式叫做环绕。\n\n默认情况下，OpenGL认为具有逆时针方向环绕的多边形是正面的，如想修改默认的行为：\n\n`glFrontFace(GL_CW);`\n\n`GL_CW`参数告诉OpenGL顺时针环绕多边形将被认为是正面的；如需恢复逆时针，可以使用参数`GL_CCW`;\n\n- 三角形带\n\n当我们需要一串相连的三角形时，可以使用`GL_TRIANGLE_STRIP`图元绘制相连的三角形，这样可以节省大量时间；\n\n- 三角形扇\n\n使用`GL_TRIANGLE_FAN`可以创建一组围绕一个中心点的相连三角形；\n\n本文地址工程目录Primitives展示了以上几种图形的画法；\n\n## 基础渲染方式\n\n### - 油画法\n\n绘制三角形时，如果出现覆盖的情况，通常的做法是对三角形进行排序，然后首先画那些较远的三角形，再在上方渲染那些较近的三角形，这种方式称做“油画法”；这种方法在图形处理中是非常低效的；\n\n### - 正面和背面剔除\n\n前面讲到三角形有正面与背面的区分，对其进行区分的原因之一就是为了进行剔除；选择不必要的面进行剔除会极大地提高性能；剔除按如下方式开启：\n\n```\n\nglEnable(GL_CULL_FACE);\t\t//开启\nglDisable(GL_CULL_FACE);\t//关闭\n\n```\n\n我们并没有指明剔除的面，如下：\n\n```\n\nvoid glCullFace(GLenum mode);\n\nGL_FRONT\t//剔除正面\n\nGL_BACK\t//剔除背面\n\nGL_FRONT_AND_BACK //正反面全部剔除\n```\n\n### - 深度测试\n\n在绘制一个像素时，将一个值（z值）分配给它，表示它到观察者的距离；当另外一个像素在同样位置进行绘制时，新像素z将与原来的进行比较，我们只绘制z值更小的像素；\n\n启用深度测试：\n\n`glEnable(GL_DEPTH_TEST);`\n\n### - 多边形模式\n\n函数*glPolygonMode*允许将多边形渲染成实体、轮廓或只有点，而且可以选择在多边形的正反面上启用该模式；\n\n```\n\nvoid glPolygonMode(GLenum face, GLenum mode);\n\n//face\n\nGL_FRONT\n\nGL_BACK\n\nGL_FRONT_AND_BACK\n\n//mode\n\nGL_FILL\t\t//默认值，实心\n\nGL_LINE\t\t//轮廓\n\nGL_POINT\t\t//点\n```\n\n本文例子GeoTest会展示这些效果；\n\n### - 多边形偏移\n\n举个例子，我们可能想要绘制一架大型飞机，然后在飞机上一个较小的但却与飞机在同一物理空间的图形，这叫做“贴花”；这个小的图形的深度值将会与原来飞机的深度缓冲区中的值相同，这将导致深度测试不可预料的通过或者失败，这种情况叫做z冲突；\n\n另外一种情况，我们想要在绘制的实心几何图形上突出它的边；以上这些z冲突的情况下，通常我们解决的办法是当深度值相同时，适当的对深度进行偏移而并不改变实际3D空间中的物理位置：\n\n```\nvoid glPolygonOffset(GLfloat factor, GLfloat units);\n//函数通过 Depth offset = (DZ * factor) + (r * units) 公式计算新的深度值；\n//其中，DZ是深度值相对于多边形屏幕区域的变化量，r是使深度缓冲区值产生变化的最小值；\n\n```\n\n例子Primitives的`DrawWireFramedBatch`函数代码中展示了偏移的使用;\n\n```\n```\n\n### - 裁剪\n\n裁剪是将渲染限制在一个较小的矩形中，如要开启裁剪：\n\n`glEnalbe(GL_SCISSOR_TEST);`\n\n指定窗口：\n\n```\nvoid glScissor(GLint x, GLint y, GLsizei width, GLsizei height);\n//x,y指定裁剪框左下角，width height则指定宽度和高度\n```\n\n例子Scissor展示了该函数的用法:\n\n```\n\t// Clear blue window\n    glClearColor(0.0f, 0.0f, 1.0f, 0.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // Now set scissor to smaller red sub region\n    glClearColor(1.0f, 0.0f, 0.0f, 0.0f);\n    glScissor(100, 100, 600, 400);\n    glEnable(GL_SCISSOR_TEST);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // Finally, an even smaller green rectangle\n    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);\n    glScissor(200, 200, 400, 200);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // Turn scissor back off for next render\n    glDisable(GL_SCISSOR_TEST);\n    \n```\n\n### - 混合\n\n当深度值相同时，使用混合也可以使下层的颜色值不会被清除；开启混合使用：\n\n`glEnable(GL_BLEND);`\n\n> 目标颜色：已经存储在颜色缓冲区中的颜色值；\n\n\n> 源颜色：作为当前渲染命令的结果进入颜色缓冲区的颜色；\n\n混合功能开启后，目标颜色和源颜色的组合方式是由混合方程式控制的；\n\n>> Cf = (Cs * S) + (Cd * D)\n\n>Cf是最终计算产生的颜色，Cs是源颜色，Cd是目标颜色，S、D分别是源和目标混合因子；\n\n>注意Cs和Cd都是向量，以上进行的是向量乘法和加法；\n\n混合因子是用函数进行设置的：\n\n```\nglBlendFunc(GLenum S, GLenum D);\n//S D都是枚举值，详细请自行google，这里给出枚举值\n```\n\n混合方程式并不是唯一的，如需改变则：\n\n```\nvoid glBlendEquation(GLenum mode);\n\nGL_FUNC_ADD\t\t\t\t\t\t//Cf = (Cs * S) + (Cd * D)\n\nGL_FUNC_SUBTRACT\t\t\t\t\t//Cf = (Cs * S) - (Cd * D)\n\nGL_FUNC_REVDRSE_SUBTRACT\t\t//Cf = (Cs * D) - (Cd * S)\n\nGL_MIN\t\t\t\t\t\t\t\t//Cf = min(Cs,Cd)\n\nGL_MAX\t\t\t\t\t\t\t\t//Cf = max(Cs,Cd)\n```\n\n另外：\n\n`void glBlendFuncSeparate(GLenum srcRGB,GLenum dstRGB,GLenum srcAlpha,GLenum dstAlpha);`\n\n可以指定源和目标的RGB颜色与Alpha颜色不同的混合函数；\n\n`vodi glBlendColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);`\n\n可以指定混合一个常量混合颜色，初始为黑色（0,0,0,0）；\n\n### - 抗锯齿\n\n由于像素是正方形的，混合时通常可以相当清楚地看到两种颜色的分界，它们常常被称为锯齿，为了消除锯齿，使用混合功能并开启锯齿，使边缘变得平滑；具体使用方法如下代码：\n\n```\n\t\t switch(value)\n        {\n        case 1:\n            // 打开抗锯齿，并给出关于尽可能进行最佳的处理的提示\n\t\t\t  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n            glEnable(GL_BLEND);\n            glEnable(GL_POINT_SMOOTH);\n            glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n            glEnable(GL_LINE_SMOOTH);\n            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);\n            glEnable(GL_POLYGON_SMOOTH);\n            glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);\n            break;\n\n        case 2:\n            // 关闭混合和所有的平滑处理\n\t\t\t  glDisable(GL_BLEND);\n            glDisable(GL_LINE_SMOOTH);\n            glDisable(GL_POINT_SMOOTH);\n            break;\n\n        default:\n            break;\n        }\n```\n\n`glEnable(GL_POINT_SMOOTH);`就是开启抗锯齿；\n\n`glHint(GLenum target, GLenum mode)`函数中target参数指定希望进行修改的行为类型，mode参数告诉OpenGL我们最关心的是什么，或渲染速度或输出质量；该函数是gl唯一一个行为完全依赖生产商的函数，总结呢是跟渲染的性能有关的函数，具体情况具体分析吧，这种函数一般很难实际看出效果；\n\n### -多重采样\n\n最后讲一下多重采样，上边讲到的平滑处理在点和直线上是广泛支持的，但是多边形的平滑处理并没有在所有平台上都得到实现，然而在`GL_POLYGON_SMOOTH`时，由于抗锯齿处理是基于混合操作的，需要对从前到后所有图元进行排序，这显然相当麻烦，使用多重采样可以解决这个问题；\n\n多重采样时，当某一点上的像素进行更新时，gl会在一个缓冲区内对该像素上的值进行采样，结果会通过采样值产生一个单独的值，这可能对性能造成一定的影响；\n\n打开多重采样：\n\n`glEnable(GL_MULTISAMPLE);`\n\n值得注意的一点是，当启用多重采样时，点、直线和多边形的平滑特性会被忽略；\n\n多重采样的采样值是会被保存在一个单独的缓存区内的，如果没有多重采样缓存区，OpenGL就当作该功能是被禁用的；\n\n>>状态排序\n\n>打开或关闭不同的OpenGL特性将会修改驱动程序的内部状态，这种状态的改变可能会对渲染的性能造成影响。对性能非常敏感的程序员常常会不辞辛苦地对所有绘图命令进行排序，这样需要相同状态的几何图形就可以在一起绘制。这种状态排序是在游戏中常用的提高速度的方法之一。\n\n多重采样缓和区在默认情况下使用片断的RGB值，并不包括颜色的alpha成分；我们可以调用`glEnable`来修改这个行为\n\n```\nGL_SAMPLE_ALPHA_TO_COVERAGE\t\t\t//使用alpha值\n\nGL_SAMPLE_ALPHA_TO_ON\t\t\t\t\t//将alpha值设为1并使用它\n\nGL_SAMPLE_COVERAGE\t\t\t\t\t\t//使用glSampleCoverage设置的值\n```\n\n`void glSampleCoverage(GLclampf value, GLboolean invert);`函数允许指定一个特定的值，它是与片断覆盖值进行按位与操作的结果；\n\n\n","source":"_posts/OpenGL-由实例理解概念.md","raw":"title: OpenGL-由实例理解概念\ndate: 2016-07-10 22:00:00\ncategories: coder\ntags: [opengl, render]\n-----------\n\nSummary:本篇讲一下关于OpenGL图形管线的一些基础知识，刚开始的内容会比较枯燥，后面会用几个例子讲解几种渲染方法，下载git上的例子可以在xcode上看到几种渲染的效果。可展示的效果有，正面和背面剔除、深度测试、多边形偏移、裁剪、混合、多重采样。\n<!-- more -->\n\n\ngit地址：[点击这里](https://github.com/usiege/OpenGL_S/tree/master/OpenGL_03_基础渲染/OGL_03_BaseRender)（这里做一下说明，在研究例子的过程中，请无视掉GLTools库，该库是原书作者对gl的一次封装，内部实现接下来会逐层展开，我们现在只讨论与gl有关的内容，后期的话我们可以自己实现封装。）\n\n## 将点连接起来\n\n上篇讲了运用gl画线函数画出直线与折线，本篇作一些补充。\n\n- 点的大小\n\n`void glPointSize(GLfloat size);`\n\n该函数可以指定绘制点的像素，不过并不是所有点的大小都能够支持，使用前请确认指定的点大小是可用的；利用下面这段代码可以获得点大小的范围，以及最小间隔：\n\n```\nGLfloat sizes[2];\t//存储支持的点的大小范围\nGLfloat step;\t\t\t//存储支持点的大小增量\n\n//获取支持的点的大小范围和增量\nglGetFloatv(GL_POINT_SIZE_RANGE,sizes);\nglGetFloatv(GL_POINT_SIZE_GRANULARITY,&step);\n```\n点总是正方形的像素，改变点大小情况也如此；\n\n另外还可以通过使用程序点大小模式来设置点大小，这样的话需要在顶点着色器或几何着色器代码中设置点的大小，这两种编程方法将在后面讲到；\n\n```\nglEnable(GL_PROGRAM_POINT_SIZE);\n//该模式允许通过着色器程序修改点大小\ngl_PointSize = 5.0;\n//在着色器程序中，修改该内建变量的值\n```\n\n- 线的宽度\n\n`void glLineWidth(GLfloat width);`\n\n该函数可以指定线段的宽度，它是改变线段宽度的唯一方式；\n\n- 线带\n\n连续的从一个顶点绘制线段，以形成一个连接起来的线带，使用`GL_LINE_STRIP`可绘制一组连接起来的线段；\n\n- 线环\n\n如果想要使上面的线带是闭合的，那么使用`GL_LINE_LOOP`会是不错的选择；\n\n- 三角形环绕\n\n>指定三角形时，点绘制的顺序与方向是不同的，使用这种结合来指定的方式叫做环绕。\n\n默认情况下，OpenGL认为具有逆时针方向环绕的多边形是正面的，如想修改默认的行为：\n\n`glFrontFace(GL_CW);`\n\n`GL_CW`参数告诉OpenGL顺时针环绕多边形将被认为是正面的；如需恢复逆时针，可以使用参数`GL_CCW`;\n\n- 三角形带\n\n当我们需要一串相连的三角形时，可以使用`GL_TRIANGLE_STRIP`图元绘制相连的三角形，这样可以节省大量时间；\n\n- 三角形扇\n\n使用`GL_TRIANGLE_FAN`可以创建一组围绕一个中心点的相连三角形；\n\n本文地址工程目录Primitives展示了以上几种图形的画法；\n\n## 基础渲染方式\n\n### - 油画法\n\n绘制三角形时，如果出现覆盖的情况，通常的做法是对三角形进行排序，然后首先画那些较远的三角形，再在上方渲染那些较近的三角形，这种方式称做“油画法”；这种方法在图形处理中是非常低效的；\n\n### - 正面和背面剔除\n\n前面讲到三角形有正面与背面的区分，对其进行区分的原因之一就是为了进行剔除；选择不必要的面进行剔除会极大地提高性能；剔除按如下方式开启：\n\n```\n\nglEnable(GL_CULL_FACE);\t\t//开启\nglDisable(GL_CULL_FACE);\t//关闭\n\n```\n\n我们并没有指明剔除的面，如下：\n\n```\n\nvoid glCullFace(GLenum mode);\n\nGL_FRONT\t//剔除正面\n\nGL_BACK\t//剔除背面\n\nGL_FRONT_AND_BACK //正反面全部剔除\n```\n\n### - 深度测试\n\n在绘制一个像素时，将一个值（z值）分配给它，表示它到观察者的距离；当另外一个像素在同样位置进行绘制时，新像素z将与原来的进行比较，我们只绘制z值更小的像素；\n\n启用深度测试：\n\n`glEnable(GL_DEPTH_TEST);`\n\n### - 多边形模式\n\n函数*glPolygonMode*允许将多边形渲染成实体、轮廓或只有点，而且可以选择在多边形的正反面上启用该模式；\n\n```\n\nvoid glPolygonMode(GLenum face, GLenum mode);\n\n//face\n\nGL_FRONT\n\nGL_BACK\n\nGL_FRONT_AND_BACK\n\n//mode\n\nGL_FILL\t\t//默认值，实心\n\nGL_LINE\t\t//轮廓\n\nGL_POINT\t\t//点\n```\n\n本文例子GeoTest会展示这些效果；\n\n### - 多边形偏移\n\n举个例子，我们可能想要绘制一架大型飞机，然后在飞机上一个较小的但却与飞机在同一物理空间的图形，这叫做“贴花”；这个小的图形的深度值将会与原来飞机的深度缓冲区中的值相同，这将导致深度测试不可预料的通过或者失败，这种情况叫做z冲突；\n\n另外一种情况，我们想要在绘制的实心几何图形上突出它的边；以上这些z冲突的情况下，通常我们解决的办法是当深度值相同时，适当的对深度进行偏移而并不改变实际3D空间中的物理位置：\n\n```\nvoid glPolygonOffset(GLfloat factor, GLfloat units);\n//函数通过 Depth offset = (DZ * factor) + (r * units) 公式计算新的深度值；\n//其中，DZ是深度值相对于多边形屏幕区域的变化量，r是使深度缓冲区值产生变化的最小值；\n\n```\n\n例子Primitives的`DrawWireFramedBatch`函数代码中展示了偏移的使用;\n\n```\n```\n\n### - 裁剪\n\n裁剪是将渲染限制在一个较小的矩形中，如要开启裁剪：\n\n`glEnalbe(GL_SCISSOR_TEST);`\n\n指定窗口：\n\n```\nvoid glScissor(GLint x, GLint y, GLsizei width, GLsizei height);\n//x,y指定裁剪框左下角，width height则指定宽度和高度\n```\n\n例子Scissor展示了该函数的用法:\n\n```\n\t// Clear blue window\n    glClearColor(0.0f, 0.0f, 1.0f, 0.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // Now set scissor to smaller red sub region\n    glClearColor(1.0f, 0.0f, 0.0f, 0.0f);\n    glScissor(100, 100, 600, 400);\n    glEnable(GL_SCISSOR_TEST);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // Finally, an even smaller green rectangle\n    glClearColor(0.0f, 1.0f, 0.0f, 0.0f);\n    glScissor(200, 200, 400, 200);\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    // Turn scissor back off for next render\n    glDisable(GL_SCISSOR_TEST);\n    \n```\n\n### - 混合\n\n当深度值相同时，使用混合也可以使下层的颜色值不会被清除；开启混合使用：\n\n`glEnable(GL_BLEND);`\n\n> 目标颜色：已经存储在颜色缓冲区中的颜色值；\n\n\n> 源颜色：作为当前渲染命令的结果进入颜色缓冲区的颜色；\n\n混合功能开启后，目标颜色和源颜色的组合方式是由混合方程式控制的；\n\n>> Cf = (Cs * S) + (Cd * D)\n\n>Cf是最终计算产生的颜色，Cs是源颜色，Cd是目标颜色，S、D分别是源和目标混合因子；\n\n>注意Cs和Cd都是向量，以上进行的是向量乘法和加法；\n\n混合因子是用函数进行设置的：\n\n```\nglBlendFunc(GLenum S, GLenum D);\n//S D都是枚举值，详细请自行google，这里给出枚举值\n```\n\n混合方程式并不是唯一的，如需改变则：\n\n```\nvoid glBlendEquation(GLenum mode);\n\nGL_FUNC_ADD\t\t\t\t\t\t//Cf = (Cs * S) + (Cd * D)\n\nGL_FUNC_SUBTRACT\t\t\t\t\t//Cf = (Cs * S) - (Cd * D)\n\nGL_FUNC_REVDRSE_SUBTRACT\t\t//Cf = (Cs * D) - (Cd * S)\n\nGL_MIN\t\t\t\t\t\t\t\t//Cf = min(Cs,Cd)\n\nGL_MAX\t\t\t\t\t\t\t\t//Cf = max(Cs,Cd)\n```\n\n另外：\n\n`void glBlendFuncSeparate(GLenum srcRGB,GLenum dstRGB,GLenum srcAlpha,GLenum dstAlpha);`\n\n可以指定源和目标的RGB颜色与Alpha颜色不同的混合函数；\n\n`vodi glBlendColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);`\n\n可以指定混合一个常量混合颜色，初始为黑色（0,0,0,0）；\n\n### - 抗锯齿\n\n由于像素是正方形的，混合时通常可以相当清楚地看到两种颜色的分界，它们常常被称为锯齿，为了消除锯齿，使用混合功能并开启锯齿，使边缘变得平滑；具体使用方法如下代码：\n\n```\n\t\t switch(value)\n        {\n        case 1:\n            // 打开抗锯齿，并给出关于尽可能进行最佳的处理的提示\n\t\t\t  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n            glEnable(GL_BLEND);\n            glEnable(GL_POINT_SMOOTH);\n            glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n            glEnable(GL_LINE_SMOOTH);\n            glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);\n            glEnable(GL_POLYGON_SMOOTH);\n            glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);\n            break;\n\n        case 2:\n            // 关闭混合和所有的平滑处理\n\t\t\t  glDisable(GL_BLEND);\n            glDisable(GL_LINE_SMOOTH);\n            glDisable(GL_POINT_SMOOTH);\n            break;\n\n        default:\n            break;\n        }\n```\n\n`glEnable(GL_POINT_SMOOTH);`就是开启抗锯齿；\n\n`glHint(GLenum target, GLenum mode)`函数中target参数指定希望进行修改的行为类型，mode参数告诉OpenGL我们最关心的是什么，或渲染速度或输出质量；该函数是gl唯一一个行为完全依赖生产商的函数，总结呢是跟渲染的性能有关的函数，具体情况具体分析吧，这种函数一般很难实际看出效果；\n\n### -多重采样\n\n最后讲一下多重采样，上边讲到的平滑处理在点和直线上是广泛支持的，但是多边形的平滑处理并没有在所有平台上都得到实现，然而在`GL_POLYGON_SMOOTH`时，由于抗锯齿处理是基于混合操作的，需要对从前到后所有图元进行排序，这显然相当麻烦，使用多重采样可以解决这个问题；\n\n多重采样时，当某一点上的像素进行更新时，gl会在一个缓冲区内对该像素上的值进行采样，结果会通过采样值产生一个单独的值，这可能对性能造成一定的影响；\n\n打开多重采样：\n\n`glEnable(GL_MULTISAMPLE);`\n\n值得注意的一点是，当启用多重采样时，点、直线和多边形的平滑特性会被忽略；\n\n多重采样的采样值是会被保存在一个单独的缓存区内的，如果没有多重采样缓存区，OpenGL就当作该功能是被禁用的；\n\n>>状态排序\n\n>打开或关闭不同的OpenGL特性将会修改驱动程序的内部状态，这种状态的改变可能会对渲染的性能造成影响。对性能非常敏感的程序员常常会不辞辛苦地对所有绘图命令进行排序，这样需要相同状态的几何图形就可以在一起绘制。这种状态排序是在游戏中常用的提高速度的方法之一。\n\n多重采样缓和区在默认情况下使用片断的RGB值，并不包括颜色的alpha成分；我们可以调用`glEnable`来修改这个行为\n\n```\nGL_SAMPLE_ALPHA_TO_COVERAGE\t\t\t//使用alpha值\n\nGL_SAMPLE_ALPHA_TO_ON\t\t\t\t\t//将alpha值设为1并使用它\n\nGL_SAMPLE_COVERAGE\t\t\t\t\t\t//使用glSampleCoverage设置的值\n```\n\n`void glSampleCoverage(GLclampf value, GLboolean invert);`函数允许指定一个特定的值，它是与片断覆盖值进行按位与操作的结果；\n\n\n","slug":"OpenGL-由实例理解概念","published":1,"updated":"2018-05-04T10:26:47.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucio2000k1v601dj3mi77","content":"<p>Summary:本篇讲一下关于OpenGL图形管线的一些基础知识，刚开始的内容会比较枯燥，后面会用几个例子讲解几种渲染方法，下载git上的例子可以在xcode上看到几种渲染的效果。可展示的效果有，正面和背面剔除、深度测试、多边形偏移、裁剪、混合、多重采样。<br><a id=\"more\"></a></p>\n<p>git地址：<a href=\"https://github.com/usiege/OpenGL_S/tree/master/OpenGL_03_基础渲染/OGL_03_BaseRender\" target=\"_blank\" rel=\"noopener\">点击这里</a>（这里做一下说明，在研究例子的过程中，请无视掉GLTools库，该库是原书作者对gl的一次封装，内部实现接下来会逐层展开，我们现在只讨论与gl有关的内容，后期的话我们可以自己实现封装。）</p>\n<h2 id=\"将点连接起来\"><a href=\"#将点连接起来\" class=\"headerlink\" title=\"将点连接起来\"></a>将点连接起来</h2><p>上篇讲了运用gl画线函数画出直线与折线，本篇作一些补充。</p>\n<ul>\n<li>点的大小</li>\n</ul>\n<p><code>void glPointSize(GLfloat size);</code></p>\n<p>该函数可以指定绘制点的像素，不过并不是所有点的大小都能够支持，使用前请确认指定的点大小是可用的；利用下面这段代码可以获得点大小的范围，以及最小间隔：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat sizes[2];\t//存储支持的点的大小范围</span><br><span class=\"line\">GLfloat step;\t\t\t//存储支持点的大小增量</span><br><span class=\"line\"></span><br><span class=\"line\">//获取支持的点的大小范围和增量</span><br><span class=\"line\">glGetFloatv(GL_POINT_SIZE_RANGE,sizes);</span><br><span class=\"line\">glGetFloatv(GL_POINT_SIZE_GRANULARITY,&amp;step);</span><br></pre></td></tr></table></figure>\n<p>点总是正方形的像素，改变点大小情况也如此；</p>\n<p>另外还可以通过使用程序点大小模式来设置点大小，这样的话需要在顶点着色器或几何着色器代码中设置点的大小，这两种编程方法将在后面讲到；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_PROGRAM_POINT_SIZE);</span><br><span class=\"line\">//该模式允许通过着色器程序修改点大小</span><br><span class=\"line\">gl_PointSize = 5.0;</span><br><span class=\"line\">//在着色器程序中，修改该内建变量的值</span><br></pre></td></tr></table></figure>\n<ul>\n<li>线的宽度</li>\n</ul>\n<p><code>void glLineWidth(GLfloat width);</code></p>\n<p>该函数可以指定线段的宽度，它是改变线段宽度的唯一方式；</p>\n<ul>\n<li>线带</li>\n</ul>\n<p>连续的从一个顶点绘制线段，以形成一个连接起来的线带，使用<code>GL_LINE_STRIP</code>可绘制一组连接起来的线段；</p>\n<ul>\n<li>线环</li>\n</ul>\n<p>如果想要使上面的线带是闭合的，那么使用<code>GL_LINE_LOOP</code>会是不错的选择；</p>\n<ul>\n<li>三角形环绕</li>\n</ul>\n<blockquote>\n<p>指定三角形时，点绘制的顺序与方向是不同的，使用这种结合来指定的方式叫做环绕。</p>\n</blockquote>\n<p>默认情况下，OpenGL认为具有逆时针方向环绕的多边形是正面的，如想修改默认的行为：</p>\n<p><code>glFrontFace(GL_CW);</code></p>\n<p><code>GL_CW</code>参数告诉OpenGL顺时针环绕多边形将被认为是正面的；如需恢复逆时针，可以使用参数<code>GL_CCW</code>;</p>\n<ul>\n<li>三角形带</li>\n</ul>\n<p>当我们需要一串相连的三角形时，可以使用<code>GL_TRIANGLE_STRIP</code>图元绘制相连的三角形，这样可以节省大量时间；</p>\n<ul>\n<li>三角形扇</li>\n</ul>\n<p>使用<code>GL_TRIANGLE_FAN</code>可以创建一组围绕一个中心点的相连三角形；</p>\n<p>本文地址工程目录Primitives展示了以上几种图形的画法；</p>\n<h2 id=\"基础渲染方式\"><a href=\"#基础渲染方式\" class=\"headerlink\" title=\"基础渲染方式\"></a>基础渲染方式</h2><h3 id=\"油画法\"><a href=\"#油画法\" class=\"headerlink\" title=\"- 油画法\"></a>- 油画法</h3><p>绘制三角形时，如果出现覆盖的情况，通常的做法是对三角形进行排序，然后首先画那些较远的三角形，再在上方渲染那些较近的三角形，这种方式称做“油画法”；这种方法在图形处理中是非常低效的；</p>\n<h3 id=\"正面和背面剔除\"><a href=\"#正面和背面剔除\" class=\"headerlink\" title=\"- 正面和背面剔除\"></a>- 正面和背面剔除</h3><p>前面讲到三角形有正面与背面的区分，对其进行区分的原因之一就是为了进行剔除；选择不必要的面进行剔除会极大地提高性能；剔除按如下方式开启：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">glEnable(GL_CULL_FACE);\t\t//开启</span><br><span class=\"line\">glDisable(GL_CULL_FACE);\t//关闭</span><br></pre></td></tr></table></figure>\n<p>我们并没有指明剔除的面，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void glCullFace(GLenum mode);</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT\t//剔除正面</span><br><span class=\"line\"></span><br><span class=\"line\">GL_BACK\t//剔除背面</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT_AND_BACK //正反面全部剔除</span><br></pre></td></tr></table></figure>\n<h3 id=\"深度测试\"><a href=\"#深度测试\" class=\"headerlink\" title=\"- 深度测试\"></a>- 深度测试</h3><p>在绘制一个像素时，将一个值（z值）分配给它，表示它到观察者的距离；当另外一个像素在同样位置进行绘制时，新像素z将与原来的进行比较，我们只绘制z值更小的像素；</p>\n<p>启用深度测试：</p>\n<p><code>glEnable(GL_DEPTH_TEST);</code></p>\n<h3 id=\"多边形模式\"><a href=\"#多边形模式\" class=\"headerlink\" title=\"- 多边形模式\"></a>- 多边形模式</h3><p>函数<em>glPolygonMode</em>允许将多边形渲染成实体、轮廓或只有点，而且可以选择在多边形的正反面上启用该模式；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void glPolygonMode(GLenum face, GLenum mode);</span><br><span class=\"line\"></span><br><span class=\"line\">//face</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT</span><br><span class=\"line\"></span><br><span class=\"line\">GL_BACK</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT_AND_BACK</span><br><span class=\"line\"></span><br><span class=\"line\">//mode</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FILL\t\t//默认值，实心</span><br><span class=\"line\"></span><br><span class=\"line\">GL_LINE\t\t//轮廓</span><br><span class=\"line\"></span><br><span class=\"line\">GL_POINT\t\t//点</span><br></pre></td></tr></table></figure>\n<p>本文例子GeoTest会展示这些效果；</p>\n<h3 id=\"多边形偏移\"><a href=\"#多边形偏移\" class=\"headerlink\" title=\"- 多边形偏移\"></a>- 多边形偏移</h3><p>举个例子，我们可能想要绘制一架大型飞机，然后在飞机上一个较小的但却与飞机在同一物理空间的图形，这叫做“贴花”；这个小的图形的深度值将会与原来飞机的深度缓冲区中的值相同，这将导致深度测试不可预料的通过或者失败，这种情况叫做z冲突；</p>\n<p>另外一种情况，我们想要在绘制的实心几何图形上突出它的边；以上这些z冲突的情况下，通常我们解决的办法是当深度值相同时，适当的对深度进行偏移而并不改变实际3D空间中的物理位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glPolygonOffset(GLfloat factor, GLfloat units);</span><br><span class=\"line\">//函数通过 Depth offset = (DZ * factor) + (r * units) 公式计算新的深度值；</span><br><span class=\"line\">//其中，DZ是深度值相对于多边形屏幕区域的变化量，r是使深度缓冲区值产生变化的最小值；</span><br></pre></td></tr></table></figure>\n<p>例子Primitives的<code>DrawWireFramedBatch</code>函数代码中展示了偏移的使用;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"></span><br><span class=\"line\">### - 裁剪</span><br><span class=\"line\"></span><br><span class=\"line\">裁剪是将渲染限制在一个较小的矩形中，如要开启裁剪：</span><br><span class=\"line\"></span><br><span class=\"line\">`glEnalbe(GL_SCISSOR_TEST);`</span><br><span class=\"line\"></span><br><span class=\"line\">指定窗口：</span><br></pre></td></tr></table></figure>\n<p>void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);<br>//x,y指定裁剪框左下角，width height则指定宽度和高度<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">例子Scissor展示了该函数的用法:</span><br></pre></td></tr></table></figure></p>\n<pre><code>// Clear blue window\nglClearColor(0.0f, 0.0f, 1.0f, 0.0f);\nglClear(GL_COLOR_BUFFER_BIT);\n\n// Now set scissor to smaller red sub region\nglClearColor(1.0f, 0.0f, 0.0f, 0.0f);\nglScissor(100, 100, 600, 400);\nglEnable(GL_SCISSOR_TEST);\nglClear(GL_COLOR_BUFFER_BIT);\n\n// Finally, an even smaller green rectangle\nglClearColor(0.0f, 1.0f, 0.0f, 0.0f);\nglScissor(200, 200, 400, 200);\nglClear(GL_COLOR_BUFFER_BIT);\n\n// Turn scissor back off for next render\nglDisable(GL_SCISSOR_TEST);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### - 混合</span><br><span class=\"line\"></span><br><span class=\"line\">当深度值相同时，使用混合也可以使下层的颜色值不会被清除；开启混合使用：</span><br><span class=\"line\"></span><br><span class=\"line\">`glEnable(GL_BLEND);`</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 目标颜色：已经存储在颜色缓冲区中的颜色值；</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 源颜色：作为当前渲染命令的结果进入颜色缓冲区的颜色；</span><br><span class=\"line\"></span><br><span class=\"line\">混合功能开启后，目标颜色和源颜色的组合方式是由混合方程式控制的；</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; Cf = (Cs * S) + (Cd * D)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Cf是最终计算产生的颜色，Cs是源颜色，Cd是目标颜色，S、D分别是源和目标混合因子；</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;注意Cs和Cd都是向量，以上进行的是向量乘法和加法；</span><br><span class=\"line\"></span><br><span class=\"line\">混合因子是用函数进行设置的：</span><br></pre></td></tr></table></figure>\n<p>glBlendFunc(GLenum S, GLenum D);<br>//S D都是枚举值，详细请自行google，这里给出枚举值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">混合方程式并不是唯一的，如需改变则：</span><br></pre></td></tr></table></figure></p>\n<p>void glBlendEquation(GLenum mode);</p>\n<p>GL_FUNC_ADD                        //Cf = (Cs <em> S) + (Cd </em> D)</p>\n<p>GL_FUNC_SUBTRACT                    //Cf = (Cs <em> S) - (Cd </em> D)</p>\n<p>GL_FUNC_REVDRSE_SUBTRACT        //Cf = (Cs <em> D) - (Cd </em> S)</p>\n<p>GL_MIN                                //Cf = min(Cs,Cd)</p>\n<p>GL_MAX                                //Cf = max(Cs,Cd)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">另外：</span><br><span class=\"line\"></span><br><span class=\"line\">`void glBlendFuncSeparate(GLenum srcRGB,GLenum dstRGB,GLenum srcAlpha,GLenum dstAlpha);`</span><br><span class=\"line\"></span><br><span class=\"line\">可以指定源和目标的RGB颜色与Alpha颜色不同的混合函数；</span><br><span class=\"line\"></span><br><span class=\"line\">`vodi glBlendColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);`</span><br><span class=\"line\"></span><br><span class=\"line\">可以指定混合一个常量混合颜色，初始为黑色（0,0,0,0）；</span><br><span class=\"line\"></span><br><span class=\"line\">### - 抗锯齿</span><br><span class=\"line\"></span><br><span class=\"line\">由于像素是正方形的，混合时通常可以相当清楚地看到两种颜色的分界，它们常常被称为锯齿，为了消除锯齿，使用混合功能并开启锯齿，使边缘变得平滑；具体使用方法如下代码：</span><br></pre></td></tr></table></figure></p>\n<pre><code> switch(value)\n{\ncase 1:\n    // 打开抗锯齿，并给出关于尽可能进行最佳的处理的提示\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_BLEND);\n    glEnable(GL_POINT_SMOOTH);\n    glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n    glEnable(GL_LINE_SMOOTH);\n    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);\n    glEnable(GL_POLYGON_SMOOTH);\n    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);\n    break;\n\ncase 2:\n    // 关闭混合和所有的平滑处理\n      glDisable(GL_BLEND);\n    glDisable(GL_LINE_SMOOTH);\n    glDisable(GL_POINT_SMOOTH);\n    break;\n\ndefault:\n    break;\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`glEnable(GL_POINT_SMOOTH);`就是开启抗锯齿；</span><br><span class=\"line\"></span><br><span class=\"line\">`glHint(GLenum target, GLenum mode)`函数中target参数指定希望进行修改的行为类型，mode参数告诉OpenGL我们最关心的是什么，或渲染速度或输出质量；该函数是gl唯一一个行为完全依赖生产商的函数，总结呢是跟渲染的性能有关的函数，具体情况具体分析吧，这种函数一般很难实际看出效果；</span><br><span class=\"line\"></span><br><span class=\"line\">### -多重采样</span><br><span class=\"line\"></span><br><span class=\"line\">最后讲一下多重采样，上边讲到的平滑处理在点和直线上是广泛支持的，但是多边形的平滑处理并没有在所有平台上都得到实现，然而在`GL_POLYGON_SMOOTH`时，由于抗锯齿处理是基于混合操作的，需要对从前到后所有图元进行排序，这显然相当麻烦，使用多重采样可以解决这个问题；</span><br><span class=\"line\"></span><br><span class=\"line\">多重采样时，当某一点上的像素进行更新时，gl会在一个缓冲区内对该像素上的值进行采样，结果会通过采样值产生一个单独的值，这可能对性能造成一定的影响；</span><br><span class=\"line\"></span><br><span class=\"line\">打开多重采样：</span><br><span class=\"line\"></span><br><span class=\"line\">`glEnable(GL_MULTISAMPLE);`</span><br><span class=\"line\"></span><br><span class=\"line\">值得注意的一点是，当启用多重采样时，点、直线和多边形的平滑特性会被忽略；</span><br><span class=\"line\"></span><br><span class=\"line\">多重采样的采样值是会被保存在一个单独的缓存区内的，如果没有多重采样缓存区，OpenGL就当作该功能是被禁用的；</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;状态排序</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;打开或关闭不同的OpenGL特性将会修改驱动程序的内部状态，这种状态的改变可能会对渲染的性能造成影响。对性能非常敏感的程序员常常会不辞辛苦地对所有绘图命令进行排序，这样需要相同状态的几何图形就可以在一起绘制。这种状态排序是在游戏中常用的提高速度的方法之一。</span><br><span class=\"line\"></span><br><span class=\"line\">多重采样缓和区在默认情况下使用片断的RGB值，并不包括颜色的alpha成分；我们可以调用`glEnable`来修改这个行为</span><br></pre></td></tr></table></figure>\n<p>GL_SAMPLE_ALPHA_TO_COVERAGE            //使用alpha值</p>\n<p>GL_SAMPLE_ALPHA_TO_ON                    //将alpha值设为1并使用它</p>\n<p>GL_SAMPLE_COVERAGE                        //使用glSampleCoverage设置的值<br><code>`</code></p>\n<p><code>void glSampleCoverage(GLclampf value, GLboolean invert);</code>函数允许指定一个特定的值，它是与片断覆盖值进行按位与操作的结果；</p>\n","site":{"data":{}},"excerpt":"<p>Summary:本篇讲一下关于OpenGL图形管线的一些基础知识，刚开始的内容会比较枯燥，后面会用几个例子讲解几种渲染方法，下载git上的例子可以在xcode上看到几种渲染的效果。可展示的效果有，正面和背面剔除、深度测试、多边形偏移、裁剪、混合、多重采样。<br>","more":"</p>\n<p>git地址：<a href=\"https://github.com/usiege/OpenGL_S/tree/master/OpenGL_03_基础渲染/OGL_03_BaseRender\" target=\"_blank\" rel=\"noopener\">点击这里</a>（这里做一下说明，在研究例子的过程中，请无视掉GLTools库，该库是原书作者对gl的一次封装，内部实现接下来会逐层展开，我们现在只讨论与gl有关的内容，后期的话我们可以自己实现封装。）</p>\n<h2 id=\"将点连接起来\"><a href=\"#将点连接起来\" class=\"headerlink\" title=\"将点连接起来\"></a>将点连接起来</h2><p>上篇讲了运用gl画线函数画出直线与折线，本篇作一些补充。</p>\n<ul>\n<li>点的大小</li>\n</ul>\n<p><code>void glPointSize(GLfloat size);</code></p>\n<p>该函数可以指定绘制点的像素，不过并不是所有点的大小都能够支持，使用前请确认指定的点大小是可用的；利用下面这段代码可以获得点大小的范围，以及最小间隔：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat sizes[2];\t//存储支持的点的大小范围</span><br><span class=\"line\">GLfloat step;\t\t\t//存储支持点的大小增量</span><br><span class=\"line\"></span><br><span class=\"line\">//获取支持的点的大小范围和增量</span><br><span class=\"line\">glGetFloatv(GL_POINT_SIZE_RANGE,sizes);</span><br><span class=\"line\">glGetFloatv(GL_POINT_SIZE_GRANULARITY,&amp;step);</span><br></pre></td></tr></table></figure>\n<p>点总是正方形的像素，改变点大小情况也如此；</p>\n<p>另外还可以通过使用程序点大小模式来设置点大小，这样的话需要在顶点着色器或几何着色器代码中设置点的大小，这两种编程方法将在后面讲到；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_PROGRAM_POINT_SIZE);</span><br><span class=\"line\">//该模式允许通过着色器程序修改点大小</span><br><span class=\"line\">gl_PointSize = 5.0;</span><br><span class=\"line\">//在着色器程序中，修改该内建变量的值</span><br></pre></td></tr></table></figure>\n<ul>\n<li>线的宽度</li>\n</ul>\n<p><code>void glLineWidth(GLfloat width);</code></p>\n<p>该函数可以指定线段的宽度，它是改变线段宽度的唯一方式；</p>\n<ul>\n<li>线带</li>\n</ul>\n<p>连续的从一个顶点绘制线段，以形成一个连接起来的线带，使用<code>GL_LINE_STRIP</code>可绘制一组连接起来的线段；</p>\n<ul>\n<li>线环</li>\n</ul>\n<p>如果想要使上面的线带是闭合的，那么使用<code>GL_LINE_LOOP</code>会是不错的选择；</p>\n<ul>\n<li>三角形环绕</li>\n</ul>\n<blockquote>\n<p>指定三角形时，点绘制的顺序与方向是不同的，使用这种结合来指定的方式叫做环绕。</p>\n</blockquote>\n<p>默认情况下，OpenGL认为具有逆时针方向环绕的多边形是正面的，如想修改默认的行为：</p>\n<p><code>glFrontFace(GL_CW);</code></p>\n<p><code>GL_CW</code>参数告诉OpenGL顺时针环绕多边形将被认为是正面的；如需恢复逆时针，可以使用参数<code>GL_CCW</code>;</p>\n<ul>\n<li>三角形带</li>\n</ul>\n<p>当我们需要一串相连的三角形时，可以使用<code>GL_TRIANGLE_STRIP</code>图元绘制相连的三角形，这样可以节省大量时间；</p>\n<ul>\n<li>三角形扇</li>\n</ul>\n<p>使用<code>GL_TRIANGLE_FAN</code>可以创建一组围绕一个中心点的相连三角形；</p>\n<p>本文地址工程目录Primitives展示了以上几种图形的画法；</p>\n<h2 id=\"基础渲染方式\"><a href=\"#基础渲染方式\" class=\"headerlink\" title=\"基础渲染方式\"></a>基础渲染方式</h2><h3 id=\"油画法\"><a href=\"#油画法\" class=\"headerlink\" title=\"- 油画法\"></a>- 油画法</h3><p>绘制三角形时，如果出现覆盖的情况，通常的做法是对三角形进行排序，然后首先画那些较远的三角形，再在上方渲染那些较近的三角形，这种方式称做“油画法”；这种方法在图形处理中是非常低效的；</p>\n<h3 id=\"正面和背面剔除\"><a href=\"#正面和背面剔除\" class=\"headerlink\" title=\"- 正面和背面剔除\"></a>- 正面和背面剔除</h3><p>前面讲到三角形有正面与背面的区分，对其进行区分的原因之一就是为了进行剔除；选择不必要的面进行剔除会极大地提高性能；剔除按如下方式开启：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">glEnable(GL_CULL_FACE);\t\t//开启</span><br><span class=\"line\">glDisable(GL_CULL_FACE);\t//关闭</span><br></pre></td></tr></table></figure>\n<p>我们并没有指明剔除的面，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void glCullFace(GLenum mode);</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT\t//剔除正面</span><br><span class=\"line\"></span><br><span class=\"line\">GL_BACK\t//剔除背面</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT_AND_BACK //正反面全部剔除</span><br></pre></td></tr></table></figure>\n<h3 id=\"深度测试\"><a href=\"#深度测试\" class=\"headerlink\" title=\"- 深度测试\"></a>- 深度测试</h3><p>在绘制一个像素时，将一个值（z值）分配给它，表示它到观察者的距离；当另外一个像素在同样位置进行绘制时，新像素z将与原来的进行比较，我们只绘制z值更小的像素；</p>\n<p>启用深度测试：</p>\n<p><code>glEnable(GL_DEPTH_TEST);</code></p>\n<h3 id=\"多边形模式\"><a href=\"#多边形模式\" class=\"headerlink\" title=\"- 多边形模式\"></a>- 多边形模式</h3><p>函数<em>glPolygonMode</em>允许将多边形渲染成实体、轮廓或只有点，而且可以选择在多边形的正反面上启用该模式；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void glPolygonMode(GLenum face, GLenum mode);</span><br><span class=\"line\"></span><br><span class=\"line\">//face</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT</span><br><span class=\"line\"></span><br><span class=\"line\">GL_BACK</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FRONT_AND_BACK</span><br><span class=\"line\"></span><br><span class=\"line\">//mode</span><br><span class=\"line\"></span><br><span class=\"line\">GL_FILL\t\t//默认值，实心</span><br><span class=\"line\"></span><br><span class=\"line\">GL_LINE\t\t//轮廓</span><br><span class=\"line\"></span><br><span class=\"line\">GL_POINT\t\t//点</span><br></pre></td></tr></table></figure>\n<p>本文例子GeoTest会展示这些效果；</p>\n<h3 id=\"多边形偏移\"><a href=\"#多边形偏移\" class=\"headerlink\" title=\"- 多边形偏移\"></a>- 多边形偏移</h3><p>举个例子，我们可能想要绘制一架大型飞机，然后在飞机上一个较小的但却与飞机在同一物理空间的图形，这叫做“贴花”；这个小的图形的深度值将会与原来飞机的深度缓冲区中的值相同，这将导致深度测试不可预料的通过或者失败，这种情况叫做z冲突；</p>\n<p>另外一种情况，我们想要在绘制的实心几何图形上突出它的边；以上这些z冲突的情况下，通常我们解决的办法是当深度值相同时，适当的对深度进行偏移而并不改变实际3D空间中的物理位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glPolygonOffset(GLfloat factor, GLfloat units);</span><br><span class=\"line\">//函数通过 Depth offset = (DZ * factor) + (r * units) 公式计算新的深度值；</span><br><span class=\"line\">//其中，DZ是深度值相对于多边形屏幕区域的变化量，r是使深度缓冲区值产生变化的最小值；</span><br></pre></td></tr></table></figure>\n<p>例子Primitives的<code>DrawWireFramedBatch</code>函数代码中展示了偏移的使用;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\"></span><br><span class=\"line\">### - 裁剪</span><br><span class=\"line\"></span><br><span class=\"line\">裁剪是将渲染限制在一个较小的矩形中，如要开启裁剪：</span><br><span class=\"line\"></span><br><span class=\"line\">`glEnalbe(GL_SCISSOR_TEST);`</span><br><span class=\"line\"></span><br><span class=\"line\">指定窗口：</span><br></pre></td></tr></table></figure>\n<p>void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);<br>//x,y指定裁剪框左下角，width height则指定宽度和高度<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">例子Scissor展示了该函数的用法:</span><br></pre></td></tr></table></figure></p>\n<pre><code>// Clear blue window\nglClearColor(0.0f, 0.0f, 1.0f, 0.0f);\nglClear(GL_COLOR_BUFFER_BIT);\n\n// Now set scissor to smaller red sub region\nglClearColor(1.0f, 0.0f, 0.0f, 0.0f);\nglScissor(100, 100, 600, 400);\nglEnable(GL_SCISSOR_TEST);\nglClear(GL_COLOR_BUFFER_BIT);\n\n// Finally, an even smaller green rectangle\nglClearColor(0.0f, 1.0f, 0.0f, 0.0f);\nglScissor(200, 200, 400, 200);\nglClear(GL_COLOR_BUFFER_BIT);\n\n// Turn scissor back off for next render\nglDisable(GL_SCISSOR_TEST);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### - 混合</span><br><span class=\"line\"></span><br><span class=\"line\">当深度值相同时，使用混合也可以使下层的颜色值不会被清除；开启混合使用：</span><br><span class=\"line\"></span><br><span class=\"line\">`glEnable(GL_BLEND);`</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 目标颜色：已经存储在颜色缓冲区中的颜色值；</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 源颜色：作为当前渲染命令的结果进入颜色缓冲区的颜色；</span><br><span class=\"line\"></span><br><span class=\"line\">混合功能开启后，目标颜色和源颜色的组合方式是由混合方程式控制的；</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; Cf = (Cs * S) + (Cd * D)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;Cf是最终计算产生的颜色，Cs是源颜色，Cd是目标颜色，S、D分别是源和目标混合因子；</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;注意Cs和Cd都是向量，以上进行的是向量乘法和加法；</span><br><span class=\"line\"></span><br><span class=\"line\">混合因子是用函数进行设置的：</span><br></pre></td></tr></table></figure>\n<p>glBlendFunc(GLenum S, GLenum D);<br>//S D都是枚举值，详细请自行google，这里给出枚举值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">混合方程式并不是唯一的，如需改变则：</span><br></pre></td></tr></table></figure></p>\n<p>void glBlendEquation(GLenum mode);</p>\n<p>GL_FUNC_ADD                        //Cf = (Cs <em> S) + (Cd </em> D)</p>\n<p>GL_FUNC_SUBTRACT                    //Cf = (Cs <em> S) - (Cd </em> D)</p>\n<p>GL_FUNC_REVDRSE_SUBTRACT        //Cf = (Cs <em> D) - (Cd </em> S)</p>\n<p>GL_MIN                                //Cf = min(Cs,Cd)</p>\n<p>GL_MAX                                //Cf = max(Cs,Cd)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">另外：</span><br><span class=\"line\"></span><br><span class=\"line\">`void glBlendFuncSeparate(GLenum srcRGB,GLenum dstRGB,GLenum srcAlpha,GLenum dstAlpha);`</span><br><span class=\"line\"></span><br><span class=\"line\">可以指定源和目标的RGB颜色与Alpha颜色不同的混合函数；</span><br><span class=\"line\"></span><br><span class=\"line\">`vodi glBlendColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);`</span><br><span class=\"line\"></span><br><span class=\"line\">可以指定混合一个常量混合颜色，初始为黑色（0,0,0,0）；</span><br><span class=\"line\"></span><br><span class=\"line\">### - 抗锯齿</span><br><span class=\"line\"></span><br><span class=\"line\">由于像素是正方形的，混合时通常可以相当清楚地看到两种颜色的分界，它们常常被称为锯齿，为了消除锯齿，使用混合功能并开启锯齿，使边缘变得平滑；具体使用方法如下代码：</span><br></pre></td></tr></table></figure></p>\n<pre><code> switch(value)\n{\ncase 1:\n    // 打开抗锯齿，并给出关于尽可能进行最佳的处理的提示\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_BLEND);\n    glEnable(GL_POINT_SMOOTH);\n    glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n    glEnable(GL_LINE_SMOOTH);\n    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);\n    glEnable(GL_POLYGON_SMOOTH);\n    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);\n    break;\n\ncase 2:\n    // 关闭混合和所有的平滑处理\n      glDisable(GL_BLEND);\n    glDisable(GL_LINE_SMOOTH);\n    glDisable(GL_POINT_SMOOTH);\n    break;\n\ndefault:\n    break;\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`glEnable(GL_POINT_SMOOTH);`就是开启抗锯齿；</span><br><span class=\"line\"></span><br><span class=\"line\">`glHint(GLenum target, GLenum mode)`函数中target参数指定希望进行修改的行为类型，mode参数告诉OpenGL我们最关心的是什么，或渲染速度或输出质量；该函数是gl唯一一个行为完全依赖生产商的函数，总结呢是跟渲染的性能有关的函数，具体情况具体分析吧，这种函数一般很难实际看出效果；</span><br><span class=\"line\"></span><br><span class=\"line\">### -多重采样</span><br><span class=\"line\"></span><br><span class=\"line\">最后讲一下多重采样，上边讲到的平滑处理在点和直线上是广泛支持的，但是多边形的平滑处理并没有在所有平台上都得到实现，然而在`GL_POLYGON_SMOOTH`时，由于抗锯齿处理是基于混合操作的，需要对从前到后所有图元进行排序，这显然相当麻烦，使用多重采样可以解决这个问题；</span><br><span class=\"line\"></span><br><span class=\"line\">多重采样时，当某一点上的像素进行更新时，gl会在一个缓冲区内对该像素上的值进行采样，结果会通过采样值产生一个单独的值，这可能对性能造成一定的影响；</span><br><span class=\"line\"></span><br><span class=\"line\">打开多重采样：</span><br><span class=\"line\"></span><br><span class=\"line\">`glEnable(GL_MULTISAMPLE);`</span><br><span class=\"line\"></span><br><span class=\"line\">值得注意的一点是，当启用多重采样时，点、直线和多边形的平滑特性会被忽略；</span><br><span class=\"line\"></span><br><span class=\"line\">多重采样的采样值是会被保存在一个单独的缓存区内的，如果没有多重采样缓存区，OpenGL就当作该功能是被禁用的；</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;状态排序</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;打开或关闭不同的OpenGL特性将会修改驱动程序的内部状态，这种状态的改变可能会对渲染的性能造成影响。对性能非常敏感的程序员常常会不辞辛苦地对所有绘图命令进行排序，这样需要相同状态的几何图形就可以在一起绘制。这种状态排序是在游戏中常用的提高速度的方法之一。</span><br><span class=\"line\"></span><br><span class=\"line\">多重采样缓和区在默认情况下使用片断的RGB值，并不包括颜色的alpha成分；我们可以调用`glEnable`来修改这个行为</span><br></pre></td></tr></table></figure>\n<p>GL_SAMPLE_ALPHA_TO_COVERAGE            //使用alpha值</p>\n<p>GL_SAMPLE_ALPHA_TO_ON                    //将alpha值设为1并使用它</p>\n<p>GL_SAMPLE_COVERAGE                        //使用glSampleCoverage设置的值<br><code>`</code></p>\n<p><code>void glSampleCoverage(GLclampf value, GLboolean invert);</code>函数允许指定一个特定的值，它是与片断覆盖值进行按位与操作的结果；</p>"},{"title":"OpenGL-纹理的初步应用","date":"2016-08-05T17:30:00.000Z","_content":"\nSummary:说到纹理，通俗的讲就是我们不用再自己去画图啦，用一些装有信息格式的文件去实现画图，这将为我们带来一个更加清新的展示效果。在纹理中涉及到许多概念也是需要我们去理解的，理解的部分我无法为你们完成，概念的部分我尽量写出自己的理解。希望可以帮到看本博客的同学。\n<!-- more -->\n\n\n[本文例子查看地址](https://github.com/usiege/OpenGL_S/tree/master/OpenGL_05_%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/BaseTexture)，本例中展示了读取tag文件并加载纹理生成图像，mac用户可以把例子下下来看看效果。\n\n## 纹理坐标自描述\n\n典型情况下，纹理坐标是作为0.0到1.0范围内的浮点值指定的，坐标命名为s,t,r,q，分别对应顶点坐标的x,y,z,w；自己理解下就是纹理会被先加载到一个各边都视为单位1的坐标系下，然后再将这样的坐标系映射到真实的屏幕坐标系里，因为每个坐标系上的全长都是单位一，那么根据在第边上的比例即可计算纹理的真实像素。而且若三个坐标系的单位一不相同的情况下，得到的结果也不会是一个正方体，所以真实的纹理计算过程会进行拉伸或收缩。\n\n## 读取像素\n\nTarga图像格式是一种方便且容易使用的图片格式，先贴上一个函数，该函数详细介绍了tga文件的加载过程：\n\n```\n/*自定义tga图片头信息结构*/\n#pragma pack(1)//结构体字节对齐\ntypedef struct\n{\n    GLbyte  identsize;              // Size of ID field that follows header (0)\n    GLbyte  colorMapType;           // 0 = None, 1 = paletted\n    GLbyte  imageType;              // 0 = none, 1 = indexed, 2 = rgb, 3 = grey, +8=rle\n    unsigned short  colorMapStart;          // First colour map entry\n    unsigned short  colorMapLength;         // Number of colors\n    unsigned char   colorMapBits;   // bits per palette entry\n    unsigned short  xstart;                 // image x origin\n    unsigned short  ystart;                 // image y origin\n    unsigned short  width;                  // width in pixels\n    unsigned short  height;                 // height in pixels\n    GLbyte  bits;                   // bits per pixel (8 16, 24, 32)\n    GLbyte  descriptor;             // image descriptor\n} TGAHEADER;\n#pragma pack(8)\n\n\n/*tga图片读取*/\n//进行内存定位并载入targa位，返回指向新的缓冲区指针，纹理高宽，以及OpenGL数据格式\n//注：只支持targa,只能是8位、24位或32位色，没有调色板和RLE编码（这部分没看懂，应该是跟图像格式有关的）\nGLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat)\n{\n    FILE *pFile;            // File pointer\n    TGAHEADER tgaHeader;        // TGA file header\n    unsigned long lImageSize;       // Size in bytes of image\n    short sDepth;           // Pixel depth;\n    GLbyte  *pBits = NULL;          // Pointer to bits\n    \n    //默认或失败值\n    *iWidth = 0;\n    *iHeight = 0;\n    *eFormat = GL_RGB;\n    *iComponents = GL_RGB;\n    \n    //尝试打开文件\n    pFile = fopen(szFileName, \"rb\");\n    if(pFile == NULL)\n        return NULL;\n    \n    // 读入文件头（二进制）\n    fread(&tgaHeader, 18/* sizeof(TGAHEADER)*/, 1, pFile);\n    \n    // 为大小字节存储顺序问题而进行字节交换，这里有大神给解释下吗？\n//#ifdef __APPLE__\n//    LITTLE_ENDIAN_WORD(&tgaHeader.colorMapStart);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.colorMapLength);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.xstart);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.ystart);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.width);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.height);\n//#endif\n    \n    // 获取纹理宽，高，深度\n    *iWidth = tgaHeader.width;\n    *iHeight = tgaHeader.height;\n    sDepth = tgaHeader.bits / 8;\n    \n    //进行有效性检验，我们需要关心8位、24位或32位\n    if(tgaHeader.bits != 8 && tgaHeader.bits != 24 && tgaHeader.bits != 32)\n        return NULL;\n    \n    // 计算图像缓冲区大小\n    lImageSize = tgaHeader.width * tgaHeader.height * sDepth;\n    \n    // 内存定位和成功检验\n    pBits = (GLbyte*)malloc(lImageSize * sizeof(GLbyte));\n    if(pBits == NULL)\n        return NULL;\n    \n    // 读入位\n    // 检查读取错误，这项操作应该发现RLE或者其他我们不想识别的格式\n    // RLE:一种压缩过的位图文件格式，RLE压缩方案是一种极其成熟的压缩方案，\n    // 特点是无损失压缩，既节省了磁盘空间又不损失任何图像数据;\n    if(fread(pBits, lImageSize, 1, pFile) != 1)\n    {\n        free(pBits);\n        return NULL;\n    }\n    \n    // 设置希望的OpenGL格式\n    switch(sDepth)\n    {\n#ifndef OPENGL_ES\n        case 3:     // Most likely case\n            *eFormat = GL_BGR;\n            *iComponents = GL_RGB;\n            break;\n#endif\n        case 4:\n            *eFormat = GL_BGRA;\n            *iComponents = GL_RGBA;\n            break;\n        case 1:\n            *eFormat = GL_LUMINANCE;\n            *iComponents = GL_LUMINANCE;\n            break;\n        default:        // RGB\n            //如果是在iPhone上，TGA为BGR，并且iPhone不支持没有alpha的BGR\n            //iPhone支持RGB，所以只要将红色和蓝色调整一下就能符合要求\n            //但是为了加快iPhone的载入速度，请保存带有alpha的TGA\n#ifdef OPENGL_ES\n            for(int i = 0; i < lImageSize; i+=3)\n            {\n                GLbyte temp = pBits[i];\n                pBits[i] = pBits[i+2];\n                pBits[i+2] = temp;\n            }\n#endif\n            break;\n    }\n\n    // 文件结束\n    fclose(pFile);\n    \n    // 返回指向图像的指针\n    return pBits;\n}\n\n```\n\n函数`gltReadTGABits`是自定义读取函数，大致的过程就是打开一个tga文件，然后以二进制的形式读取出来，进而对外部指针width等做修改，所以该函数返回了像素的宽高等的一些信息。\n\n## 载入纹理\n\n接下来载入缓冲区内的纹理：\n\n```\nbool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)\n{\n\tGLbyte *pBits;\n\tint nWidth, nHeight, nComponents;\n\tGLenum eFormat;\n\t\n\t// Read the texture bits\n\tpBits = gltReadTGABits(szFileName, &nWidth, &nHeight, &nComponents, &eFormat);\n\tif(pBits == NULL)\n\t\treturn false;\n\t\n    //纹理环绕\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);\n\t\n    //纹理过滤（邻近过滤和线性过滤）\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);\n    \n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\tglTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0,\n\t\t\t\t eFormat, GL_UNSIGNED_BYTE, pBits);\n\t\n    free(pBits);\n    \n    if(minFilter == GL_LINEAR_MIPMAP_LINEAR || \n       minFilter == GL_LINEAR_MIPMAP_NEAREST ||\n       minFilter == GL_NEAREST_MIPMAP_LINEAR ||\n       minFilter == GL_NEAREST_MIPMAP_NEAREST)\n        glGenerateMipmap(GL_TEXTURE_2D);\n    \n\treturn true;\n}\n```\n\n### `glTexParameteri`\n\nOpenGL在拉伸和收缩时对纹理贴图计算颜色片段的过程称为纹理过滤；纹理坐标总是根据纹理图像的纹理单元进行求值和绘图；使用上面这个函数设置放大和缩小的过滤模式：\n\n```\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n`GL_LINEAR`,是线性过滤，把纹理坐标周围的的纹理单元的加权平均值应用到纹理坐标上，这可以需要一些额外的开销；\n\n`GL_NEAREST`是最邻近过滤，把最邻近的纹理单元应用到纹理坐标中，它我们能选择的最简单、最快速的过滤方法；\n\n\n\n前面说到纹理坐标坐落在一个0.0到1.0的范围内，当超过了范围，OpenGL使用这个函数处理纹理环绕模式；\n\n`GL_REPEAT`模式下OpenGL在纹理坐标值超过1.0的方向上进行重复；\n\n`GL_CLAMP`所需的纹理单元取自纹理边界或`TEXTURE_BORDER_COLOR`(glTexParameterfv函数设置的值)；\n\n`GL_CLAMP_TO_EDGE`强制对范围外的纹理坐标沿着合法的纹理坐标的最后一行或一列进行渲染；\n\n`GL_CLAMP_TO_BORDER`范围之外的纹理坐标使用边界纹理单元；\n\n注：在`GL_NEAREST`模式下过滤模式并不起作用，因为纹理坐标总是对齐到纹理贴图中的一些特定的纹理单元；\n\n\n### `glPixelStorei`\n\n`GL_UNPACK_ALIGNMENT`指定OpenGL如何从数据缓冲区中解包图像数据；关于这个函数我们暂时只说明这一点；这似乎跟OpenGL对像素的内存分配有关；\n\n### `glTexImage2D`\n\n函数原型：\n\n```\nglTexImage2D(GLenum target, GLint level, GLint internalformat, \n\t\t\t\tGLsizei width, GLsizei height, GLsizei depth, GLint border,\n\t\t\t\tGLeunm format, GLeunm type,void* data);\n```\n\n函数比较长，参数讲解：\n\ntarget变量分别是`GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`,这里我们选择`GL_TEXTURE_2D`；该函数之后会有详细说明；\n\nlevel指定了加载的mip贴图层次（你说你不知道mip贴图是什么，下次我们会讲，这里你理解成你们家铺地的瓷砖就好了）；\n\n我们必须指定纹理数据的internalformat，这个信息告诉我们希望在每个纹理中存储多少颜色成分，并在可能的情况下说明这些成分的存储大小，以及是否希望对纹理进行压缩；竟然一个参数有这么多作用，具体参数列表为：\n\n| 常量              | 含义           |\n| ------------- |:-------------:| -----:|\n| GL_ALPHA              |按照alpha值存储纹理单元|\n| GL_LUMINANCE(亮度)     |按照亮度值存储纹理单元|\n| GL_LUMINANCE_ALPHA    |按照亮度值和alpha值存储纹理单元|\n| GL_RGB                |按照红、绿、蓝成分存储纹理单元|\n| GL_RGBA               |按照红、绿、蓝和alpha成分存储纹理单元|\n\nwidth,height,depth指定了被加载纹理的宽、高和深，这些值必须是2的整数次方，这一点非常重要；纹理贴图并不要求是立方体，但是一个纹理在加载时如果使用了非2的整数次幂值，将会导致纹理贴图被禁用，意思就是你什么也显示不出来；\n\nborder允许我们为纹理贴图指定一个边界宽度；\n\nformat,type,data详见`glReadPixels()`函数中对应的解释；\n\n### `glReadPixels`\n\n```\nglReadPixels(GLint x,GLint y,GLSizei width,GLSizei height,\nGLenum format,GLeunm type,const void* pixels);\n```\n\nOpenGL提供了简洁的函数来操作像素：\n\n\nglReadPixels：读取一些像素。当前可以简单理解为“把已经绘制好的像素（它可能已经被保存到显卡的显存中）读取到内存”。\n\n\nglDrawPixels：绘制一些像素。当前可以简单理解为“把内存中一些数据作为像素数据，进行绘制”。\n\n\nglCopyPixels：复制一些像素。当前可以简单理解为“把已经绘制好的像素从一个位置复制到另一个位置”。虽然从功能上看，好象等价于先读取像素再绘制像素，但实际上它不需要把已经绘制的像素（它可能已经被保存到显卡的显存中）转换为内存数据，然后再由内存数据进行重新的绘制，所以要比先读取后绘制快很多。\n这三个函数可以完成简单的像素读取、绘制和复制任务，但实际上也可以完成更复杂的任务。\n\n该函数总共有七个参数。前四个参数可以得到一个矩形，该矩形所包括的像素都会被读取出来；（第一、二个参数表示了矩形的左下角横、纵坐标，坐标以窗口最左下角为零，最右上角为最大值；第三、四个参数表示了矩形的宽度和高度）\n\n\n第五个参数表示读取的内容，例如：GL_RGB就会依次读取像素的红、绿、蓝三种数据，GL_RGBA则会依次读取像素的红、绿、蓝、alpha四种数据，GL_RED则只读取像素的红色数据（类似的还有GL_GREEN，GL_BLUE，以及GL_ALPHA）。如果采用的不是RGBA颜色模式，而是采用颜色索引模式，则也可以使用GL_COLOR_INDEX来读取像素的颜色索引。目前仅需要知道这些，但实际上还可以读取其它内容，例如深度缓冲区的深度数据等；\n\n\n第六个参数表示读取的内容保存到内存时所使用的格式，例如：GL_UNSIGNED_BYTE会把各种数据保存为GLubyte，GL_FLOAT会把各种数据保存为GLfloat等。\n\n\n第七个参数表示一个指针，像素数据被读取后，将被保存到这个指针所表示的地址。注意，需要保证该地址有足够的可以使用的空间，以容纳读取的像素数据。例如一幅大小为256*256的图象，如果读取其RGB数据，且每一数据被保存为GLubyte，总大小就是：256*256*3 = 196608字节，即192千字节。如果是读取RGBA数据，则总大小就是256*256*4 = 262144字节，即256千字节。\n注意：glReadPixels实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲。\n\n本篇就先到这里吧，本人要下班了。\n\n","source":"_posts/OpenGL-纹理的初步应用.md","raw":"title: OpenGL-纹理的初步应用\ndate: 2016-08-06 01:30:00\ncategories: coder\ntags: [opengl, texture]\n-----------\n\nSummary:说到纹理，通俗的讲就是我们不用再自己去画图啦，用一些装有信息格式的文件去实现画图，这将为我们带来一个更加清新的展示效果。在纹理中涉及到许多概念也是需要我们去理解的，理解的部分我无法为你们完成，概念的部分我尽量写出自己的理解。希望可以帮到看本博客的同学。\n<!-- more -->\n\n\n[本文例子查看地址](https://github.com/usiege/OpenGL_S/tree/master/OpenGL_05_%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/BaseTexture)，本例中展示了读取tag文件并加载纹理生成图像，mac用户可以把例子下下来看看效果。\n\n## 纹理坐标自描述\n\n典型情况下，纹理坐标是作为0.0到1.0范围内的浮点值指定的，坐标命名为s,t,r,q，分别对应顶点坐标的x,y,z,w；自己理解下就是纹理会被先加载到一个各边都视为单位1的坐标系下，然后再将这样的坐标系映射到真实的屏幕坐标系里，因为每个坐标系上的全长都是单位一，那么根据在第边上的比例即可计算纹理的真实像素。而且若三个坐标系的单位一不相同的情况下，得到的结果也不会是一个正方体，所以真实的纹理计算过程会进行拉伸或收缩。\n\n## 读取像素\n\nTarga图像格式是一种方便且容易使用的图片格式，先贴上一个函数，该函数详细介绍了tga文件的加载过程：\n\n```\n/*自定义tga图片头信息结构*/\n#pragma pack(1)//结构体字节对齐\ntypedef struct\n{\n    GLbyte  identsize;              // Size of ID field that follows header (0)\n    GLbyte  colorMapType;           // 0 = None, 1 = paletted\n    GLbyte  imageType;              // 0 = none, 1 = indexed, 2 = rgb, 3 = grey, +8=rle\n    unsigned short  colorMapStart;          // First colour map entry\n    unsigned short  colorMapLength;         // Number of colors\n    unsigned char   colorMapBits;   // bits per palette entry\n    unsigned short  xstart;                 // image x origin\n    unsigned short  ystart;                 // image y origin\n    unsigned short  width;                  // width in pixels\n    unsigned short  height;                 // height in pixels\n    GLbyte  bits;                   // bits per pixel (8 16, 24, 32)\n    GLbyte  descriptor;             // image descriptor\n} TGAHEADER;\n#pragma pack(8)\n\n\n/*tga图片读取*/\n//进行内存定位并载入targa位，返回指向新的缓冲区指针，纹理高宽，以及OpenGL数据格式\n//注：只支持targa,只能是8位、24位或32位色，没有调色板和RLE编码（这部分没看懂，应该是跟图像格式有关的）\nGLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat)\n{\n    FILE *pFile;            // File pointer\n    TGAHEADER tgaHeader;        // TGA file header\n    unsigned long lImageSize;       // Size in bytes of image\n    short sDepth;           // Pixel depth;\n    GLbyte  *pBits = NULL;          // Pointer to bits\n    \n    //默认或失败值\n    *iWidth = 0;\n    *iHeight = 0;\n    *eFormat = GL_RGB;\n    *iComponents = GL_RGB;\n    \n    //尝试打开文件\n    pFile = fopen(szFileName, \"rb\");\n    if(pFile == NULL)\n        return NULL;\n    \n    // 读入文件头（二进制）\n    fread(&tgaHeader, 18/* sizeof(TGAHEADER)*/, 1, pFile);\n    \n    // 为大小字节存储顺序问题而进行字节交换，这里有大神给解释下吗？\n//#ifdef __APPLE__\n//    LITTLE_ENDIAN_WORD(&tgaHeader.colorMapStart);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.colorMapLength);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.xstart);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.ystart);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.width);\n//    LITTLE_ENDIAN_WORD(&tgaHeader.height);\n//#endif\n    \n    // 获取纹理宽，高，深度\n    *iWidth = tgaHeader.width;\n    *iHeight = tgaHeader.height;\n    sDepth = tgaHeader.bits / 8;\n    \n    //进行有效性检验，我们需要关心8位、24位或32位\n    if(tgaHeader.bits != 8 && tgaHeader.bits != 24 && tgaHeader.bits != 32)\n        return NULL;\n    \n    // 计算图像缓冲区大小\n    lImageSize = tgaHeader.width * tgaHeader.height * sDepth;\n    \n    // 内存定位和成功检验\n    pBits = (GLbyte*)malloc(lImageSize * sizeof(GLbyte));\n    if(pBits == NULL)\n        return NULL;\n    \n    // 读入位\n    // 检查读取错误，这项操作应该发现RLE或者其他我们不想识别的格式\n    // RLE:一种压缩过的位图文件格式，RLE压缩方案是一种极其成熟的压缩方案，\n    // 特点是无损失压缩，既节省了磁盘空间又不损失任何图像数据;\n    if(fread(pBits, lImageSize, 1, pFile) != 1)\n    {\n        free(pBits);\n        return NULL;\n    }\n    \n    // 设置希望的OpenGL格式\n    switch(sDepth)\n    {\n#ifndef OPENGL_ES\n        case 3:     // Most likely case\n            *eFormat = GL_BGR;\n            *iComponents = GL_RGB;\n            break;\n#endif\n        case 4:\n            *eFormat = GL_BGRA;\n            *iComponents = GL_RGBA;\n            break;\n        case 1:\n            *eFormat = GL_LUMINANCE;\n            *iComponents = GL_LUMINANCE;\n            break;\n        default:        // RGB\n            //如果是在iPhone上，TGA为BGR，并且iPhone不支持没有alpha的BGR\n            //iPhone支持RGB，所以只要将红色和蓝色调整一下就能符合要求\n            //但是为了加快iPhone的载入速度，请保存带有alpha的TGA\n#ifdef OPENGL_ES\n            for(int i = 0; i < lImageSize; i+=3)\n            {\n                GLbyte temp = pBits[i];\n                pBits[i] = pBits[i+2];\n                pBits[i+2] = temp;\n            }\n#endif\n            break;\n    }\n\n    // 文件结束\n    fclose(pFile);\n    \n    // 返回指向图像的指针\n    return pBits;\n}\n\n```\n\n函数`gltReadTGABits`是自定义读取函数，大致的过程就是打开一个tga文件，然后以二进制的形式读取出来，进而对外部指针width等做修改，所以该函数返回了像素的宽高等的一些信息。\n\n## 载入纹理\n\n接下来载入缓冲区内的纹理：\n\n```\nbool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)\n{\n\tGLbyte *pBits;\n\tint nWidth, nHeight, nComponents;\n\tGLenum eFormat;\n\t\n\t// Read the texture bits\n\tpBits = gltReadTGABits(szFileName, &nWidth, &nHeight, &nComponents, &eFormat);\n\tif(pBits == NULL)\n\t\treturn false;\n\t\n    //纹理环绕\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);\n\t\n    //纹理过滤（邻近过滤和线性过滤）\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);\n    \n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\tglTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0,\n\t\t\t\t eFormat, GL_UNSIGNED_BYTE, pBits);\n\t\n    free(pBits);\n    \n    if(minFilter == GL_LINEAR_MIPMAP_LINEAR || \n       minFilter == GL_LINEAR_MIPMAP_NEAREST ||\n       minFilter == GL_NEAREST_MIPMAP_LINEAR ||\n       minFilter == GL_NEAREST_MIPMAP_NEAREST)\n        glGenerateMipmap(GL_TEXTURE_2D);\n    \n\treturn true;\n}\n```\n\n### `glTexParameteri`\n\nOpenGL在拉伸和收缩时对纹理贴图计算颜色片段的过程称为纹理过滤；纹理坐标总是根据纹理图像的纹理单元进行求值和绘图；使用上面这个函数设置放大和缩小的过滤模式：\n\n```\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n`GL_LINEAR`,是线性过滤，把纹理坐标周围的的纹理单元的加权平均值应用到纹理坐标上，这可以需要一些额外的开销；\n\n`GL_NEAREST`是最邻近过滤，把最邻近的纹理单元应用到纹理坐标中，它我们能选择的最简单、最快速的过滤方法；\n\n\n\n前面说到纹理坐标坐落在一个0.0到1.0的范围内，当超过了范围，OpenGL使用这个函数处理纹理环绕模式；\n\n`GL_REPEAT`模式下OpenGL在纹理坐标值超过1.0的方向上进行重复；\n\n`GL_CLAMP`所需的纹理单元取自纹理边界或`TEXTURE_BORDER_COLOR`(glTexParameterfv函数设置的值)；\n\n`GL_CLAMP_TO_EDGE`强制对范围外的纹理坐标沿着合法的纹理坐标的最后一行或一列进行渲染；\n\n`GL_CLAMP_TO_BORDER`范围之外的纹理坐标使用边界纹理单元；\n\n注：在`GL_NEAREST`模式下过滤模式并不起作用，因为纹理坐标总是对齐到纹理贴图中的一些特定的纹理单元；\n\n\n### `glPixelStorei`\n\n`GL_UNPACK_ALIGNMENT`指定OpenGL如何从数据缓冲区中解包图像数据；关于这个函数我们暂时只说明这一点；这似乎跟OpenGL对像素的内存分配有关；\n\n### `glTexImage2D`\n\n函数原型：\n\n```\nglTexImage2D(GLenum target, GLint level, GLint internalformat, \n\t\t\t\tGLsizei width, GLsizei height, GLsizei depth, GLint border,\n\t\t\t\tGLeunm format, GLeunm type,void* data);\n```\n\n函数比较长，参数讲解：\n\ntarget变量分别是`GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`,这里我们选择`GL_TEXTURE_2D`；该函数之后会有详细说明；\n\nlevel指定了加载的mip贴图层次（你说你不知道mip贴图是什么，下次我们会讲，这里你理解成你们家铺地的瓷砖就好了）；\n\n我们必须指定纹理数据的internalformat，这个信息告诉我们希望在每个纹理中存储多少颜色成分，并在可能的情况下说明这些成分的存储大小，以及是否希望对纹理进行压缩；竟然一个参数有这么多作用，具体参数列表为：\n\n| 常量              | 含义           |\n| ------------- |:-------------:| -----:|\n| GL_ALPHA              |按照alpha值存储纹理单元|\n| GL_LUMINANCE(亮度)     |按照亮度值存储纹理单元|\n| GL_LUMINANCE_ALPHA    |按照亮度值和alpha值存储纹理单元|\n| GL_RGB                |按照红、绿、蓝成分存储纹理单元|\n| GL_RGBA               |按照红、绿、蓝和alpha成分存储纹理单元|\n\nwidth,height,depth指定了被加载纹理的宽、高和深，这些值必须是2的整数次方，这一点非常重要；纹理贴图并不要求是立方体，但是一个纹理在加载时如果使用了非2的整数次幂值，将会导致纹理贴图被禁用，意思就是你什么也显示不出来；\n\nborder允许我们为纹理贴图指定一个边界宽度；\n\nformat,type,data详见`glReadPixels()`函数中对应的解释；\n\n### `glReadPixels`\n\n```\nglReadPixels(GLint x,GLint y,GLSizei width,GLSizei height,\nGLenum format,GLeunm type,const void* pixels);\n```\n\nOpenGL提供了简洁的函数来操作像素：\n\n\nglReadPixels：读取一些像素。当前可以简单理解为“把已经绘制好的像素（它可能已经被保存到显卡的显存中）读取到内存”。\n\n\nglDrawPixels：绘制一些像素。当前可以简单理解为“把内存中一些数据作为像素数据，进行绘制”。\n\n\nglCopyPixels：复制一些像素。当前可以简单理解为“把已经绘制好的像素从一个位置复制到另一个位置”。虽然从功能上看，好象等价于先读取像素再绘制像素，但实际上它不需要把已经绘制的像素（它可能已经被保存到显卡的显存中）转换为内存数据，然后再由内存数据进行重新的绘制，所以要比先读取后绘制快很多。\n这三个函数可以完成简单的像素读取、绘制和复制任务，但实际上也可以完成更复杂的任务。\n\n该函数总共有七个参数。前四个参数可以得到一个矩形，该矩形所包括的像素都会被读取出来；（第一、二个参数表示了矩形的左下角横、纵坐标，坐标以窗口最左下角为零，最右上角为最大值；第三、四个参数表示了矩形的宽度和高度）\n\n\n第五个参数表示读取的内容，例如：GL_RGB就会依次读取像素的红、绿、蓝三种数据，GL_RGBA则会依次读取像素的红、绿、蓝、alpha四种数据，GL_RED则只读取像素的红色数据（类似的还有GL_GREEN，GL_BLUE，以及GL_ALPHA）。如果采用的不是RGBA颜色模式，而是采用颜色索引模式，则也可以使用GL_COLOR_INDEX来读取像素的颜色索引。目前仅需要知道这些，但实际上还可以读取其它内容，例如深度缓冲区的深度数据等；\n\n\n第六个参数表示读取的内容保存到内存时所使用的格式，例如：GL_UNSIGNED_BYTE会把各种数据保存为GLubyte，GL_FLOAT会把各种数据保存为GLfloat等。\n\n\n第七个参数表示一个指针，像素数据被读取后，将被保存到这个指针所表示的地址。注意，需要保证该地址有足够的可以使用的空间，以容纳读取的像素数据。例如一幅大小为256*256的图象，如果读取其RGB数据，且每一数据被保存为GLubyte，总大小就是：256*256*3 = 196608字节，即192千字节。如果是读取RGBA数据，则总大小就是256*256*4 = 262144字节，即256千字节。\n注意：glReadPixels实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲。\n\n本篇就先到这里吧，本人要下班了。\n\n","slug":"OpenGL-纹理的初步应用","published":1,"updated":"2018-05-04T10:26:54.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucio4000o1v60iw11n1r7","content":"<p>Summary:说到纹理，通俗的讲就是我们不用再自己去画图啦，用一些装有信息格式的文件去实现画图，这将为我们带来一个更加清新的展示效果。在纹理中涉及到许多概念也是需要我们去理解的，理解的部分我无法为你们完成，概念的部分我尽量写出自己的理解。希望可以帮到看本博客的同学。<br><a id=\"more\"></a></p>\n<p><a href=\"https://github.com/usiege/OpenGL_S/tree/master/OpenGL_05_%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/BaseTexture\" target=\"_blank\" rel=\"noopener\">本文例子查看地址</a>，本例中展示了读取tag文件并加载纹理生成图像，mac用户可以把例子下下来看看效果。</p>\n<h2 id=\"纹理坐标自描述\"><a href=\"#纹理坐标自描述\" class=\"headerlink\" title=\"纹理坐标自描述\"></a>纹理坐标自描述</h2><p>典型情况下，纹理坐标是作为0.0到1.0范围内的浮点值指定的，坐标命名为s,t,r,q，分别对应顶点坐标的x,y,z,w；自己理解下就是纹理会被先加载到一个各边都视为单位1的坐标系下，然后再将这样的坐标系映射到真实的屏幕坐标系里，因为每个坐标系上的全长都是单位一，那么根据在第边上的比例即可计算纹理的真实像素。而且若三个坐标系的单位一不相同的情况下，得到的结果也不会是一个正方体，所以真实的纹理计算过程会进行拉伸或收缩。</p>\n<h2 id=\"读取像素\"><a href=\"#读取像素\" class=\"headerlink\" title=\"读取像素\"></a>读取像素</h2><p>Targa图像格式是一种方便且容易使用的图片格式，先贴上一个函数，该函数详细介绍了tga文件的加载过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*自定义tga图片头信息结构*/</span><br><span class=\"line\">#pragma pack(1)//结构体字节对齐</span><br><span class=\"line\">typedef struct</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GLbyte  identsize;              // Size of ID field that follows header (0)</span><br><span class=\"line\">    GLbyte  colorMapType;           // 0 = None, 1 = paletted</span><br><span class=\"line\">    GLbyte  imageType;              // 0 = none, 1 = indexed, 2 = rgb, 3 = grey, +8=rle</span><br><span class=\"line\">    unsigned short  colorMapStart;          // First colour map entry</span><br><span class=\"line\">    unsigned short  colorMapLength;         // Number of colors</span><br><span class=\"line\">    unsigned char   colorMapBits;   // bits per palette entry</span><br><span class=\"line\">    unsigned short  xstart;                 // image x origin</span><br><span class=\"line\">    unsigned short  ystart;                 // image y origin</span><br><span class=\"line\">    unsigned short  width;                  // width in pixels</span><br><span class=\"line\">    unsigned short  height;                 // height in pixels</span><br><span class=\"line\">    GLbyte  bits;                   // bits per pixel (8 16, 24, 32)</span><br><span class=\"line\">    GLbyte  descriptor;             // image descriptor</span><br><span class=\"line\">&#125; TGAHEADER;</span><br><span class=\"line\">#pragma pack(8)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*tga图片读取*/</span><br><span class=\"line\">//进行内存定位并载入targa位，返回指向新的缓冲区指针，纹理高宽，以及OpenGL数据格式</span><br><span class=\"line\">//注：只支持targa,只能是8位、24位或32位色，没有调色板和RLE编码（这部分没看懂，应该是跟图像格式有关的）</span><br><span class=\"line\">GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE *pFile;            // File pointer</span><br><span class=\"line\">    TGAHEADER tgaHeader;        // TGA file header</span><br><span class=\"line\">    unsigned long lImageSize;       // Size in bytes of image</span><br><span class=\"line\">    short sDepth;           // Pixel depth;</span><br><span class=\"line\">    GLbyte  *pBits = NULL;          // Pointer to bits</span><br><span class=\"line\">    </span><br><span class=\"line\">    //默认或失败值</span><br><span class=\"line\">    *iWidth = 0;</span><br><span class=\"line\">    *iHeight = 0;</span><br><span class=\"line\">    *eFormat = GL_RGB;</span><br><span class=\"line\">    *iComponents = GL_RGB;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //尝试打开文件</span><br><span class=\"line\">    pFile = fopen(szFileName, &quot;rb&quot;);</span><br><span class=\"line\">    if(pFile == NULL)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读入文件头（二进制）</span><br><span class=\"line\">    fread(&amp;tgaHeader, 18/* sizeof(TGAHEADER)*/, 1, pFile);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 为大小字节存储顺序问题而进行字节交换，这里有大神给解释下吗？</span><br><span class=\"line\">//#ifdef __APPLE__</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapStart);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapLength);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.xstart);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.ystart);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.width);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.height);</span><br><span class=\"line\">//#endif</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取纹理宽，高，深度</span><br><span class=\"line\">    *iWidth = tgaHeader.width;</span><br><span class=\"line\">    *iHeight = tgaHeader.height;</span><br><span class=\"line\">    sDepth = tgaHeader.bits / 8;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //进行有效性检验，我们需要关心8位、24位或32位</span><br><span class=\"line\">    if(tgaHeader.bits != 8 &amp;&amp; tgaHeader.bits != 24 &amp;&amp; tgaHeader.bits != 32)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 计算图像缓冲区大小</span><br><span class=\"line\">    lImageSize = tgaHeader.width * tgaHeader.height * sDepth;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 内存定位和成功检验</span><br><span class=\"line\">    pBits = (GLbyte*)malloc(lImageSize * sizeof(GLbyte));</span><br><span class=\"line\">    if(pBits == NULL)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读入位</span><br><span class=\"line\">    // 检查读取错误，这项操作应该发现RLE或者其他我们不想识别的格式</span><br><span class=\"line\">    // RLE:一种压缩过的位图文件格式，RLE压缩方案是一种极其成熟的压缩方案，</span><br><span class=\"line\">    // 特点是无损失压缩，既节省了磁盘空间又不损失任何图像数据;</span><br><span class=\"line\">    if(fread(pBits, lImageSize, 1, pFile) != 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        free(pBits);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置希望的OpenGL格式</span><br><span class=\"line\">    switch(sDepth)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#ifndef OPENGL_ES</span><br><span class=\"line\">        case 3:     // Most likely case</span><br><span class=\"line\">            *eFormat = GL_BGR;</span><br><span class=\"line\">            *iComponents = GL_RGB;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">            *eFormat = GL_BGRA;</span><br><span class=\"line\">            *iComponents = GL_RGBA;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            *eFormat = GL_LUMINANCE;</span><br><span class=\"line\">            *iComponents = GL_LUMINANCE;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:        // RGB</span><br><span class=\"line\">            //如果是在iPhone上，TGA为BGR，并且iPhone不支持没有alpha的BGR</span><br><span class=\"line\">            //iPhone支持RGB，所以只要将红色和蓝色调整一下就能符合要求</span><br><span class=\"line\">            //但是为了加快iPhone的载入速度，请保存带有alpha的TGA</span><br><span class=\"line\">#ifdef OPENGL_ES</span><br><span class=\"line\">            for(int i = 0; i &lt; lImageSize; i+=3)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                GLbyte temp = pBits[i];</span><br><span class=\"line\">                pBits[i] = pBits[i+2];</span><br><span class=\"line\">                pBits[i+2] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 文件结束</span><br><span class=\"line\">    fclose(pFile);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回指向图像的指针</span><br><span class=\"line\">    return pBits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数<code>gltReadTGABits</code>是自定义读取函数，大致的过程就是打开一个tga文件，然后以二进制的形式读取出来，进而对外部指针width等做修改，所以该函数返回了像素的宽高等的一些信息。</p>\n<h2 id=\"载入纹理\"><a href=\"#载入纹理\" class=\"headerlink\" title=\"载入纹理\"></a>载入纹理</h2><p>接下来载入缓冲区内的纹理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGLbyte *pBits;</span><br><span class=\"line\">\tint nWidth, nHeight, nComponents;</span><br><span class=\"line\">\tGLenum eFormat;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// Read the texture bits</span><br><span class=\"line\">\tpBits = gltReadTGABits(szFileName, &amp;nWidth, &amp;nHeight, &amp;nComponents, &amp;eFormat);</span><br><span class=\"line\">\tif(pBits == NULL)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //纹理环绕</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //纹理过滤（邻近过滤和线性过滤）</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);</span><br><span class=\"line\">    </span><br><span class=\"line\">\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class=\"line\">\tglTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0,</span><br><span class=\"line\">\t\t\t\t eFormat, GL_UNSIGNED_BYTE, pBits);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    free(pBits);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(minFilter == GL_LINEAR_MIPMAP_LINEAR || </span><br><span class=\"line\">       minFilter == GL_LINEAR_MIPMAP_NEAREST ||</span><br><span class=\"line\">       minFilter == GL_NEAREST_MIPMAP_LINEAR ||</span><br><span class=\"line\">       minFilter == GL_NEAREST_MIPMAP_NEAREST)</span><br><span class=\"line\">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class=\"line\">    </span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"glTexParameteri\"><a href=\"#glTexParameteri\" class=\"headerlink\" title=\"glTexParameteri\"></a><code>glTexParameteri</code></h3><p>OpenGL在拉伸和收缩时对纹理贴图计算颜色片段的过程称为纹理过滤；纹理坐标总是根据纹理图像的纹理单元进行求值和绘图；使用上面这个函数设置放大和缩小的过滤模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>\n<p><code>GL_LINEAR</code>,是线性过滤，把纹理坐标周围的的纹理单元的加权平均值应用到纹理坐标上，这可以需要一些额外的开销；</p>\n<p><code>GL_NEAREST</code>是最邻近过滤，把最邻近的纹理单元应用到纹理坐标中，它我们能选择的最简单、最快速的过滤方法；</p>\n<p>前面说到纹理坐标坐落在一个0.0到1.0的范围内，当超过了范围，OpenGL使用这个函数处理纹理环绕模式；</p>\n<p><code>GL_REPEAT</code>模式下OpenGL在纹理坐标值超过1.0的方向上进行重复；</p>\n<p><code>GL_CLAMP</code>所需的纹理单元取自纹理边界或<code>TEXTURE_BORDER_COLOR</code>(glTexParameterfv函数设置的值)；</p>\n<p><code>GL_CLAMP_TO_EDGE</code>强制对范围外的纹理坐标沿着合法的纹理坐标的最后一行或一列进行渲染；</p>\n<p><code>GL_CLAMP_TO_BORDER</code>范围之外的纹理坐标使用边界纹理单元；</p>\n<p>注：在<code>GL_NEAREST</code>模式下过滤模式并不起作用，因为纹理坐标总是对齐到纹理贴图中的一些特定的纹理单元；</p>\n<h3 id=\"glPixelStorei\"><a href=\"#glPixelStorei\" class=\"headerlink\" title=\"glPixelStorei\"></a><code>glPixelStorei</code></h3><p><code>GL_UNPACK_ALIGNMENT</code>指定OpenGL如何从数据缓冲区中解包图像数据；关于这个函数我们暂时只说明这一点；这似乎跟OpenGL对像素的内存分配有关；</p>\n<h3 id=\"glTexImage2D\"><a href=\"#glTexImage2D\" class=\"headerlink\" title=\"glTexImage2D\"></a><code>glTexImage2D</code></h3><p>函数原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexImage2D(GLenum target, GLint level, GLint internalformat, </span><br><span class=\"line\">\t\t\t\tGLsizei width, GLsizei height, GLsizei depth, GLint border,</span><br><span class=\"line\">\t\t\t\tGLeunm format, GLeunm type,void* data);</span><br></pre></td></tr></table></figure>\n<p>函数比较长，参数讲解：</p>\n<p>target变量分别是<code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,这里我们选择<code>GL_TEXTURE_2D</code>；该函数之后会有详细说明；</p>\n<p>level指定了加载的mip贴图层次（你说你不知道mip贴图是什么，下次我们会讲，这里你理解成你们家铺地的瓷砖就好了）；</p>\n<p>我们必须指定纹理数据的internalformat，这个信息告诉我们希望在每个纹理中存储多少颜色成分，并在可能的情况下说明这些成分的存储大小，以及是否希望对纹理进行压缩；竟然一个参数有这么多作用，具体参数列表为：</p>\n<table>\n<thead>\n<tr>\n<th>常量</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_ALPHA</td>\n<td style=\"text-align:center\">按照alpha值存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE(亮度)</td>\n<td style=\"text-align:center\">按照亮度值存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td style=\"text-align:center\">按照亮度值和alpha值存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td style=\"text-align:center\">按照红、绿、蓝成分存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td style=\"text-align:center\">按照红、绿、蓝和alpha成分存储纹理单元</td>\n</tr>\n</tbody>\n</table>\n<p>width,height,depth指定了被加载纹理的宽、高和深，这些值必须是2的整数次方，这一点非常重要；纹理贴图并不要求是立方体，但是一个纹理在加载时如果使用了非2的整数次幂值，将会导致纹理贴图被禁用，意思就是你什么也显示不出来；</p>\n<p>border允许我们为纹理贴图指定一个边界宽度；</p>\n<p>format,type,data详见<code>glReadPixels()</code>函数中对应的解释；</p>\n<h3 id=\"glReadPixels\"><a href=\"#glReadPixels\" class=\"headerlink\" title=\"glReadPixels\"></a><code>glReadPixels</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glReadPixels(GLint x,GLint y,GLSizei width,GLSizei height,</span><br><span class=\"line\">GLenum format,GLeunm type,const void* pixels);</span><br></pre></td></tr></table></figure>\n<p>OpenGL提供了简洁的函数来操作像素：</p>\n<p>glReadPixels：读取一些像素。当前可以简单理解为“把已经绘制好的像素（它可能已经被保存到显卡的显存中）读取到内存”。</p>\n<p>glDrawPixels：绘制一些像素。当前可以简单理解为“把内存中一些数据作为像素数据，进行绘制”。</p>\n<p>glCopyPixels：复制一些像素。当前可以简单理解为“把已经绘制好的像素从一个位置复制到另一个位置”。虽然从功能上看，好象等价于先读取像素再绘制像素，但实际上它不需要把已经绘制的像素（它可能已经被保存到显卡的显存中）转换为内存数据，然后再由内存数据进行重新的绘制，所以要比先读取后绘制快很多。<br>这三个函数可以完成简单的像素读取、绘制和复制任务，但实际上也可以完成更复杂的任务。</p>\n<p>该函数总共有七个参数。前四个参数可以得到一个矩形，该矩形所包括的像素都会被读取出来；（第一、二个参数表示了矩形的左下角横、纵坐标，坐标以窗口最左下角为零，最右上角为最大值；第三、四个参数表示了矩形的宽度和高度）</p>\n<p>第五个参数表示读取的内容，例如：GL_RGB就会依次读取像素的红、绿、蓝三种数据，GL_RGBA则会依次读取像素的红、绿、蓝、alpha四种数据，GL_RED则只读取像素的红色数据（类似的还有GL_GREEN，GL_BLUE，以及GL_ALPHA）。如果采用的不是RGBA颜色模式，而是采用颜色索引模式，则也可以使用GL_COLOR_INDEX来读取像素的颜色索引。目前仅需要知道这些，但实际上还可以读取其它内容，例如深度缓冲区的深度数据等；</p>\n<p>第六个参数表示读取的内容保存到内存时所使用的格式，例如：GL_UNSIGNED_BYTE会把各种数据保存为GLubyte，GL_FLOAT会把各种数据保存为GLfloat等。</p>\n<p>第七个参数表示一个指针，像素数据被读取后，将被保存到这个指针所表示的地址。注意，需要保证该地址有足够的可以使用的空间，以容纳读取的像素数据。例如一幅大小为256<em>256的图象，如果读取其RGB数据，且每一数据被保存为GLubyte，总大小就是：256</em>256<em>3 = 196608字节，即192千字节。如果是读取RGBA数据，则总大小就是256</em>256*4 = 262144字节，即256千字节。<br>注意：glReadPixels实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲。</p>\n<p>本篇就先到这里吧，本人要下班了。</p>\n","site":{"data":{}},"excerpt":"<p>Summary:说到纹理，通俗的讲就是我们不用再自己去画图啦，用一些装有信息格式的文件去实现画图，这将为我们带来一个更加清新的展示效果。在纹理中涉及到许多概念也是需要我们去理解的，理解的部分我无法为你们完成，概念的部分我尽量写出自己的理解。希望可以帮到看本博客的同学。<br>","more":"</p>\n<p><a href=\"https://github.com/usiege/OpenGL_S/tree/master/OpenGL_05_%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/BaseTexture\" target=\"_blank\" rel=\"noopener\">本文例子查看地址</a>，本例中展示了读取tag文件并加载纹理生成图像，mac用户可以把例子下下来看看效果。</p>\n<h2 id=\"纹理坐标自描述\"><a href=\"#纹理坐标自描述\" class=\"headerlink\" title=\"纹理坐标自描述\"></a>纹理坐标自描述</h2><p>典型情况下，纹理坐标是作为0.0到1.0范围内的浮点值指定的，坐标命名为s,t,r,q，分别对应顶点坐标的x,y,z,w；自己理解下就是纹理会被先加载到一个各边都视为单位1的坐标系下，然后再将这样的坐标系映射到真实的屏幕坐标系里，因为每个坐标系上的全长都是单位一，那么根据在第边上的比例即可计算纹理的真实像素。而且若三个坐标系的单位一不相同的情况下，得到的结果也不会是一个正方体，所以真实的纹理计算过程会进行拉伸或收缩。</p>\n<h2 id=\"读取像素\"><a href=\"#读取像素\" class=\"headerlink\" title=\"读取像素\"></a>读取像素</h2><p>Targa图像格式是一种方便且容易使用的图片格式，先贴上一个函数，该函数详细介绍了tga文件的加载过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*自定义tga图片头信息结构*/</span><br><span class=\"line\">#pragma pack(1)//结构体字节对齐</span><br><span class=\"line\">typedef struct</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GLbyte  identsize;              // Size of ID field that follows header (0)</span><br><span class=\"line\">    GLbyte  colorMapType;           // 0 = None, 1 = paletted</span><br><span class=\"line\">    GLbyte  imageType;              // 0 = none, 1 = indexed, 2 = rgb, 3 = grey, +8=rle</span><br><span class=\"line\">    unsigned short  colorMapStart;          // First colour map entry</span><br><span class=\"line\">    unsigned short  colorMapLength;         // Number of colors</span><br><span class=\"line\">    unsigned char   colorMapBits;   // bits per palette entry</span><br><span class=\"line\">    unsigned short  xstart;                 // image x origin</span><br><span class=\"line\">    unsigned short  ystart;                 // image y origin</span><br><span class=\"line\">    unsigned short  width;                  // width in pixels</span><br><span class=\"line\">    unsigned short  height;                 // height in pixels</span><br><span class=\"line\">    GLbyte  bits;                   // bits per pixel (8 16, 24, 32)</span><br><span class=\"line\">    GLbyte  descriptor;             // image descriptor</span><br><span class=\"line\">&#125; TGAHEADER;</span><br><span class=\"line\">#pragma pack(8)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*tga图片读取*/</span><br><span class=\"line\">//进行内存定位并载入targa位，返回指向新的缓冲区指针，纹理高宽，以及OpenGL数据格式</span><br><span class=\"line\">//注：只支持targa,只能是8位、24位或32位色，没有调色板和RLE编码（这部分没看懂，应该是跟图像格式有关的）</span><br><span class=\"line\">GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE *pFile;            // File pointer</span><br><span class=\"line\">    TGAHEADER tgaHeader;        // TGA file header</span><br><span class=\"line\">    unsigned long lImageSize;       // Size in bytes of image</span><br><span class=\"line\">    short sDepth;           // Pixel depth;</span><br><span class=\"line\">    GLbyte  *pBits = NULL;          // Pointer to bits</span><br><span class=\"line\">    </span><br><span class=\"line\">    //默认或失败值</span><br><span class=\"line\">    *iWidth = 0;</span><br><span class=\"line\">    *iHeight = 0;</span><br><span class=\"line\">    *eFormat = GL_RGB;</span><br><span class=\"line\">    *iComponents = GL_RGB;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //尝试打开文件</span><br><span class=\"line\">    pFile = fopen(szFileName, &quot;rb&quot;);</span><br><span class=\"line\">    if(pFile == NULL)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读入文件头（二进制）</span><br><span class=\"line\">    fread(&amp;tgaHeader, 18/* sizeof(TGAHEADER)*/, 1, pFile);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 为大小字节存储顺序问题而进行字节交换，这里有大神给解释下吗？</span><br><span class=\"line\">//#ifdef __APPLE__</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapStart);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.colorMapLength);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.xstart);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.ystart);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.width);</span><br><span class=\"line\">//    LITTLE_ENDIAN_WORD(&amp;tgaHeader.height);</span><br><span class=\"line\">//#endif</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取纹理宽，高，深度</span><br><span class=\"line\">    *iWidth = tgaHeader.width;</span><br><span class=\"line\">    *iHeight = tgaHeader.height;</span><br><span class=\"line\">    sDepth = tgaHeader.bits / 8;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //进行有效性检验，我们需要关心8位、24位或32位</span><br><span class=\"line\">    if(tgaHeader.bits != 8 &amp;&amp; tgaHeader.bits != 24 &amp;&amp; tgaHeader.bits != 32)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 计算图像缓冲区大小</span><br><span class=\"line\">    lImageSize = tgaHeader.width * tgaHeader.height * sDepth;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 内存定位和成功检验</span><br><span class=\"line\">    pBits = (GLbyte*)malloc(lImageSize * sizeof(GLbyte));</span><br><span class=\"line\">    if(pBits == NULL)</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读入位</span><br><span class=\"line\">    // 检查读取错误，这项操作应该发现RLE或者其他我们不想识别的格式</span><br><span class=\"line\">    // RLE:一种压缩过的位图文件格式，RLE压缩方案是一种极其成熟的压缩方案，</span><br><span class=\"line\">    // 特点是无损失压缩，既节省了磁盘空间又不损失任何图像数据;</span><br><span class=\"line\">    if(fread(pBits, lImageSize, 1, pFile) != 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        free(pBits);</span><br><span class=\"line\">        return NULL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置希望的OpenGL格式</span><br><span class=\"line\">    switch(sDepth)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">#ifndef OPENGL_ES</span><br><span class=\"line\">        case 3:     // Most likely case</span><br><span class=\"line\">            *eFormat = GL_BGR;</span><br><span class=\"line\">            *iComponents = GL_RGB;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">            *eFormat = GL_BGRA;</span><br><span class=\"line\">            *iComponents = GL_RGBA;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            *eFormat = GL_LUMINANCE;</span><br><span class=\"line\">            *iComponents = GL_LUMINANCE;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:        // RGB</span><br><span class=\"line\">            //如果是在iPhone上，TGA为BGR，并且iPhone不支持没有alpha的BGR</span><br><span class=\"line\">            //iPhone支持RGB，所以只要将红色和蓝色调整一下就能符合要求</span><br><span class=\"line\">            //但是为了加快iPhone的载入速度，请保存带有alpha的TGA</span><br><span class=\"line\">#ifdef OPENGL_ES</span><br><span class=\"line\">            for(int i = 0; i &lt; lImageSize; i+=3)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                GLbyte temp = pBits[i];</span><br><span class=\"line\">                pBits[i] = pBits[i+2];</span><br><span class=\"line\">                pBits[i+2] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 文件结束</span><br><span class=\"line\">    fclose(pFile);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 返回指向图像的指针</span><br><span class=\"line\">    return pBits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数<code>gltReadTGABits</code>是自定义读取函数，大致的过程就是打开一个tga文件，然后以二进制的形式读取出来，进而对外部指针width等做修改，所以该函数返回了像素的宽高等的一些信息。</p>\n<h2 id=\"载入纹理\"><a href=\"#载入纹理\" class=\"headerlink\" title=\"载入纹理\"></a>载入纹理</h2><p>接下来载入缓冲区内的纹理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool LoadTGATexture(const char *szFileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGLbyte *pBits;</span><br><span class=\"line\">\tint nWidth, nHeight, nComponents;</span><br><span class=\"line\">\tGLenum eFormat;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// Read the texture bits</span><br><span class=\"line\">\tpBits = gltReadTGABits(szFileName, &amp;nWidth, &amp;nHeight, &amp;nComponents, &amp;eFormat);</span><br><span class=\"line\">\tif(pBits == NULL)</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //纹理环绕</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    //纹理过滤（邻近过滤和线性过滤）</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);</span><br><span class=\"line\">\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);</span><br><span class=\"line\">    </span><br><span class=\"line\">\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class=\"line\">\tglTexImage2D(GL_TEXTURE_2D, 0, nComponents, nWidth, nHeight, 0,</span><br><span class=\"line\">\t\t\t\t eFormat, GL_UNSIGNED_BYTE, pBits);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    free(pBits);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(minFilter == GL_LINEAR_MIPMAP_LINEAR || </span><br><span class=\"line\">       minFilter == GL_LINEAR_MIPMAP_NEAREST ||</span><br><span class=\"line\">       minFilter == GL_NEAREST_MIPMAP_LINEAR ||</span><br><span class=\"line\">       minFilter == GL_NEAREST_MIPMAP_NEAREST)</span><br><span class=\"line\">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class=\"line\">    </span><br><span class=\"line\">\treturn true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"glTexParameteri\"><a href=\"#glTexParameteri\" class=\"headerlink\" title=\"glTexParameteri\"></a><code>glTexParameteri</code></h3><p>OpenGL在拉伸和收缩时对纹理贴图计算颜色片段的过程称为纹理过滤；纹理坐标总是根据纹理图像的纹理单元进行求值和绘图；使用上面这个函数设置放大和缩小的过滤模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>\n<p><code>GL_LINEAR</code>,是线性过滤，把纹理坐标周围的的纹理单元的加权平均值应用到纹理坐标上，这可以需要一些额外的开销；</p>\n<p><code>GL_NEAREST</code>是最邻近过滤，把最邻近的纹理单元应用到纹理坐标中，它我们能选择的最简单、最快速的过滤方法；</p>\n<p>前面说到纹理坐标坐落在一个0.0到1.0的范围内，当超过了范围，OpenGL使用这个函数处理纹理环绕模式；</p>\n<p><code>GL_REPEAT</code>模式下OpenGL在纹理坐标值超过1.0的方向上进行重复；</p>\n<p><code>GL_CLAMP</code>所需的纹理单元取自纹理边界或<code>TEXTURE_BORDER_COLOR</code>(glTexParameterfv函数设置的值)；</p>\n<p><code>GL_CLAMP_TO_EDGE</code>强制对范围外的纹理坐标沿着合法的纹理坐标的最后一行或一列进行渲染；</p>\n<p><code>GL_CLAMP_TO_BORDER</code>范围之外的纹理坐标使用边界纹理单元；</p>\n<p>注：在<code>GL_NEAREST</code>模式下过滤模式并不起作用，因为纹理坐标总是对齐到纹理贴图中的一些特定的纹理单元；</p>\n<h3 id=\"glPixelStorei\"><a href=\"#glPixelStorei\" class=\"headerlink\" title=\"glPixelStorei\"></a><code>glPixelStorei</code></h3><p><code>GL_UNPACK_ALIGNMENT</code>指定OpenGL如何从数据缓冲区中解包图像数据；关于这个函数我们暂时只说明这一点；这似乎跟OpenGL对像素的内存分配有关；</p>\n<h3 id=\"glTexImage2D\"><a href=\"#glTexImage2D\" class=\"headerlink\" title=\"glTexImage2D\"></a><code>glTexImage2D</code></h3><p>函数原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexImage2D(GLenum target, GLint level, GLint internalformat, </span><br><span class=\"line\">\t\t\t\tGLsizei width, GLsizei height, GLsizei depth, GLint border,</span><br><span class=\"line\">\t\t\t\tGLeunm format, GLeunm type,void* data);</span><br></pre></td></tr></table></figure>\n<p>函数比较长，参数讲解：</p>\n<p>target变量分别是<code>GL_TEXTURE_1D</code>, <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_3D</code>,这里我们选择<code>GL_TEXTURE_2D</code>；该函数之后会有详细说明；</p>\n<p>level指定了加载的mip贴图层次（你说你不知道mip贴图是什么，下次我们会讲，这里你理解成你们家铺地的瓷砖就好了）；</p>\n<p>我们必须指定纹理数据的internalformat，这个信息告诉我们希望在每个纹理中存储多少颜色成分，并在可能的情况下说明这些成分的存储大小，以及是否希望对纹理进行压缩；竟然一个参数有这么多作用，具体参数列表为：</p>\n<table>\n<thead>\n<tr>\n<th>常量</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_ALPHA</td>\n<td style=\"text-align:center\">按照alpha值存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE(亮度)</td>\n<td style=\"text-align:center\">按照亮度值存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_LUMINANCE_ALPHA</td>\n<td style=\"text-align:center\">按照亮度值和alpha值存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_RGB</td>\n<td style=\"text-align:center\">按照红、绿、蓝成分存储纹理单元</td>\n</tr>\n<tr>\n<td>GL_RGBA</td>\n<td style=\"text-align:center\">按照红、绿、蓝和alpha成分存储纹理单元</td>\n</tr>\n</tbody>\n</table>\n<p>width,height,depth指定了被加载纹理的宽、高和深，这些值必须是2的整数次方，这一点非常重要；纹理贴图并不要求是立方体，但是一个纹理在加载时如果使用了非2的整数次幂值，将会导致纹理贴图被禁用，意思就是你什么也显示不出来；</p>\n<p>border允许我们为纹理贴图指定一个边界宽度；</p>\n<p>format,type,data详见<code>glReadPixels()</code>函数中对应的解释；</p>\n<h3 id=\"glReadPixels\"><a href=\"#glReadPixels\" class=\"headerlink\" title=\"glReadPixels\"></a><code>glReadPixels</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glReadPixels(GLint x,GLint y,GLSizei width,GLSizei height,</span><br><span class=\"line\">GLenum format,GLeunm type,const void* pixels);</span><br></pre></td></tr></table></figure>\n<p>OpenGL提供了简洁的函数来操作像素：</p>\n<p>glReadPixels：读取一些像素。当前可以简单理解为“把已经绘制好的像素（它可能已经被保存到显卡的显存中）读取到内存”。</p>\n<p>glDrawPixels：绘制一些像素。当前可以简单理解为“把内存中一些数据作为像素数据，进行绘制”。</p>\n<p>glCopyPixels：复制一些像素。当前可以简单理解为“把已经绘制好的像素从一个位置复制到另一个位置”。虽然从功能上看，好象等价于先读取像素再绘制像素，但实际上它不需要把已经绘制的像素（它可能已经被保存到显卡的显存中）转换为内存数据，然后再由内存数据进行重新的绘制，所以要比先读取后绘制快很多。<br>这三个函数可以完成简单的像素读取、绘制和复制任务，但实际上也可以完成更复杂的任务。</p>\n<p>该函数总共有七个参数。前四个参数可以得到一个矩形，该矩形所包括的像素都会被读取出来；（第一、二个参数表示了矩形的左下角横、纵坐标，坐标以窗口最左下角为零，最右上角为最大值；第三、四个参数表示了矩形的宽度和高度）</p>\n<p>第五个参数表示读取的内容，例如：GL_RGB就会依次读取像素的红、绿、蓝三种数据，GL_RGBA则会依次读取像素的红、绿、蓝、alpha四种数据，GL_RED则只读取像素的红色数据（类似的还有GL_GREEN，GL_BLUE，以及GL_ALPHA）。如果采用的不是RGBA颜色模式，而是采用颜色索引模式，则也可以使用GL_COLOR_INDEX来读取像素的颜色索引。目前仅需要知道这些，但实际上还可以读取其它内容，例如深度缓冲区的深度数据等；</p>\n<p>第六个参数表示读取的内容保存到内存时所使用的格式，例如：GL_UNSIGNED_BYTE会把各种数据保存为GLubyte，GL_FLOAT会把各种数据保存为GLfloat等。</p>\n<p>第七个参数表示一个指针，像素数据被读取后，将被保存到这个指针所表示的地址。注意，需要保证该地址有足够的可以使用的空间，以容纳读取的像素数据。例如一幅大小为256<em>256的图象，如果读取其RGB数据，且每一数据被保存为GLubyte，总大小就是：256</em>256<em>3 = 196608字节，即192千字节。如果是读取RGBA数据，则总大小就是256</em>256*4 = 262144字节，即256千字节。<br>注意：glReadPixels实际上是从缓冲区中读取数据，如果使用了双缓冲区，则默认是从正在显示的缓冲（即前缓冲）中读取，而绘制工作是默认绘制到后缓冲区的。因此，如果需要读取已经绘制好的像素，往往需要先交换前后缓冲。</p>\n<p>本篇就先到这里吧，本人要下班了。</p>"},{"title":"OpenGLES-纹理的初步认识","date":"2016-06-04T15:51:00.000Z","_content":"\nSummary:  上周看书学习OpenGLES关于纹理的知识，云里雾里的，看完的感觉是好多东西都明白，涉及到许多opengl的内容，不过照着书里的内容运行了几个Demo，大致算是有些总结，现做一下回顾，上几个例子。\n不过这里有一点，这本书看完下一步还是要细研究一下opengl，初步决定从《计算机图形学》这本书入手。好了，之后的事情不多说，先做好当下的事情。\n\n<!-- more -->\n\n\n## Demo:渲染图片[Demo代码](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_2)\n\n首先是关于纹理的一些概念:\n\n>纹理是什么？纹理是一个用来保存图像的元素值的OGE缓存,就是颜色缓存；\n\n>当用一个图像初始化一个纹理缓存后，每一个像素就变成了纹理中的纹素（texel）；\n\n\n>像素通常表示屏幕上的一个实际的颜色点，纹素是在一个虚拟的坐标系中;\n\n\n>GPU会转换OGE坐标系中的每个点为帧缓存中的真实像素坐标（视口viewport坐标）；\n\n\n>转换几何形状数据为帧缓存中的颜色像素的过程叫做点阵化（rasterizing），每个颜色像素叫做片元（fragment）;\n\n\n>纹素决定片元的对齐过程，叫做映射（mapping）；\n\n\n>取样（sampling）是GPU从每个片元的U、V位置选择纹素的过程；\n\n\n>MIP贴图是为一个纹理存储多个细节的技术，它通过减少GPU的取样来提高渲染的性能；\n\n下面的例子展示了使用一个图片渲染的图片缓存：\n\n\n在`GLKViewController`中，设置OGE的上下文：\n\n\n```\n\tGLKView *view = (GLKView *)self.view;\n    view.backgroundColor = [UIColor whiteColor];\n   NSAssert([view isKindOfClass:[GLKView class]],\n      @\"View controller's view is not a GLKView\");\n   \n   view.context = [[AGLKContext alloc] \n      initWithAPI:kEAGLRenderingAPIOpenGLES2];\n   \n   // Make the new context current\n   [AGLKContext setCurrentContext:view.context];\n```\n\n上面的`AGLKContext`是`EAGLContext`的子类，`setCurrentContext:`是继承自父类的方法，设备当前上下文；\n\n设置提供基础功能:\n\n```\n// Create a base effect that provides standard OpenGL ES 2.0\n   // shading language programs and set constants to be used for \n   // all subsequent rendering\n   self.baseEffect = [[GLKBaseEffect alloc] init];\n   self.baseEffect.useConstantColor = GL_TRUE;\n   self.baseEffect.constantColor = GLKVector4Make(\n      1.0f, // Red\n      1.0f, // Green\n      1.0f, // Blue\n      1.0f);// Alpha\n```\n上面的这个constantColor,说是顶点缓冲，这里可能是顶点的颜色缓存，具体应该是与opengl相关的东西，这里这么用着，我改过这里的值，会修改渲染出来图的背景色，暂且认为是渲染用的一个底色吧；\n\n设置当前上下文的“清除颜色”：\n\n```\n// Set the background color stored in the current context\nGLKVector4 clearColorRGBA = GLKVector4Make(\n      1.0f, // Red\n      1.0f, // Green\n      1.0f, // Blue\n      1.0f);// Alpha \nglClearColor(\n      clearColorRGBA.r, \n      clearColorRGBA.g, \n      clearColorRGBA.b, \n      clearColorRGBA.a); \n```\n接下来要进行渲染图片了，大致与渲染一个三角形的过程差不多，可对照[开始OpenGLES的探索](http://uwuneng.com/opengles_start.html)，同样也是6步：\n\n这里我们自定义了一个`AGLKVertexAttribArrayBuffer`封装了关于一些OGE的操作，来说明一下：\n\n```\n// This data type is used to store information for each vertex\n//这个类型用来保存每个顶点的信息\n typedef struct {\n   GLKVector3  positionCoords;\n   GLKVector2  textureCoords;\n}SceneVertex;\n\n// Define    data for a triangle to use in example\n//定义三角形顶点\nstatic const SceneVertex vertices[] = \n{\n   {{-0.5f, -0.5f, 0.0f}, {0.0f, 0.0f}}, // lower left corner\n   {{ 0.5f, -0.5f, 0.0f}, {1.0f, 0.0f}}, // lower right corner\n   {{-0.5f,  0.5f, 0.0f}, {0.0f, 1.0f}}, // upper left corner\n};\n\n// Create vertex buffer containing vertices to draw\n//这里是定义渲染区域\n   self.vertexBuffer = [[AGLKVertexAttribArrayBuffer alloc]\n      initWithAttribStride:sizeof(SceneVertex)\n      numberOfVertices:sizeof(vertices) / sizeof(SceneVertex)\n      bytes:vertices\n      usage:GL_STATIC_DRAW];\n\nself.baseEffect.texture2d0.name = textureInfo.name;\nself.baseEffect.texture2d0.target = textureInfo.target;\n\n```\n\n下面是init方法：\n\n```\n// This method creates a vertex attribute array buffer in\n// the current OpenGL ES context for the thread upon which this \n// method is called.\n- (id)initWithAttribStride:(GLsizei)aStride\n   numberOfVertices:(GLsizei)count\n   bytes:(const GLvoid *)dataPtr\n   usage:(GLenum)usage;\n{\n   NSParameterAssert(0 < aStride);\n   NSAssert((0 < count && NULL != dataPtr) ||\n      (0 == count && NULL == dataPtr),\n      @\"data must not be NULL or count > 0\");\n      \n   if(nil != (self = [super init]))\n   {\n      stride = aStride;\n      bufferSizeBytes = stride * count;\n      \n      glGenBuffers(1,                // STEP 1\n         &name);\n      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2\n         self.name); \n      glBufferData(                  // STEP 3\n         GL_ARRAY_BUFFER,  // Initialize buffer contents\n         bufferSizeBytes,  // Number of bytes to copy\n         dataPtr,          // Address of bytes to copy\n         usage);           // Hint: cache in GPU memory\n         \n      NSAssert(0 != name, @\"Failed to generate name\");\n   }\n   \n   return self;\n}   \n```\n\n从这里可以看到图形渲染的前三步，生成缓存`glGenBuffers`，绑定缓存`glBindBuffer`，复制数据到缓存`glBufferData`；\n\n下面我们来进入今天的重点：\n\n```\n   // Setup texture\n   CGImageRef imageRef = \n      [[UIImage imageNamed:@\"leaves.gif\"] CGImage];\n      \n   AGLKTextureInfo *textureInfo = [AGLKTextureLoader \n      textureWithCGImage:imageRef \n      options:nil \n      error:NULL];\n   \n   self.baseEffect.texture2d0.name = textureInfo.name;\n   self.baseEffect.texture2d0.target = textureInfo.target;\n\n```\n`textureWithCGImage:`实现具体细节：\n\n```\n// This method generates a new OpenGL ES texture buffer and \n// initializes the buffer contents using pixel data from the \n// specified Core Graphics image, cgImage. This method returns an\n// immutable AGLKTextureInfo instance initialized with \n// information about the newly generated texture buffer.\n//    The generated texture buffer has power of 2 dimensions. The\n// provided image data is scaled (re-sampled) by Core Graphics as\n// necessary to fit within the generated texture buffer.\n\n+ (AGLKTextureInfo *)textureWithCGImage:(CGImageRef)cgImage\n                                options:(NSDictionary *)options\n   error:(NSError **)outError;\n{\n   // Get the bytes to be used when copying data into new texture\n   // buffer\n   size_t width;\n   size_t height;\n   NSData *imageData = AGLKDataWithResizedCGImageBytes(\n      cgImage,\n      &width,\n      &height);\n   \n   // Generation, bind, and copy data into a new texture buffer\n   GLuint      textureBufferID;\n   \n   glGenTextures(1, &textureBufferID);                  // Step 1\n   glBindTexture(GL_TEXTURE_2D, textureBufferID);       // Step 2\n   \n    //该函数是OGE最复杂的函数\n   glTexImage2D(                                        // Step 3\n      GL_TEXTURE_2D, //用于2D纹理\n      0, //指定MIP帖图的初始细节级别\n      GL_RGBA, //指定每个纹素需要保存信息的数量\n      (GLuint)width,//\n      (GLuint)height,\n      0, //围绕纹素的边界的大小,总是被设置为0\n      GL_RGBA, \n      GL_UNSIGNED_BYTE, \n      [imageData bytes]);\n   \n   // Set parameters that control texture sampling for the bound\n   // texture\n  glTexParameteri(GL_TEXTURE_2D,\n     GL_TEXTURE_MIN_FILTER, \n     GL_LINEAR); \n   \n   // Allocate and initialize the AGLKTextureInfo instance to be\n   // returned\n   AGLKTextureInfo *result = [[AGLKTextureInfo alloc] \n      initWithName:textureBufferID\n      target:GL_TEXTURE_2D\n      width:(GLuint)width\n      height:(GLuint)height];\n   \n   return result;\n}\n```\n\n上面这个方法使用Core Graphics图像的像素数据生成一个新的OGE缓存并初始化它，此方法返回一个不变的AGLKtextureinfo实例。\n\n解释一下这个方法`glTexParameteri`，该方法为创建的纹理缓存设置OGE取样和循环模式。如果使用了MIP贴图，第二个参数会被设置成GL_LINEAR_MIPMAP_LINEAR，这会告诉OGE使用与被取样的S,T坐标最接近的纹素的线性插值取样两个最合适的MIP贴图图像尺寸。然后，来自MIP贴图的两个样本被线性差值来产生最终的片元颜色。这里涉及的两个概念需要对opengl进行深入了解。\n\n\n其中`AGLKDataWithResizedCGImageBytes`把指定的cgImmage拖入imageData提供的字节中，Core Graphics把cgImage拖入一个适当大小的Core Graphics上下文中，这个过程会把图像的尺寸调整为2的幂，图像在绘制的时候还会被上下翻转，这是因为OGE的原点在左下角而iOS的实现原点却是在左上角，翻转Y轴确保了图像字节拥有适用于纹理缓存的正确的方向。\n\n```\nstatic NSData *AGLKDataWithResizedCGImageBytes(\n   CGImageRef cgImage,\n   size_t *widthPtr,\n   size_t *heightPtr)\n{\n   NSCParameterAssert(NULL != cgImage);\n   NSCParameterAssert(NULL != widthPtr);\n   NSCParameterAssert(NULL != heightPtr);\n   \n   GLuint originalWidth = (GLuint)CGImageGetWidth(cgImage);\n   GLuint originalHeight = (GLuint)CGImageGetWidth(cgImage);\n   \n   NSCAssert(0 < originalWidth, @\"Invalid image width\");\n   NSCAssert(0 < originalHeight, @\"Invalid image width\");\n   \n   // Calculate the width and height of the new texture buffer\n   // The new texture buffer will have power of 2 dimensions.\n   GLuint width = AGLKCalculatePowerOf2ForDimension(\n      originalWidth);\n   GLuint height = AGLKCalculatePowerOf2ForDimension(\n      originalHeight);\n      \n      //注意这个函数AGLKCalculatePowerOf2ForDimension就是用来取整用的\n      \n   // Allocate sufficient storage for RGBA pixel color data with \n   // the power of 2 sizes specified\n   NSMutableData    *imageData = [NSMutableData dataWithLength:\n      height * width * 4];  // 4 bytes per RGBA pixel\n\n   NSCAssert(nil != imageData, \n      @\"Unable to allocate image storage\");\n   \n   // Create a Core Graphics context that draws into the \n   // allocated bytes\n   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n   CGContextRef cgContext = CGBitmapContextCreate( \n      [imageData mutableBytes], width, height, 8, \n      4 * width, colorSpace, \n      kCGImageAlphaPremultipliedLast);\n   CGColorSpaceRelease(colorSpace);\n   \n   // Flip the Core Graphics Y-axis for future drawing\n   CGContextTranslateCTM (cgContext, 0, height);\n   CGContextScaleCTM (cgContext, 1.0, -1.0);\n   \n   // Draw the loaded image into the Core Graphics context \n   // resizing as necessary\n   CGContextDrawImage(cgContext, CGRectMake(0, 0, width, height),\n      cgImage);\n   \n   CGContextRelease(cgContext);\n   \n   *widthPtr = width;\n   *heightPtr = height;\n   \n   return imageData;\n}\n```\n\n最后在glk回调中实现真正画图：\n\n```\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n   [self.baseEffect prepareToDraw];\n   \n   // Clear back frame buffer (erase previous drawing)\n   [(AGLKContext *)view.context clear:GL_COLOR_BUFFER_BIT];\n   \n   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribPosition\n      numberOfCoordinates:3\n      attribOffset:offsetof(SceneVertex, positionCoords)\n      shouldEnable:YES];\n   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribTexCoord0\n      numberOfCoordinates:2\n      attribOffset:offsetof(SceneVertex, textureCoords)\n      shouldEnable:YES];\n      \n   // Draw triangles using the first three vertices in the \n   // currently bound vertex buffer\n   [self.vertexBuffer drawArrayWithMode:GL_TRIANGLES\n      startVertexIndex:0\n      numberOfVertices:3];\n}\n```\n\n`glEnableVertexAttribArray`,\n\n`glVertexAttribPointer`,\n\n`glDrawArrays`\n\n这里提前熟悉一下这些函数，虽然现在还是对它们不是太理解。\n\n后面的例子就不一一写了，过程笔记都在代码中，分别涉及到一些概念\n\n[OpenGLES_Ch3_3取样循环等](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_3)\n\n[OpenGLES_Ch3_4混合片元颜色](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_4)\n\n[OpenGLES_Ch3_5多重纹理](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_5)\n\n[OpenGLES_Ch3_6自定义纹理](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_6)\n\n\n\n","source":"_posts/OpenGLES-纹理的初步认识.md","raw":"title: OpenGLES-纹理的初步认识\ndate: 2016-06-04 23:51:00\ncategories: coder\ntags: [opengles, texture]\n-----------\n\nSummary:  上周看书学习OpenGLES关于纹理的知识，云里雾里的，看完的感觉是好多东西都明白，涉及到许多opengl的内容，不过照着书里的内容运行了几个Demo，大致算是有些总结，现做一下回顾，上几个例子。\n不过这里有一点，这本书看完下一步还是要细研究一下opengl，初步决定从《计算机图形学》这本书入手。好了，之后的事情不多说，先做好当下的事情。\n\n<!-- more -->\n\n\n## Demo:渲染图片[Demo代码](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_2)\n\n首先是关于纹理的一些概念:\n\n>纹理是什么？纹理是一个用来保存图像的元素值的OGE缓存,就是颜色缓存；\n\n>当用一个图像初始化一个纹理缓存后，每一个像素就变成了纹理中的纹素（texel）；\n\n\n>像素通常表示屏幕上的一个实际的颜色点，纹素是在一个虚拟的坐标系中;\n\n\n>GPU会转换OGE坐标系中的每个点为帧缓存中的真实像素坐标（视口viewport坐标）；\n\n\n>转换几何形状数据为帧缓存中的颜色像素的过程叫做点阵化（rasterizing），每个颜色像素叫做片元（fragment）;\n\n\n>纹素决定片元的对齐过程，叫做映射（mapping）；\n\n\n>取样（sampling）是GPU从每个片元的U、V位置选择纹素的过程；\n\n\n>MIP贴图是为一个纹理存储多个细节的技术，它通过减少GPU的取样来提高渲染的性能；\n\n下面的例子展示了使用一个图片渲染的图片缓存：\n\n\n在`GLKViewController`中，设置OGE的上下文：\n\n\n```\n\tGLKView *view = (GLKView *)self.view;\n    view.backgroundColor = [UIColor whiteColor];\n   NSAssert([view isKindOfClass:[GLKView class]],\n      @\"View controller's view is not a GLKView\");\n   \n   view.context = [[AGLKContext alloc] \n      initWithAPI:kEAGLRenderingAPIOpenGLES2];\n   \n   // Make the new context current\n   [AGLKContext setCurrentContext:view.context];\n```\n\n上面的`AGLKContext`是`EAGLContext`的子类，`setCurrentContext:`是继承自父类的方法，设备当前上下文；\n\n设置提供基础功能:\n\n```\n// Create a base effect that provides standard OpenGL ES 2.0\n   // shading language programs and set constants to be used for \n   // all subsequent rendering\n   self.baseEffect = [[GLKBaseEffect alloc] init];\n   self.baseEffect.useConstantColor = GL_TRUE;\n   self.baseEffect.constantColor = GLKVector4Make(\n      1.0f, // Red\n      1.0f, // Green\n      1.0f, // Blue\n      1.0f);// Alpha\n```\n上面的这个constantColor,说是顶点缓冲，这里可能是顶点的颜色缓存，具体应该是与opengl相关的东西，这里这么用着，我改过这里的值，会修改渲染出来图的背景色，暂且认为是渲染用的一个底色吧；\n\n设置当前上下文的“清除颜色”：\n\n```\n// Set the background color stored in the current context\nGLKVector4 clearColorRGBA = GLKVector4Make(\n      1.0f, // Red\n      1.0f, // Green\n      1.0f, // Blue\n      1.0f);// Alpha \nglClearColor(\n      clearColorRGBA.r, \n      clearColorRGBA.g, \n      clearColorRGBA.b, \n      clearColorRGBA.a); \n```\n接下来要进行渲染图片了，大致与渲染一个三角形的过程差不多，可对照[开始OpenGLES的探索](http://uwuneng.com/opengles_start.html)，同样也是6步：\n\n这里我们自定义了一个`AGLKVertexAttribArrayBuffer`封装了关于一些OGE的操作，来说明一下：\n\n```\n// This data type is used to store information for each vertex\n//这个类型用来保存每个顶点的信息\n typedef struct {\n   GLKVector3  positionCoords;\n   GLKVector2  textureCoords;\n}SceneVertex;\n\n// Define    data for a triangle to use in example\n//定义三角形顶点\nstatic const SceneVertex vertices[] = \n{\n   {{-0.5f, -0.5f, 0.0f}, {0.0f, 0.0f}}, // lower left corner\n   {{ 0.5f, -0.5f, 0.0f}, {1.0f, 0.0f}}, // lower right corner\n   {{-0.5f,  0.5f, 0.0f}, {0.0f, 1.0f}}, // upper left corner\n};\n\n// Create vertex buffer containing vertices to draw\n//这里是定义渲染区域\n   self.vertexBuffer = [[AGLKVertexAttribArrayBuffer alloc]\n      initWithAttribStride:sizeof(SceneVertex)\n      numberOfVertices:sizeof(vertices) / sizeof(SceneVertex)\n      bytes:vertices\n      usage:GL_STATIC_DRAW];\n\nself.baseEffect.texture2d0.name = textureInfo.name;\nself.baseEffect.texture2d0.target = textureInfo.target;\n\n```\n\n下面是init方法：\n\n```\n// This method creates a vertex attribute array buffer in\n// the current OpenGL ES context for the thread upon which this \n// method is called.\n- (id)initWithAttribStride:(GLsizei)aStride\n   numberOfVertices:(GLsizei)count\n   bytes:(const GLvoid *)dataPtr\n   usage:(GLenum)usage;\n{\n   NSParameterAssert(0 < aStride);\n   NSAssert((0 < count && NULL != dataPtr) ||\n      (0 == count && NULL == dataPtr),\n      @\"data must not be NULL or count > 0\");\n      \n   if(nil != (self = [super init]))\n   {\n      stride = aStride;\n      bufferSizeBytes = stride * count;\n      \n      glGenBuffers(1,                // STEP 1\n         &name);\n      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2\n         self.name); \n      glBufferData(                  // STEP 3\n         GL_ARRAY_BUFFER,  // Initialize buffer contents\n         bufferSizeBytes,  // Number of bytes to copy\n         dataPtr,          // Address of bytes to copy\n         usage);           // Hint: cache in GPU memory\n         \n      NSAssert(0 != name, @\"Failed to generate name\");\n   }\n   \n   return self;\n}   \n```\n\n从这里可以看到图形渲染的前三步，生成缓存`glGenBuffers`，绑定缓存`glBindBuffer`，复制数据到缓存`glBufferData`；\n\n下面我们来进入今天的重点：\n\n```\n   // Setup texture\n   CGImageRef imageRef = \n      [[UIImage imageNamed:@\"leaves.gif\"] CGImage];\n      \n   AGLKTextureInfo *textureInfo = [AGLKTextureLoader \n      textureWithCGImage:imageRef \n      options:nil \n      error:NULL];\n   \n   self.baseEffect.texture2d0.name = textureInfo.name;\n   self.baseEffect.texture2d0.target = textureInfo.target;\n\n```\n`textureWithCGImage:`实现具体细节：\n\n```\n// This method generates a new OpenGL ES texture buffer and \n// initializes the buffer contents using pixel data from the \n// specified Core Graphics image, cgImage. This method returns an\n// immutable AGLKTextureInfo instance initialized with \n// information about the newly generated texture buffer.\n//    The generated texture buffer has power of 2 dimensions. The\n// provided image data is scaled (re-sampled) by Core Graphics as\n// necessary to fit within the generated texture buffer.\n\n+ (AGLKTextureInfo *)textureWithCGImage:(CGImageRef)cgImage\n                                options:(NSDictionary *)options\n   error:(NSError **)outError;\n{\n   // Get the bytes to be used when copying data into new texture\n   // buffer\n   size_t width;\n   size_t height;\n   NSData *imageData = AGLKDataWithResizedCGImageBytes(\n      cgImage,\n      &width,\n      &height);\n   \n   // Generation, bind, and copy data into a new texture buffer\n   GLuint      textureBufferID;\n   \n   glGenTextures(1, &textureBufferID);                  // Step 1\n   glBindTexture(GL_TEXTURE_2D, textureBufferID);       // Step 2\n   \n    //该函数是OGE最复杂的函数\n   glTexImage2D(                                        // Step 3\n      GL_TEXTURE_2D, //用于2D纹理\n      0, //指定MIP帖图的初始细节级别\n      GL_RGBA, //指定每个纹素需要保存信息的数量\n      (GLuint)width,//\n      (GLuint)height,\n      0, //围绕纹素的边界的大小,总是被设置为0\n      GL_RGBA, \n      GL_UNSIGNED_BYTE, \n      [imageData bytes]);\n   \n   // Set parameters that control texture sampling for the bound\n   // texture\n  glTexParameteri(GL_TEXTURE_2D,\n     GL_TEXTURE_MIN_FILTER, \n     GL_LINEAR); \n   \n   // Allocate and initialize the AGLKTextureInfo instance to be\n   // returned\n   AGLKTextureInfo *result = [[AGLKTextureInfo alloc] \n      initWithName:textureBufferID\n      target:GL_TEXTURE_2D\n      width:(GLuint)width\n      height:(GLuint)height];\n   \n   return result;\n}\n```\n\n上面这个方法使用Core Graphics图像的像素数据生成一个新的OGE缓存并初始化它，此方法返回一个不变的AGLKtextureinfo实例。\n\n解释一下这个方法`glTexParameteri`，该方法为创建的纹理缓存设置OGE取样和循环模式。如果使用了MIP贴图，第二个参数会被设置成GL_LINEAR_MIPMAP_LINEAR，这会告诉OGE使用与被取样的S,T坐标最接近的纹素的线性插值取样两个最合适的MIP贴图图像尺寸。然后，来自MIP贴图的两个样本被线性差值来产生最终的片元颜色。这里涉及的两个概念需要对opengl进行深入了解。\n\n\n其中`AGLKDataWithResizedCGImageBytes`把指定的cgImmage拖入imageData提供的字节中，Core Graphics把cgImage拖入一个适当大小的Core Graphics上下文中，这个过程会把图像的尺寸调整为2的幂，图像在绘制的时候还会被上下翻转，这是因为OGE的原点在左下角而iOS的实现原点却是在左上角，翻转Y轴确保了图像字节拥有适用于纹理缓存的正确的方向。\n\n```\nstatic NSData *AGLKDataWithResizedCGImageBytes(\n   CGImageRef cgImage,\n   size_t *widthPtr,\n   size_t *heightPtr)\n{\n   NSCParameterAssert(NULL != cgImage);\n   NSCParameterAssert(NULL != widthPtr);\n   NSCParameterAssert(NULL != heightPtr);\n   \n   GLuint originalWidth = (GLuint)CGImageGetWidth(cgImage);\n   GLuint originalHeight = (GLuint)CGImageGetWidth(cgImage);\n   \n   NSCAssert(0 < originalWidth, @\"Invalid image width\");\n   NSCAssert(0 < originalHeight, @\"Invalid image width\");\n   \n   // Calculate the width and height of the new texture buffer\n   // The new texture buffer will have power of 2 dimensions.\n   GLuint width = AGLKCalculatePowerOf2ForDimension(\n      originalWidth);\n   GLuint height = AGLKCalculatePowerOf2ForDimension(\n      originalHeight);\n      \n      //注意这个函数AGLKCalculatePowerOf2ForDimension就是用来取整用的\n      \n   // Allocate sufficient storage for RGBA pixel color data with \n   // the power of 2 sizes specified\n   NSMutableData    *imageData = [NSMutableData dataWithLength:\n      height * width * 4];  // 4 bytes per RGBA pixel\n\n   NSCAssert(nil != imageData, \n      @\"Unable to allocate image storage\");\n   \n   // Create a Core Graphics context that draws into the \n   // allocated bytes\n   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n   CGContextRef cgContext = CGBitmapContextCreate( \n      [imageData mutableBytes], width, height, 8, \n      4 * width, colorSpace, \n      kCGImageAlphaPremultipliedLast);\n   CGColorSpaceRelease(colorSpace);\n   \n   // Flip the Core Graphics Y-axis for future drawing\n   CGContextTranslateCTM (cgContext, 0, height);\n   CGContextScaleCTM (cgContext, 1.0, -1.0);\n   \n   // Draw the loaded image into the Core Graphics context \n   // resizing as necessary\n   CGContextDrawImage(cgContext, CGRectMake(0, 0, width, height),\n      cgImage);\n   \n   CGContextRelease(cgContext);\n   \n   *widthPtr = width;\n   *heightPtr = height;\n   \n   return imageData;\n}\n```\n\n最后在glk回调中实现真正画图：\n\n```\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n   [self.baseEffect prepareToDraw];\n   \n   // Clear back frame buffer (erase previous drawing)\n   [(AGLKContext *)view.context clear:GL_COLOR_BUFFER_BIT];\n   \n   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribPosition\n      numberOfCoordinates:3\n      attribOffset:offsetof(SceneVertex, positionCoords)\n      shouldEnable:YES];\n   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribTexCoord0\n      numberOfCoordinates:2\n      attribOffset:offsetof(SceneVertex, textureCoords)\n      shouldEnable:YES];\n      \n   // Draw triangles using the first three vertices in the \n   // currently bound vertex buffer\n   [self.vertexBuffer drawArrayWithMode:GL_TRIANGLES\n      startVertexIndex:0\n      numberOfVertices:3];\n}\n```\n\n`glEnableVertexAttribArray`,\n\n`glVertexAttribPointer`,\n\n`glDrawArrays`\n\n这里提前熟悉一下这些函数，虽然现在还是对它们不是太理解。\n\n后面的例子就不一一写了，过程笔记都在代码中，分别涉及到一些概念\n\n[OpenGLES_Ch3_3取样循环等](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_3)\n\n[OpenGLES_Ch3_4混合片元颜色](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_4)\n\n[OpenGLES_Ch3_5多重纹理](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_5)\n\n[OpenGLES_Ch3_6自定义纹理](https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_6)\n\n\n\n","slug":"OpenGLES-纹理的初步认识","published":1,"updated":"2018-05-04T10:27:12.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucio5000r1v60qqw8sa82","content":"<p>Summary:  上周看书学习OpenGLES关于纹理的知识，云里雾里的，看完的感觉是好多东西都明白，涉及到许多opengl的内容，不过照着书里的内容运行了几个Demo，大致算是有些总结，现做一下回顾，上几个例子。<br>不过这里有一点，这本书看完下一步还是要细研究一下opengl，初步决定从《计算机图形学》这本书入手。好了，之后的事情不多说，先做好当下的事情。</p>\n<a id=\"more\"></a>\n<h2 id=\"Demo-渲染图片Demo代码\"><a href=\"#Demo-渲染图片Demo代码\" class=\"headerlink\" title=\"Demo:渲染图片Demo代码\"></a>Demo:渲染图片<a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_2\" target=\"_blank\" rel=\"noopener\">Demo代码</a></h2><p>首先是关于纹理的一些概念:</p>\n<blockquote>\n<p>纹理是什么？纹理是一个用来保存图像的元素值的OGE缓存,就是颜色缓存；</p>\n</blockquote>\n<blockquote>\n<p>当用一个图像初始化一个纹理缓存后，每一个像素就变成了纹理中的纹素（texel）；</p>\n</blockquote>\n<blockquote>\n<p>像素通常表示屏幕上的一个实际的颜色点，纹素是在一个虚拟的坐标系中;</p>\n</blockquote>\n<blockquote>\n<p>GPU会转换OGE坐标系中的每个点为帧缓存中的真实像素坐标（视口viewport坐标）；</p>\n</blockquote>\n<blockquote>\n<p>转换几何形状数据为帧缓存中的颜色像素的过程叫做点阵化（rasterizing），每个颜色像素叫做片元（fragment）;</p>\n</blockquote>\n<blockquote>\n<p>纹素决定片元的对齐过程，叫做映射（mapping）；</p>\n</blockquote>\n<blockquote>\n<p>取样（sampling）是GPU从每个片元的U、V位置选择纹素的过程；</p>\n</blockquote>\n<blockquote>\n<p>MIP贴图是为一个纹理存储多个细节的技术，它通过减少GPU的取样来提高渲染的性能；</p>\n</blockquote>\n<p>下面的例子展示了使用一个图片渲染的图片缓存：</p>\n<p>在<code>GLKViewController</code>中，设置OGE的上下文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLKView *view = (GLKView *)self.view;</span><br><span class=\"line\">   view.backgroundColor = [UIColor whiteColor];</span><br><span class=\"line\">  NSAssert([view isKindOfClass:[GLKView class]],</span><br><span class=\"line\">     @&quot;View controller&apos;s view is not a GLKView&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  view.context = [[AGLKContext alloc] </span><br><span class=\"line\">     initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">  </span><br><span class=\"line\">  // Make the new context current</span><br><span class=\"line\">  [AGLKContext setCurrentContext:view.context];</span><br></pre></td></tr></table></figure>\n<p>上面的<code>AGLKContext</code>是<code>EAGLContext</code>的子类，<code>setCurrentContext:</code>是继承自父类的方法，设备当前上下文；</p>\n<p>设置提供基础功能:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create a base effect that provides standard OpenGL ES 2.0</span><br><span class=\"line\">   // shading language programs and set constants to be used for </span><br><span class=\"line\">   // all subsequent rendering</span><br><span class=\"line\">   self.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">   self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class=\"line\">   self.baseEffect.constantColor = GLKVector4Make(</span><br><span class=\"line\">      1.0f, // Red</span><br><span class=\"line\">      1.0f, // Green</span><br><span class=\"line\">      1.0f, // Blue</span><br><span class=\"line\">      1.0f);// Alpha</span><br></pre></td></tr></table></figure>\n<p>上面的这个constantColor,说是顶点缓冲，这里可能是顶点的颜色缓存，具体应该是与opengl相关的东西，这里这么用着，我改过这里的值，会修改渲染出来图的背景色，暂且认为是渲染用的一个底色吧；</p>\n<p>设置当前上下文的“清除颜色”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Set the background color stored in the current context</span><br><span class=\"line\">GLKVector4 clearColorRGBA = GLKVector4Make(</span><br><span class=\"line\">      1.0f, // Red</span><br><span class=\"line\">      1.0f, // Green</span><br><span class=\"line\">      1.0f, // Blue</span><br><span class=\"line\">      1.0f);// Alpha </span><br><span class=\"line\">glClearColor(</span><br><span class=\"line\">      clearColorRGBA.r, </span><br><span class=\"line\">      clearColorRGBA.g, </span><br><span class=\"line\">      clearColorRGBA.b, </span><br><span class=\"line\">      clearColorRGBA.a);</span><br></pre></td></tr></table></figure>\n<p>接下来要进行渲染图片了，大致与渲染一个三角形的过程差不多，可对照<a href=\"http://uwuneng.com/opengles_start.html\">开始OpenGLES的探索</a>，同样也是6步：</p>\n<p>这里我们自定义了一个<code>AGLKVertexAttribArrayBuffer</code>封装了关于一些OGE的操作，来说明一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This data type is used to store information for each vertex</span><br><span class=\"line\">//这个类型用来保存每个顶点的信息</span><br><span class=\"line\"> typedef struct &#123;</span><br><span class=\"line\">   GLKVector3  positionCoords;</span><br><span class=\"line\">   GLKVector2  textureCoords;</span><br><span class=\"line\">&#125;SceneVertex;</span><br><span class=\"line\"></span><br><span class=\"line\">// Define    data for a triangle to use in example</span><br><span class=\"line\">//定义三角形顶点</span><br><span class=\"line\">static const SceneVertex vertices[] = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &#123;&#123;-0.5f, -0.5f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, // lower left corner</span><br><span class=\"line\">   &#123;&#123; 0.5f, -0.5f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, // lower right corner</span><br><span class=\"line\">   &#123;&#123;-0.5f,  0.5f, 0.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;, // upper left corner</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create vertex buffer containing vertices to draw</span><br><span class=\"line\">//这里是定义渲染区域</span><br><span class=\"line\">   self.vertexBuffer = [[AGLKVertexAttribArrayBuffer alloc]</span><br><span class=\"line\">      initWithAttribStride:sizeof(SceneVertex)</span><br><span class=\"line\">      numberOfVertices:sizeof(vertices) / sizeof(SceneVertex)</span><br><span class=\"line\">      bytes:vertices</span><br><span class=\"line\">      usage:GL_STATIC_DRAW];</span><br><span class=\"line\"></span><br><span class=\"line\">self.baseEffect.texture2d0.name = textureInfo.name;</span><br><span class=\"line\">self.baseEffect.texture2d0.target = textureInfo.target;</span><br></pre></td></tr></table></figure>\n<p>下面是init方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method creates a vertex attribute array buffer in</span><br><span class=\"line\">// the current OpenGL ES context for the thread upon which this </span><br><span class=\"line\">// method is called.</span><br><span class=\"line\">- (id)initWithAttribStride:(GLsizei)aStride</span><br><span class=\"line\">   numberOfVertices:(GLsizei)count</span><br><span class=\"line\">   bytes:(const GLvoid *)dataPtr</span><br><span class=\"line\">   usage:(GLenum)usage;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSParameterAssert(0 &lt; aStride);</span><br><span class=\"line\">   NSAssert((0 &lt; count &amp;&amp; NULL != dataPtr) ||</span><br><span class=\"line\">      (0 == count &amp;&amp; NULL == dataPtr),</span><br><span class=\"line\">      @&quot;data must not be NULL or count &gt; 0&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   if(nil != (self = [super init]))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      stride = aStride;</span><br><span class=\"line\">      bufferSizeBytes = stride * count;</span><br><span class=\"line\">      </span><br><span class=\"line\">      glGenBuffers(1,                // STEP 1</span><br><span class=\"line\">         &amp;name);</span><br><span class=\"line\">      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class=\"line\">         self.name); </span><br><span class=\"line\">      glBufferData(                  // STEP 3</span><br><span class=\"line\">         GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class=\"line\">         bufferSizeBytes,  // Number of bytes to copy</span><br><span class=\"line\">         dataPtr,          // Address of bytes to copy</span><br><span class=\"line\">         usage);           // Hint: cache in GPU memory</span><br><span class=\"line\">         </span><br><span class=\"line\">      NSAssert(0 != name, @&quot;Failed to generate name&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到图形渲染的前三步，生成缓存<code>glGenBuffers</code>，绑定缓存<code>glBindBuffer</code>，复制数据到缓存<code>glBufferData</code>；</p>\n<p>下面我们来进入今天的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Setup texture</span><br><span class=\"line\">CGImageRef imageRef = </span><br><span class=\"line\">   [[UIImage imageNamed:@&quot;leaves.gif&quot;] CGImage];</span><br><span class=\"line\">   </span><br><span class=\"line\">AGLKTextureInfo *textureInfo = [AGLKTextureLoader </span><br><span class=\"line\">   textureWithCGImage:imageRef </span><br><span class=\"line\">   options:nil </span><br><span class=\"line\">   error:NULL];</span><br><span class=\"line\"></span><br><span class=\"line\">self.baseEffect.texture2d0.name = textureInfo.name;</span><br><span class=\"line\">self.baseEffect.texture2d0.target = textureInfo.target;</span><br></pre></td></tr></table></figure>\n<p><code>textureWithCGImage:</code>实现具体细节：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method generates a new OpenGL ES texture buffer and </span><br><span class=\"line\">// initializes the buffer contents using pixel data from the </span><br><span class=\"line\">// specified Core Graphics image, cgImage. This method returns an</span><br><span class=\"line\">// immutable AGLKTextureInfo instance initialized with </span><br><span class=\"line\">// information about the newly generated texture buffer.</span><br><span class=\"line\">//    The generated texture buffer has power of 2 dimensions. The</span><br><span class=\"line\">// provided image data is scaled (re-sampled) by Core Graphics as</span><br><span class=\"line\">// necessary to fit within the generated texture buffer.</span><br><span class=\"line\"></span><br><span class=\"line\">+ (AGLKTextureInfo *)textureWithCGImage:(CGImageRef)cgImage</span><br><span class=\"line\">                                options:(NSDictionary *)options</span><br><span class=\"line\">   error:(NSError **)outError;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   // Get the bytes to be used when copying data into new texture</span><br><span class=\"line\">   // buffer</span><br><span class=\"line\">   size_t width;</span><br><span class=\"line\">   size_t height;</span><br><span class=\"line\">   NSData *imageData = AGLKDataWithResizedCGImageBytes(</span><br><span class=\"line\">      cgImage,</span><br><span class=\"line\">      &amp;width,</span><br><span class=\"line\">      &amp;height);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Generation, bind, and copy data into a new texture buffer</span><br><span class=\"line\">   GLuint      textureBufferID;</span><br><span class=\"line\">   </span><br><span class=\"line\">   glGenTextures(1, &amp;textureBufferID);                  // Step 1</span><br><span class=\"line\">   glBindTexture(GL_TEXTURE_2D, textureBufferID);       // Step 2</span><br><span class=\"line\">   </span><br><span class=\"line\">    //该函数是OGE最复杂的函数</span><br><span class=\"line\">   glTexImage2D(                                        // Step 3</span><br><span class=\"line\">      GL_TEXTURE_2D, //用于2D纹理</span><br><span class=\"line\">      0, //指定MIP帖图的初始细节级别</span><br><span class=\"line\">      GL_RGBA, //指定每个纹素需要保存信息的数量</span><br><span class=\"line\">      (GLuint)width,//</span><br><span class=\"line\">      (GLuint)height,</span><br><span class=\"line\">      0, //围绕纹素的边界的大小,总是被设置为0</span><br><span class=\"line\">      GL_RGBA, </span><br><span class=\"line\">      GL_UNSIGNED_BYTE, </span><br><span class=\"line\">      [imageData bytes]);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Set parameters that control texture sampling for the bound</span><br><span class=\"line\">   // texture</span><br><span class=\"line\">  glTexParameteri(GL_TEXTURE_2D,</span><br><span class=\"line\">     GL_TEXTURE_MIN_FILTER, </span><br><span class=\"line\">     GL_LINEAR); </span><br><span class=\"line\">   </span><br><span class=\"line\">   // Allocate and initialize the AGLKTextureInfo instance to be</span><br><span class=\"line\">   // returned</span><br><span class=\"line\">   AGLKTextureInfo *result = [[AGLKTextureInfo alloc] </span><br><span class=\"line\">      initWithName:textureBufferID</span><br><span class=\"line\">      target:GL_TEXTURE_2D</span><br><span class=\"line\">      width:(GLuint)width</span><br><span class=\"line\">      height:(GLuint)height];</span><br><span class=\"line\">   </span><br><span class=\"line\">   return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个方法使用Core Graphics图像的像素数据生成一个新的OGE缓存并初始化它，此方法返回一个不变的AGLKtextureinfo实例。</p>\n<p>解释一下这个方法<code>glTexParameteri</code>，该方法为创建的纹理缓存设置OGE取样和循环模式。如果使用了MIP贴图，第二个参数会被设置成GL_LINEAR_MIPMAP_LINEAR，这会告诉OGE使用与被取样的S,T坐标最接近的纹素的线性插值取样两个最合适的MIP贴图图像尺寸。然后，来自MIP贴图的两个样本被线性差值来产生最终的片元颜色。这里涉及的两个概念需要对opengl进行深入了解。</p>\n<p>其中<code>AGLKDataWithResizedCGImageBytes</code>把指定的cgImmage拖入imageData提供的字节中，Core Graphics把cgImage拖入一个适当大小的Core Graphics上下文中，这个过程会把图像的尺寸调整为2的幂，图像在绘制的时候还会被上下翻转，这是因为OGE的原点在左下角而iOS的实现原点却是在左上角，翻转Y轴确保了图像字节拥有适用于纹理缓存的正确的方向。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static NSData *AGLKDataWithResizedCGImageBytes(</span><br><span class=\"line\">   CGImageRef cgImage,</span><br><span class=\"line\">   size_t *widthPtr,</span><br><span class=\"line\">   size_t *heightPtr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSCParameterAssert(NULL != cgImage);</span><br><span class=\"line\">   NSCParameterAssert(NULL != widthPtr);</span><br><span class=\"line\">   NSCParameterAssert(NULL != heightPtr);</span><br><span class=\"line\">   </span><br><span class=\"line\">   GLuint originalWidth = (GLuint)CGImageGetWidth(cgImage);</span><br><span class=\"line\">   GLuint originalHeight = (GLuint)CGImageGetWidth(cgImage);</span><br><span class=\"line\">   </span><br><span class=\"line\">   NSCAssert(0 &lt; originalWidth, @&quot;Invalid image width&quot;);</span><br><span class=\"line\">   NSCAssert(0 &lt; originalHeight, @&quot;Invalid image width&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Calculate the width and height of the new texture buffer</span><br><span class=\"line\">   // The new texture buffer will have power of 2 dimensions.</span><br><span class=\"line\">   GLuint width = AGLKCalculatePowerOf2ForDimension(</span><br><span class=\"line\">      originalWidth);</span><br><span class=\"line\">   GLuint height = AGLKCalculatePowerOf2ForDimension(</span><br><span class=\"line\">      originalHeight);</span><br><span class=\"line\">      </span><br><span class=\"line\">      //注意这个函数AGLKCalculatePowerOf2ForDimension就是用来取整用的</span><br><span class=\"line\">      </span><br><span class=\"line\">   // Allocate sufficient storage for RGBA pixel color data with </span><br><span class=\"line\">   // the power of 2 sizes specified</span><br><span class=\"line\">   NSMutableData    *imageData = [NSMutableData dataWithLength:</span><br><span class=\"line\">      height * width * 4];  // 4 bytes per RGBA pixel</span><br><span class=\"line\"></span><br><span class=\"line\">   NSCAssert(nil != imageData, </span><br><span class=\"line\">      @&quot;Unable to allocate image storage&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Create a Core Graphics context that draws into the </span><br><span class=\"line\">   // allocated bytes</span><br><span class=\"line\">   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">   CGContextRef cgContext = CGBitmapContextCreate( </span><br><span class=\"line\">      [imageData mutableBytes], width, height, 8, </span><br><span class=\"line\">      4 * width, colorSpace, </span><br><span class=\"line\">      kCGImageAlphaPremultipliedLast);</span><br><span class=\"line\">   CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Flip the Core Graphics Y-axis for future drawing</span><br><span class=\"line\">   CGContextTranslateCTM (cgContext, 0, height);</span><br><span class=\"line\">   CGContextScaleCTM (cgContext, 1.0, -1.0);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Draw the loaded image into the Core Graphics context </span><br><span class=\"line\">   // resizing as necessary</span><br><span class=\"line\">   CGContextDrawImage(cgContext, CGRectMake(0, 0, width, height),</span><br><span class=\"line\">      cgImage);</span><br><span class=\"line\">   </span><br><span class=\"line\">   CGContextRelease(cgContext);</span><br><span class=\"line\">   </span><br><span class=\"line\">   *widthPtr = width;</span><br><span class=\"line\">   *heightPtr = height;</span><br><span class=\"line\">   </span><br><span class=\"line\">   return imageData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后在glk回调中实现真正画图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [self.baseEffect prepareToDraw];</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Clear back frame buffer (erase previous drawing)</span><br><span class=\"line\">   [(AGLKContext *)view.context clear:GL_COLOR_BUFFER_BIT];</span><br><span class=\"line\">   </span><br><span class=\"line\">   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribPosition</span><br><span class=\"line\">      numberOfCoordinates:3</span><br><span class=\"line\">      attribOffset:offsetof(SceneVertex, positionCoords)</span><br><span class=\"line\">      shouldEnable:YES];</span><br><span class=\"line\">   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribTexCoord0</span><br><span class=\"line\">      numberOfCoordinates:2</span><br><span class=\"line\">      attribOffset:offsetof(SceneVertex, textureCoords)</span><br><span class=\"line\">      shouldEnable:YES];</span><br><span class=\"line\">      </span><br><span class=\"line\">   // Draw triangles using the first three vertices in the </span><br><span class=\"line\">   // currently bound vertex buffer</span><br><span class=\"line\">   [self.vertexBuffer drawArrayWithMode:GL_TRIANGLES</span><br><span class=\"line\">      startVertexIndex:0</span><br><span class=\"line\">      numberOfVertices:3];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glEnableVertexAttribArray</code>,</p>\n<p><code>glVertexAttribPointer</code>,</p>\n<p><code>glDrawArrays</code></p>\n<p>这里提前熟悉一下这些函数，虽然现在还是对它们不是太理解。</p>\n<p>后面的例子就不一一写了，过程笔记都在代码中，分别涉及到一些概念</p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_3\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_3取样循环等</a></p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_4\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_4混合片元颜色</a></p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_5\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_5多重纹理</a></p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_6\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_6自定义纹理</a></p>\n","site":{"data":{}},"excerpt":"<p>Summary:  上周看书学习OpenGLES关于纹理的知识，云里雾里的，看完的感觉是好多东西都明白，涉及到许多opengl的内容，不过照着书里的内容运行了几个Demo，大致算是有些总结，现做一下回顾，上几个例子。<br>不过这里有一点，这本书看完下一步还是要细研究一下opengl，初步决定从《计算机图形学》这本书入手。好了，之后的事情不多说，先做好当下的事情。</p>","more":"<h2 id=\"Demo-渲染图片Demo代码\"><a href=\"#Demo-渲染图片Demo代码\" class=\"headerlink\" title=\"Demo:渲染图片Demo代码\"></a>Demo:渲染图片<a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_2\" target=\"_blank\" rel=\"noopener\">Demo代码</a></h2><p>首先是关于纹理的一些概念:</p>\n<blockquote>\n<p>纹理是什么？纹理是一个用来保存图像的元素值的OGE缓存,就是颜色缓存；</p>\n</blockquote>\n<blockquote>\n<p>当用一个图像初始化一个纹理缓存后，每一个像素就变成了纹理中的纹素（texel）；</p>\n</blockquote>\n<blockquote>\n<p>像素通常表示屏幕上的一个实际的颜色点，纹素是在一个虚拟的坐标系中;</p>\n</blockquote>\n<blockquote>\n<p>GPU会转换OGE坐标系中的每个点为帧缓存中的真实像素坐标（视口viewport坐标）；</p>\n</blockquote>\n<blockquote>\n<p>转换几何形状数据为帧缓存中的颜色像素的过程叫做点阵化（rasterizing），每个颜色像素叫做片元（fragment）;</p>\n</blockquote>\n<blockquote>\n<p>纹素决定片元的对齐过程，叫做映射（mapping）；</p>\n</blockquote>\n<blockquote>\n<p>取样（sampling）是GPU从每个片元的U、V位置选择纹素的过程；</p>\n</blockquote>\n<blockquote>\n<p>MIP贴图是为一个纹理存储多个细节的技术，它通过减少GPU的取样来提高渲染的性能；</p>\n</blockquote>\n<p>下面的例子展示了使用一个图片渲染的图片缓存：</p>\n<p>在<code>GLKViewController</code>中，设置OGE的上下文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLKView *view = (GLKView *)self.view;</span><br><span class=\"line\">   view.backgroundColor = [UIColor whiteColor];</span><br><span class=\"line\">  NSAssert([view isKindOfClass:[GLKView class]],</span><br><span class=\"line\">     @&quot;View controller&apos;s view is not a GLKView&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  view.context = [[AGLKContext alloc] </span><br><span class=\"line\">     initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">  </span><br><span class=\"line\">  // Make the new context current</span><br><span class=\"line\">  [AGLKContext setCurrentContext:view.context];</span><br></pre></td></tr></table></figure>\n<p>上面的<code>AGLKContext</code>是<code>EAGLContext</code>的子类，<code>setCurrentContext:</code>是继承自父类的方法，设备当前上下文；</p>\n<p>设置提供基础功能:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create a base effect that provides standard OpenGL ES 2.0</span><br><span class=\"line\">   // shading language programs and set constants to be used for </span><br><span class=\"line\">   // all subsequent rendering</span><br><span class=\"line\">   self.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">   self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class=\"line\">   self.baseEffect.constantColor = GLKVector4Make(</span><br><span class=\"line\">      1.0f, // Red</span><br><span class=\"line\">      1.0f, // Green</span><br><span class=\"line\">      1.0f, // Blue</span><br><span class=\"line\">      1.0f);// Alpha</span><br></pre></td></tr></table></figure>\n<p>上面的这个constantColor,说是顶点缓冲，这里可能是顶点的颜色缓存，具体应该是与opengl相关的东西，这里这么用着，我改过这里的值，会修改渲染出来图的背景色，暂且认为是渲染用的一个底色吧；</p>\n<p>设置当前上下文的“清除颜色”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Set the background color stored in the current context</span><br><span class=\"line\">GLKVector4 clearColorRGBA = GLKVector4Make(</span><br><span class=\"line\">      1.0f, // Red</span><br><span class=\"line\">      1.0f, // Green</span><br><span class=\"line\">      1.0f, // Blue</span><br><span class=\"line\">      1.0f);// Alpha </span><br><span class=\"line\">glClearColor(</span><br><span class=\"line\">      clearColorRGBA.r, </span><br><span class=\"line\">      clearColorRGBA.g, </span><br><span class=\"line\">      clearColorRGBA.b, </span><br><span class=\"line\">      clearColorRGBA.a);</span><br></pre></td></tr></table></figure>\n<p>接下来要进行渲染图片了，大致与渲染一个三角形的过程差不多，可对照<a href=\"http://uwuneng.com/opengles_start.html\">开始OpenGLES的探索</a>，同样也是6步：</p>\n<p>这里我们自定义了一个<code>AGLKVertexAttribArrayBuffer</code>封装了关于一些OGE的操作，来说明一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This data type is used to store information for each vertex</span><br><span class=\"line\">//这个类型用来保存每个顶点的信息</span><br><span class=\"line\"> typedef struct &#123;</span><br><span class=\"line\">   GLKVector3  positionCoords;</span><br><span class=\"line\">   GLKVector2  textureCoords;</span><br><span class=\"line\">&#125;SceneVertex;</span><br><span class=\"line\"></span><br><span class=\"line\">// Define    data for a triangle to use in example</span><br><span class=\"line\">//定义三角形顶点</span><br><span class=\"line\">static const SceneVertex vertices[] = </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   &#123;&#123;-0.5f, -0.5f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, // lower left corner</span><br><span class=\"line\">   &#123;&#123; 0.5f, -0.5f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, // lower right corner</span><br><span class=\"line\">   &#123;&#123;-0.5f,  0.5f, 0.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;, // upper left corner</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create vertex buffer containing vertices to draw</span><br><span class=\"line\">//这里是定义渲染区域</span><br><span class=\"line\">   self.vertexBuffer = [[AGLKVertexAttribArrayBuffer alloc]</span><br><span class=\"line\">      initWithAttribStride:sizeof(SceneVertex)</span><br><span class=\"line\">      numberOfVertices:sizeof(vertices) / sizeof(SceneVertex)</span><br><span class=\"line\">      bytes:vertices</span><br><span class=\"line\">      usage:GL_STATIC_DRAW];</span><br><span class=\"line\"></span><br><span class=\"line\">self.baseEffect.texture2d0.name = textureInfo.name;</span><br><span class=\"line\">self.baseEffect.texture2d0.target = textureInfo.target;</span><br></pre></td></tr></table></figure>\n<p>下面是init方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method creates a vertex attribute array buffer in</span><br><span class=\"line\">// the current OpenGL ES context for the thread upon which this </span><br><span class=\"line\">// method is called.</span><br><span class=\"line\">- (id)initWithAttribStride:(GLsizei)aStride</span><br><span class=\"line\">   numberOfVertices:(GLsizei)count</span><br><span class=\"line\">   bytes:(const GLvoid *)dataPtr</span><br><span class=\"line\">   usage:(GLenum)usage;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSParameterAssert(0 &lt; aStride);</span><br><span class=\"line\">   NSAssert((0 &lt; count &amp;&amp; NULL != dataPtr) ||</span><br><span class=\"line\">      (0 == count &amp;&amp; NULL == dataPtr),</span><br><span class=\"line\">      @&quot;data must not be NULL or count &gt; 0&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   if(nil != (self = [super init]))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      stride = aStride;</span><br><span class=\"line\">      bufferSizeBytes = stride * count;</span><br><span class=\"line\">      </span><br><span class=\"line\">      glGenBuffers(1,                // STEP 1</span><br><span class=\"line\">         &amp;name);</span><br><span class=\"line\">      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class=\"line\">         self.name); </span><br><span class=\"line\">      glBufferData(                  // STEP 3</span><br><span class=\"line\">         GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class=\"line\">         bufferSizeBytes,  // Number of bytes to copy</span><br><span class=\"line\">         dataPtr,          // Address of bytes to copy</span><br><span class=\"line\">         usage);           // Hint: cache in GPU memory</span><br><span class=\"line\">         </span><br><span class=\"line\">      NSAssert(0 != name, @&quot;Failed to generate name&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从这里可以看到图形渲染的前三步，生成缓存<code>glGenBuffers</code>，绑定缓存<code>glBindBuffer</code>，复制数据到缓存<code>glBufferData</code>；</p>\n<p>下面我们来进入今天的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Setup texture</span><br><span class=\"line\">CGImageRef imageRef = </span><br><span class=\"line\">   [[UIImage imageNamed:@&quot;leaves.gif&quot;] CGImage];</span><br><span class=\"line\">   </span><br><span class=\"line\">AGLKTextureInfo *textureInfo = [AGLKTextureLoader </span><br><span class=\"line\">   textureWithCGImage:imageRef </span><br><span class=\"line\">   options:nil </span><br><span class=\"line\">   error:NULL];</span><br><span class=\"line\"></span><br><span class=\"line\">self.baseEffect.texture2d0.name = textureInfo.name;</span><br><span class=\"line\">self.baseEffect.texture2d0.target = textureInfo.target;</span><br></pre></td></tr></table></figure>\n<p><code>textureWithCGImage:</code>实现具体细节：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method generates a new OpenGL ES texture buffer and </span><br><span class=\"line\">// initializes the buffer contents using pixel data from the </span><br><span class=\"line\">// specified Core Graphics image, cgImage. This method returns an</span><br><span class=\"line\">// immutable AGLKTextureInfo instance initialized with </span><br><span class=\"line\">// information about the newly generated texture buffer.</span><br><span class=\"line\">//    The generated texture buffer has power of 2 dimensions. The</span><br><span class=\"line\">// provided image data is scaled (re-sampled) by Core Graphics as</span><br><span class=\"line\">// necessary to fit within the generated texture buffer.</span><br><span class=\"line\"></span><br><span class=\"line\">+ (AGLKTextureInfo *)textureWithCGImage:(CGImageRef)cgImage</span><br><span class=\"line\">                                options:(NSDictionary *)options</span><br><span class=\"line\">   error:(NSError **)outError;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   // Get the bytes to be used when copying data into new texture</span><br><span class=\"line\">   // buffer</span><br><span class=\"line\">   size_t width;</span><br><span class=\"line\">   size_t height;</span><br><span class=\"line\">   NSData *imageData = AGLKDataWithResizedCGImageBytes(</span><br><span class=\"line\">      cgImage,</span><br><span class=\"line\">      &amp;width,</span><br><span class=\"line\">      &amp;height);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Generation, bind, and copy data into a new texture buffer</span><br><span class=\"line\">   GLuint      textureBufferID;</span><br><span class=\"line\">   </span><br><span class=\"line\">   glGenTextures(1, &amp;textureBufferID);                  // Step 1</span><br><span class=\"line\">   glBindTexture(GL_TEXTURE_2D, textureBufferID);       // Step 2</span><br><span class=\"line\">   </span><br><span class=\"line\">    //该函数是OGE最复杂的函数</span><br><span class=\"line\">   glTexImage2D(                                        // Step 3</span><br><span class=\"line\">      GL_TEXTURE_2D, //用于2D纹理</span><br><span class=\"line\">      0, //指定MIP帖图的初始细节级别</span><br><span class=\"line\">      GL_RGBA, //指定每个纹素需要保存信息的数量</span><br><span class=\"line\">      (GLuint)width,//</span><br><span class=\"line\">      (GLuint)height,</span><br><span class=\"line\">      0, //围绕纹素的边界的大小,总是被设置为0</span><br><span class=\"line\">      GL_RGBA, </span><br><span class=\"line\">      GL_UNSIGNED_BYTE, </span><br><span class=\"line\">      [imageData bytes]);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Set parameters that control texture sampling for the bound</span><br><span class=\"line\">   // texture</span><br><span class=\"line\">  glTexParameteri(GL_TEXTURE_2D,</span><br><span class=\"line\">     GL_TEXTURE_MIN_FILTER, </span><br><span class=\"line\">     GL_LINEAR); </span><br><span class=\"line\">   </span><br><span class=\"line\">   // Allocate and initialize the AGLKTextureInfo instance to be</span><br><span class=\"line\">   // returned</span><br><span class=\"line\">   AGLKTextureInfo *result = [[AGLKTextureInfo alloc] </span><br><span class=\"line\">      initWithName:textureBufferID</span><br><span class=\"line\">      target:GL_TEXTURE_2D</span><br><span class=\"line\">      width:(GLuint)width</span><br><span class=\"line\">      height:(GLuint)height];</span><br><span class=\"line\">   </span><br><span class=\"line\">   return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个方法使用Core Graphics图像的像素数据生成一个新的OGE缓存并初始化它，此方法返回一个不变的AGLKtextureinfo实例。</p>\n<p>解释一下这个方法<code>glTexParameteri</code>，该方法为创建的纹理缓存设置OGE取样和循环模式。如果使用了MIP贴图，第二个参数会被设置成GL_LINEAR_MIPMAP_LINEAR，这会告诉OGE使用与被取样的S,T坐标最接近的纹素的线性插值取样两个最合适的MIP贴图图像尺寸。然后，来自MIP贴图的两个样本被线性差值来产生最终的片元颜色。这里涉及的两个概念需要对opengl进行深入了解。</p>\n<p>其中<code>AGLKDataWithResizedCGImageBytes</code>把指定的cgImmage拖入imageData提供的字节中，Core Graphics把cgImage拖入一个适当大小的Core Graphics上下文中，这个过程会把图像的尺寸调整为2的幂，图像在绘制的时候还会被上下翻转，这是因为OGE的原点在左下角而iOS的实现原点却是在左上角，翻转Y轴确保了图像字节拥有适用于纹理缓存的正确的方向。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static NSData *AGLKDataWithResizedCGImageBytes(</span><br><span class=\"line\">   CGImageRef cgImage,</span><br><span class=\"line\">   size_t *widthPtr,</span><br><span class=\"line\">   size_t *heightPtr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSCParameterAssert(NULL != cgImage);</span><br><span class=\"line\">   NSCParameterAssert(NULL != widthPtr);</span><br><span class=\"line\">   NSCParameterAssert(NULL != heightPtr);</span><br><span class=\"line\">   </span><br><span class=\"line\">   GLuint originalWidth = (GLuint)CGImageGetWidth(cgImage);</span><br><span class=\"line\">   GLuint originalHeight = (GLuint)CGImageGetWidth(cgImage);</span><br><span class=\"line\">   </span><br><span class=\"line\">   NSCAssert(0 &lt; originalWidth, @&quot;Invalid image width&quot;);</span><br><span class=\"line\">   NSCAssert(0 &lt; originalHeight, @&quot;Invalid image width&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Calculate the width and height of the new texture buffer</span><br><span class=\"line\">   // The new texture buffer will have power of 2 dimensions.</span><br><span class=\"line\">   GLuint width = AGLKCalculatePowerOf2ForDimension(</span><br><span class=\"line\">      originalWidth);</span><br><span class=\"line\">   GLuint height = AGLKCalculatePowerOf2ForDimension(</span><br><span class=\"line\">      originalHeight);</span><br><span class=\"line\">      </span><br><span class=\"line\">      //注意这个函数AGLKCalculatePowerOf2ForDimension就是用来取整用的</span><br><span class=\"line\">      </span><br><span class=\"line\">   // Allocate sufficient storage for RGBA pixel color data with </span><br><span class=\"line\">   // the power of 2 sizes specified</span><br><span class=\"line\">   NSMutableData    *imageData = [NSMutableData dataWithLength:</span><br><span class=\"line\">      height * width * 4];  // 4 bytes per RGBA pixel</span><br><span class=\"line\"></span><br><span class=\"line\">   NSCAssert(nil != imageData, </span><br><span class=\"line\">      @&quot;Unable to allocate image storage&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Create a Core Graphics context that draws into the </span><br><span class=\"line\">   // allocated bytes</span><br><span class=\"line\">   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class=\"line\">   CGContextRef cgContext = CGBitmapContextCreate( </span><br><span class=\"line\">      [imageData mutableBytes], width, height, 8, </span><br><span class=\"line\">      4 * width, colorSpace, </span><br><span class=\"line\">      kCGImageAlphaPremultipliedLast);</span><br><span class=\"line\">   CGColorSpaceRelease(colorSpace);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Flip the Core Graphics Y-axis for future drawing</span><br><span class=\"line\">   CGContextTranslateCTM (cgContext, 0, height);</span><br><span class=\"line\">   CGContextScaleCTM (cgContext, 1.0, -1.0);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Draw the loaded image into the Core Graphics context </span><br><span class=\"line\">   // resizing as necessary</span><br><span class=\"line\">   CGContextDrawImage(cgContext, CGRectMake(0, 0, width, height),</span><br><span class=\"line\">      cgImage);</span><br><span class=\"line\">   </span><br><span class=\"line\">   CGContextRelease(cgContext);</span><br><span class=\"line\">   </span><br><span class=\"line\">   *widthPtr = width;</span><br><span class=\"line\">   *heightPtr = height;</span><br><span class=\"line\">   </span><br><span class=\"line\">   return imageData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后在glk回调中实现真正画图：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [self.baseEffect prepareToDraw];</span><br><span class=\"line\">   </span><br><span class=\"line\">   // Clear back frame buffer (erase previous drawing)</span><br><span class=\"line\">   [(AGLKContext *)view.context clear:GL_COLOR_BUFFER_BIT];</span><br><span class=\"line\">   </span><br><span class=\"line\">   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribPosition</span><br><span class=\"line\">      numberOfCoordinates:3</span><br><span class=\"line\">      attribOffset:offsetof(SceneVertex, positionCoords)</span><br><span class=\"line\">      shouldEnable:YES];</span><br><span class=\"line\">   [self.vertexBuffer prepareToDrawWithAttrib:GLKVertexAttribTexCoord0</span><br><span class=\"line\">      numberOfCoordinates:2</span><br><span class=\"line\">      attribOffset:offsetof(SceneVertex, textureCoords)</span><br><span class=\"line\">      shouldEnable:YES];</span><br><span class=\"line\">      </span><br><span class=\"line\">   // Draw triangles using the first three vertices in the </span><br><span class=\"line\">   // currently bound vertex buffer</span><br><span class=\"line\">   [self.vertexBuffer drawArrayWithMode:GL_TRIANGLES</span><br><span class=\"line\">      startVertexIndex:0</span><br><span class=\"line\">      numberOfVertices:3];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glEnableVertexAttribArray</code>,</p>\n<p><code>glVertexAttribPointer</code>,</p>\n<p><code>glDrawArrays</code></p>\n<p>这里提前熟悉一下这些函数，虽然现在还是对它们不是太理解。</p>\n<p>后面的例子就不一一写了，过程笔记都在代码中，分别涉及到一些概念</p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_3\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_3取样循环等</a></p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_4\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_4混合片元颜色</a></p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_5\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_5多重纹理</a></p>\n<p><a href=\"https://github.com/usiege/OpenGLES_iOS/tree/master/OpenGLES_Ch_3_纹理/OpenGLES_Ch3_6\" target=\"_blank\" rel=\"noopener\">OpenGLES_Ch3_6自定义纹理</a></p>"},{"title":"Python-django安装","date":"2017-10-25T11:56:00.000Z","_content":"django \n<!-- more -->\n\n1. 发现错误\n![image_1bt9d9b27bv5glj1a0m15hr1ncn9.png-258.7kB][1]\n怀疑是pip版本的问题；\n\n2. 于是查了下更新pip的方法： \n\n查看pip版本\n```\npip -version\n```\n升级方法\n```\npip install -U pip\n```\n如果pip出现有问题，或者你花了很长的时间想用pip安装，例如使用下面这种方式：\n```\npip install Django==1.8.16\n```\n\n如果你刚好安装成功，那么恭喜你；如果不是，那么我们就要使用另外一种方法； \n3. 下载安装\n\n[gzip压缩包][2]\n\n或者：\n```\ngit clone https://github.com/django/django.git\n```\n下载完成之后：\n```\ntar -xvf django-master.tar.gz\ncd django-master\npython setup.py install\n```\n会出现下面的问题：\n![image_1bt9ib15m8juqh01adb1hlb154k9.png-97.5kB][3]\n继续找：\nBecause you're trying to install it on Python2, but the latest version of Django requires Python 3;\n所以使用安装方法：\n```\npip3 install -e django\n```\n这个仍然是联网安装，但是貌似`pytz`并不能连接上，vpn也不行；\n所以:\n```\ncd django\npython3 setup.py install\n```\n终于，你的django完成了；\n\n续：\n隔天使用以上的所有方法均可以，可能是十九大开会期间被墙掉了吧。\n![image_1btbid9ijfnd1q2i15npd78l9p9.png-253.6kB][4]\n\n\n  [1]: http://static.zybuluo.com/usiege/tvcs5iet0ge1yypcquu2swdq/image_1bt9d9b27bv5glj1a0m15hr1ncn9.png\n  [2]: https://github.com/django/django/archive/master.tar.gz\n  [3]: http://static.zybuluo.com/usiege/skgzjd12wfs2u973aidsrk7o/image_1bt9ib15m8juqh01adb1hlb154k9.png\n  [4]: http://static.zybuluo.com/usiege/06h0phv3szekmv2l4x2cmurb/image_1btbid9ijfnd1q2i15npd78l9p9.png","source":"_posts/Python-django安装.md","raw":"title: Python-django安装\ndate: 2017-10-25 19:56:00\ncategories: coder\ntags: [python, django]\n-----------\ndjango \n<!-- more -->\n\n1. 发现错误\n![image_1bt9d9b27bv5glj1a0m15hr1ncn9.png-258.7kB][1]\n怀疑是pip版本的问题；\n\n2. 于是查了下更新pip的方法： \n\n查看pip版本\n```\npip -version\n```\n升级方法\n```\npip install -U pip\n```\n如果pip出现有问题，或者你花了很长的时间想用pip安装，例如使用下面这种方式：\n```\npip install Django==1.8.16\n```\n\n如果你刚好安装成功，那么恭喜你；如果不是，那么我们就要使用另外一种方法； \n3. 下载安装\n\n[gzip压缩包][2]\n\n或者：\n```\ngit clone https://github.com/django/django.git\n```\n下载完成之后：\n```\ntar -xvf django-master.tar.gz\ncd django-master\npython setup.py install\n```\n会出现下面的问题：\n![image_1bt9ib15m8juqh01adb1hlb154k9.png-97.5kB][3]\n继续找：\nBecause you're trying to install it on Python2, but the latest version of Django requires Python 3;\n所以使用安装方法：\n```\npip3 install -e django\n```\n这个仍然是联网安装，但是貌似`pytz`并不能连接上，vpn也不行；\n所以:\n```\ncd django\npython3 setup.py install\n```\n终于，你的django完成了；\n\n续：\n隔天使用以上的所有方法均可以，可能是十九大开会期间被墙掉了吧。\n![image_1btbid9ijfnd1q2i15npd78l9p9.png-253.6kB][4]\n\n\n  [1]: http://static.zybuluo.com/usiege/tvcs5iet0ge1yypcquu2swdq/image_1bt9d9b27bv5glj1a0m15hr1ncn9.png\n  [2]: https://github.com/django/django/archive/master.tar.gz\n  [3]: http://static.zybuluo.com/usiege/skgzjd12wfs2u973aidsrk7o/image_1bt9ib15m8juqh01adb1hlb154k9.png\n  [4]: http://static.zybuluo.com/usiege/06h0phv3szekmv2l4x2cmurb/image_1btbid9ijfnd1q2i15npd78l9p9.png","slug":"Python-django安装","published":1,"updated":"2018-05-04T09:05:13.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucio6000u1v60wupdd0xz","content":"<p>django<br><a id=\"more\"></a></p>\n<ol>\n<li><p>发现错误<br><img src=\"http://static.zybuluo.com/usiege/tvcs5iet0ge1yypcquu2swdq/image_1bt9d9b27bv5glj1a0m15hr1ncn9.png\" alt=\"image_1bt9d9b27bv5glj1a0m15hr1ncn9.png-258.7kB\"><br>怀疑是pip版本的问题；</p>\n</li>\n<li><p>于是查了下更新pip的方法： </p>\n</li>\n</ol>\n<p>查看pip版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip -version</span><br></pre></td></tr></table></figure></p>\n<p>升级方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U pip</span><br></pre></td></tr></table></figure></p>\n<p>如果pip出现有问题，或者你花了很长的时间想用pip安装，例如使用下面这种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install Django==1.8.16</span><br></pre></td></tr></table></figure></p>\n<p>如果你刚好安装成功，那么恭喜你；如果不是，那么我们就要使用另外一种方法； </p>\n<ol start=\"3\">\n<li>下载安装</li>\n</ol>\n<p><a href=\"https://github.com/django/django/archive/master.tar.gz\" target=\"_blank\" rel=\"noopener\">gzip压缩包</a></p>\n<p>或者：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/django/django.git</span><br></pre></td></tr></table></figure></p>\n<p>下载完成之后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf django-master.tar.gz</span><br><span class=\"line\">cd django-master</span><br><span class=\"line\">python setup.py install</span><br></pre></td></tr></table></figure></p>\n<p>会出现下面的问题：<br><img src=\"http://static.zybuluo.com/usiege/skgzjd12wfs2u973aidsrk7o/image_1bt9ib15m8juqh01adb1hlb154k9.png\" alt=\"image_1bt9ib15m8juqh01adb1hlb154k9.png-97.5kB\"><br>继续找：<br>Because you’re trying to install it on Python2, but the latest version of Django requires Python 3;<br>所以使用安装方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install -e django</span><br></pre></td></tr></table></figure></p>\n<p>这个仍然是联网安装，但是貌似<code>pytz</code>并不能连接上，vpn也不行；<br>所以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd django</span><br><span class=\"line\">python3 setup.py install</span><br></pre></td></tr></table></figure></p>\n<p>终于，你的django完成了；</p>\n<p>续：<br>隔天使用以上的所有方法均可以，可能是十九大开会期间被墙掉了吧。<br><img src=\"http://static.zybuluo.com/usiege/06h0phv3szekmv2l4x2cmurb/image_1btbid9ijfnd1q2i15npd78l9p9.png\" alt=\"image_1btbid9ijfnd1q2i15npd78l9p9.png-253.6kB\"></p>\n","site":{"data":{}},"excerpt":"<p>django<br>","more":"</p>\n<ol>\n<li><p>发现错误<br><img src=\"http://static.zybuluo.com/usiege/tvcs5iet0ge1yypcquu2swdq/image_1bt9d9b27bv5glj1a0m15hr1ncn9.png\" alt=\"image_1bt9d9b27bv5glj1a0m15hr1ncn9.png-258.7kB\"><br>怀疑是pip版本的问题；</p>\n</li>\n<li><p>于是查了下更新pip的方法： </p>\n</li>\n</ol>\n<p>查看pip版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip -version</span><br></pre></td></tr></table></figure></p>\n<p>升级方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -U pip</span><br></pre></td></tr></table></figure></p>\n<p>如果pip出现有问题，或者你花了很长的时间想用pip安装，例如使用下面这种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install Django==1.8.16</span><br></pre></td></tr></table></figure></p>\n<p>如果你刚好安装成功，那么恭喜你；如果不是，那么我们就要使用另外一种方法； </p>\n<ol start=\"3\">\n<li>下载安装</li>\n</ol>\n<p><a href=\"https://github.com/django/django/archive/master.tar.gz\" target=\"_blank\" rel=\"noopener\">gzip压缩包</a></p>\n<p>或者：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/django/django.git</span><br></pre></td></tr></table></figure></p>\n<p>下载完成之后：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf django-master.tar.gz</span><br><span class=\"line\">cd django-master</span><br><span class=\"line\">python setup.py install</span><br></pre></td></tr></table></figure></p>\n<p>会出现下面的问题：<br><img src=\"http://static.zybuluo.com/usiege/skgzjd12wfs2u973aidsrk7o/image_1bt9ib15m8juqh01adb1hlb154k9.png\" alt=\"image_1bt9ib15m8juqh01adb1hlb154k9.png-97.5kB\"><br>继续找：<br>Because you’re trying to install it on Python2, but the latest version of Django requires Python 3;<br>所以使用安装方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install -e django</span><br></pre></td></tr></table></figure></p>\n<p>这个仍然是联网安装，但是貌似<code>pytz</code>并不能连接上，vpn也不行；<br>所以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd django</span><br><span class=\"line\">python3 setup.py install</span><br></pre></td></tr></table></figure></p>\n<p>终于，你的django完成了；</p>\n<p>续：<br>隔天使用以上的所有方法均可以，可能是十九大开会期间被墙掉了吧。<br><img src=\"http://static.zybuluo.com/usiege/06h0phv3szekmv2l4x2cmurb/image_1btbid9ijfnd1q2i15npd78l9p9.png\" alt=\"image_1btbid9ijfnd1q2i15npd78l9p9.png-253.6kB\"></p>"},{"title":"Python抓取One网页上的内容","date":"2016-05-06T08:46:00.000Z","_content":"\nSummary: 本文是从微信推送内容中摘取下来的，其中某些内容进行了小的改动，本文作者在Mac 10.11.4下运行正常，脚本会存取网页上的内容并保存到本地txt文件中，文件中内容以json格式保存。\n<!-- more -->\n\n# 1.python环境搭建\n\n## 安装homebrew\n\n`/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n\n## 安装pip\n\n首先安装easy_install\n\n`curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python`\n\n接着\n\n`sudo easy_install pip`\n\n## 安装virtualenv\n\n`pip install virtualenv`\n\n## 安装request和beautifulsoup4\n\n`pip install requests beautifulsoup4`\n\n# 2.网页分析\n\n[请移步源网址，本文参考原文](https://mp.weixin.qq.com/s?__biz=MzA5ODUzOTA0OQ==&mid=2651688023&idx=1&sn=ce865e87c60777c52ff60c2381c1a353&scene=1&srcid=0505caJlTtmQucm6toGF6Qiw&key=b28b03434249256bfa726a59c0a981ca91726f8ece7ac2a4e4552ba24a316f23dd587233818175463c02bedea86bb34d&ascene=0&uin=MjA4NjU4OTk1&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.4+build(15E65)&version=11020201&pass_ticket=EVsyFUgOaslYvrzF%2Bee4tQMk2jt%2F5PtB04iRB0X4XzE%3D)\n\n# 3.python编码\n\n```python\nimport argparse\nimport re\nfrom multiprocessing import Pool\n\nimport requests\nimport bs4\n\nimport time\nimport json\nimport io\n\nroot_url = 'http://wufazhuce.com'\n\ndef get_url(num):\n\treturn root_url+'/one/'+str(num)\n\ndef get_urls(num):\n\turls = map(get_url,range(100,100+num))\n\treturn urls\n\ndef get_data(url):\n\tdataList = {}\n\tresponse = requests.get(url)\n\tif response.status_code != 200:\n\t\treturn {'noValue':'noValue'}\n\tsoup = bs4.BeautifulSoup(response.text,'html.parser')\n\tprint soup.title.string\n\tdataList['index'] = soup.title.string[4:7]\n\tfor meta in soup.select('meta'):\n\t\tif meta.get('name') == 'description':\n\t\t\tdataList['content'] = meta.get('content')\n\t\tdataList['imgUrl'] = soup.find_all('img')[1]['src']\n\treturn dataList\n\n\nif __name__ == '__main__':\n\tpool = Pool(4)\n\tdataList = []\n\turls = get_urls(10)\n\n\tstart = time.time()\n\tdataList = pool.map(get_data,urls)\n\tend = time.time()\n\n\tprint 'use:%.2f s'%(end-start)\n\tjsonData = json.dumps({'data':dataList})\n\twith open('data.txt','w') as outfile:\n\t\tjson.dump(jsonData,outfile)\n```\n\n\n","source":"_posts/Python抓取One网页上的内容.md","raw":"title: Python抓取One网页上的内容\ndate: 2016-05-06 16:46:00\ncategories: coder\ntags: [python, request, beautifulsoup4]\n-----------\n\nSummary: 本文是从微信推送内容中摘取下来的，其中某些内容进行了小的改动，本文作者在Mac 10.11.4下运行正常，脚本会存取网页上的内容并保存到本地txt文件中，文件中内容以json格式保存。\n<!-- more -->\n\n# 1.python环境搭建\n\n## 安装homebrew\n\n`/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n\n## 安装pip\n\n首先安装easy_install\n\n`curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python`\n\n接着\n\n`sudo easy_install pip`\n\n## 安装virtualenv\n\n`pip install virtualenv`\n\n## 安装request和beautifulsoup4\n\n`pip install requests beautifulsoup4`\n\n# 2.网页分析\n\n[请移步源网址，本文参考原文](https://mp.weixin.qq.com/s?__biz=MzA5ODUzOTA0OQ==&mid=2651688023&idx=1&sn=ce865e87c60777c52ff60c2381c1a353&scene=1&srcid=0505caJlTtmQucm6toGF6Qiw&key=b28b03434249256bfa726a59c0a981ca91726f8ece7ac2a4e4552ba24a316f23dd587233818175463c02bedea86bb34d&ascene=0&uin=MjA4NjU4OTk1&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.4+build(15E65)&version=11020201&pass_ticket=EVsyFUgOaslYvrzF%2Bee4tQMk2jt%2F5PtB04iRB0X4XzE%3D)\n\n# 3.python编码\n\n```python\nimport argparse\nimport re\nfrom multiprocessing import Pool\n\nimport requests\nimport bs4\n\nimport time\nimport json\nimport io\n\nroot_url = 'http://wufazhuce.com'\n\ndef get_url(num):\n\treturn root_url+'/one/'+str(num)\n\ndef get_urls(num):\n\turls = map(get_url,range(100,100+num))\n\treturn urls\n\ndef get_data(url):\n\tdataList = {}\n\tresponse = requests.get(url)\n\tif response.status_code != 200:\n\t\treturn {'noValue':'noValue'}\n\tsoup = bs4.BeautifulSoup(response.text,'html.parser')\n\tprint soup.title.string\n\tdataList['index'] = soup.title.string[4:7]\n\tfor meta in soup.select('meta'):\n\t\tif meta.get('name') == 'description':\n\t\t\tdataList['content'] = meta.get('content')\n\t\tdataList['imgUrl'] = soup.find_all('img')[1]['src']\n\treturn dataList\n\n\nif __name__ == '__main__':\n\tpool = Pool(4)\n\tdataList = []\n\turls = get_urls(10)\n\n\tstart = time.time()\n\tdataList = pool.map(get_data,urls)\n\tend = time.time()\n\n\tprint 'use:%.2f s'%(end-start)\n\tjsonData = json.dumps({'data':dataList})\n\twith open('data.txt','w') as outfile:\n\t\tjson.dump(jsonData,outfile)\n```\n\n\n","slug":"Python抓取One网页上的内容","published":1,"updated":"2018-05-04T08:49:25.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucio7000x1v604hc9tl4j","content":"<p>Summary: 本文是从微信推送内容中摘取下来的，其中某些内容进行了小的改动，本文作者在Mac 10.11.4下运行正常，脚本会存取网页上的内容并保存到本地txt文件中，文件中内容以json格式保存。<br><a id=\"more\"></a></p>\n<h1 id=\"1-python环境搭建\"><a href=\"#1-python环境搭建\" class=\"headerlink\" title=\"1.python环境搭建\"></a>1.python环境搭建</h1><h2 id=\"安装homebrew\"><a href=\"#安装homebrew\" class=\"headerlink\" title=\"安装homebrew\"></a>安装homebrew</h2><p><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>\n<h2 id=\"安装pip\"><a href=\"#安装pip\" class=\"headerlink\" title=\"安装pip\"></a>安装pip</h2><p>首先安装easy_install</p>\n<p><code>curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python</code></p>\n<p>接着</p>\n<p><code>sudo easy_install pip</code></p>\n<h2 id=\"安装virtualenv\"><a href=\"#安装virtualenv\" class=\"headerlink\" title=\"安装virtualenv\"></a>安装virtualenv</h2><p><code>pip install virtualenv</code></p>\n<h2 id=\"安装request和beautifulsoup4\"><a href=\"#安装request和beautifulsoup4\" class=\"headerlink\" title=\"安装request和beautifulsoup4\"></a>安装request和beautifulsoup4</h2><p><code>pip install requests beautifulsoup4</code></p>\n<h1 id=\"2-网页分析\"><a href=\"#2-网页分析\" class=\"headerlink\" title=\"2.网页分析\"></a>2.网页分析</h1><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA5ODUzOTA0OQ==&amp;mid=2651688023&amp;idx=1&amp;sn=ce865e87c60777c52ff60c2381c1a353&amp;scene=1&amp;srcid=0505caJlTtmQucm6toGF6Qiw&amp;key=b28b03434249256bfa726a59c0a981ca91726f8ece7ac2a4e4552ba24a316f23dd587233818175463c02bedea86bb34d&amp;ascene=0&amp;uin=MjA4NjU4OTk1&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.4+build(15E65\" target=\"_blank\" rel=\"noopener\">请移步源网址，本文参考原文</a>&amp;version=11020201&amp;pass_ticket=EVsyFUgOaslYvrzF%2Bee4tQMk2jt%2F5PtB04iRB0X4XzE%3D)</p>\n<h1 id=\"3-python编码\"><a href=\"#3-python编码\" class=\"headerlink\" title=\"3.python编码\"></a>3.python编码</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> bs4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> io</span><br><span class=\"line\"></span><br><span class=\"line\">root_url = <span class=\"string\">'http://wufazhuce.com'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_url</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root_url+<span class=\"string\">'/one/'</span>+str(num)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_urls</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">\turls = map(get_url,range(<span class=\"number\">100</span>,<span class=\"number\">100</span>+num))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> urls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_data</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">\tdataList = &#123;&#125;</span><br><span class=\"line\">\tresponse = requests.get(url)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> response.status_code != <span class=\"number\">200</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;<span class=\"string\">'noValue'</span>:<span class=\"string\">'noValue'</span>&#125;</span><br><span class=\"line\">\tsoup = bs4.BeautifulSoup(response.text,<span class=\"string\">'html.parser'</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">print</span> soup.title.string</span><br><span class=\"line\">\tdataList[<span class=\"string\">'index'</span>] = soup.title.string[<span class=\"number\">4</span>:<span class=\"number\">7</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> meta <span class=\"keyword\">in</span> soup.select(<span class=\"string\">'meta'</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> meta.get(<span class=\"string\">'name'</span>) == <span class=\"string\">'description'</span>:</span><br><span class=\"line\">\t\t\tdataList[<span class=\"string\">'content'</span>] = meta.get(<span class=\"string\">'content'</span>)</span><br><span class=\"line\">\t\tdataList[<span class=\"string\">'imgUrl'</span>] = soup.find_all(<span class=\"string\">'img'</span>)[<span class=\"number\">1</span>][<span class=\"string\">'src'</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dataList</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">\tpool = Pool(<span class=\"number\">4</span>)</span><br><span class=\"line\">\tdataList = []</span><br><span class=\"line\">\turls = get_urls(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tstart = time.time()</span><br><span class=\"line\">\tdataList = pool.map(get_data,urls)</span><br><span class=\"line\">\tend = time.time()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'use:%.2f s'</span>%(end-start)</span><br><span class=\"line\">\tjsonData = json.dumps(&#123;<span class=\"string\">'data'</span>:dataList&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">with</span> open(<span class=\"string\">'data.txt'</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> outfile:</span><br><span class=\"line\">\t\tjson.dump(jsonData,outfile)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Summary: 本文是从微信推送内容中摘取下来的，其中某些内容进行了小的改动，本文作者在Mac 10.11.4下运行正常，脚本会存取网页上的内容并保存到本地txt文件中，文件中内容以json格式保存。<br>","more":"</p>\n<h1 id=\"1-python环境搭建\"><a href=\"#1-python环境搭建\" class=\"headerlink\" title=\"1.python环境搭建\"></a>1.python环境搭建</h1><h2 id=\"安装homebrew\"><a href=\"#安装homebrew\" class=\"headerlink\" title=\"安装homebrew\"></a>安装homebrew</h2><p><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>\n<h2 id=\"安装pip\"><a href=\"#安装pip\" class=\"headerlink\" title=\"安装pip\"></a>安装pip</h2><p>首先安装easy_install</p>\n<p><code>curl https://bootstrap.pypa.io/ez_setup.py -o - | sudo python</code></p>\n<p>接着</p>\n<p><code>sudo easy_install pip</code></p>\n<h2 id=\"安装virtualenv\"><a href=\"#安装virtualenv\" class=\"headerlink\" title=\"安装virtualenv\"></a>安装virtualenv</h2><p><code>pip install virtualenv</code></p>\n<h2 id=\"安装request和beautifulsoup4\"><a href=\"#安装request和beautifulsoup4\" class=\"headerlink\" title=\"安装request和beautifulsoup4\"></a>安装request和beautifulsoup4</h2><p><code>pip install requests beautifulsoup4</code></p>\n<h1 id=\"2-网页分析\"><a href=\"#2-网页分析\" class=\"headerlink\" title=\"2.网页分析\"></a>2.网页分析</h1><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA5ODUzOTA0OQ==&amp;mid=2651688023&amp;idx=1&amp;sn=ce865e87c60777c52ff60c2381c1a353&amp;scene=1&amp;srcid=0505caJlTtmQucm6toGF6Qiw&amp;key=b28b03434249256bfa726a59c0a981ca91726f8ece7ac2a4e4552ba24a316f23dd587233818175463c02bedea86bb34d&amp;ascene=0&amp;uin=MjA4NjU4OTk1&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.4+build(15E65\" target=\"_blank\" rel=\"noopener\">请移步源网址，本文参考原文</a>&amp;version=11020201&amp;pass_ticket=EVsyFUgOaslYvrzF%2Bee4tQMk2jt%2F5PtB04iRB0X4XzE%3D)</p>\n<h1 id=\"3-python编码\"><a href=\"#3-python编码\" class=\"headerlink\" title=\"3.python编码\"></a>3.python编码</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> bs4</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> io</span><br><span class=\"line\"></span><br><span class=\"line\">root_url = <span class=\"string\">'http://wufazhuce.com'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_url</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root_url+<span class=\"string\">'/one/'</span>+str(num)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_urls</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">\turls = map(get_url,range(<span class=\"number\">100</span>,<span class=\"number\">100</span>+num))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> urls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_data</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">\tdataList = &#123;&#125;</span><br><span class=\"line\">\tresponse = requests.get(url)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> response.status_code != <span class=\"number\">200</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;<span class=\"string\">'noValue'</span>:<span class=\"string\">'noValue'</span>&#125;</span><br><span class=\"line\">\tsoup = bs4.BeautifulSoup(response.text,<span class=\"string\">'html.parser'</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">print</span> soup.title.string</span><br><span class=\"line\">\tdataList[<span class=\"string\">'index'</span>] = soup.title.string[<span class=\"number\">4</span>:<span class=\"number\">7</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> meta <span class=\"keyword\">in</span> soup.select(<span class=\"string\">'meta'</span>):</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> meta.get(<span class=\"string\">'name'</span>) == <span class=\"string\">'description'</span>:</span><br><span class=\"line\">\t\t\tdataList[<span class=\"string\">'content'</span>] = meta.get(<span class=\"string\">'content'</span>)</span><br><span class=\"line\">\t\tdataList[<span class=\"string\">'imgUrl'</span>] = soup.find_all(<span class=\"string\">'img'</span>)[<span class=\"number\">1</span>][<span class=\"string\">'src'</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dataList</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">\tpool = Pool(<span class=\"number\">4</span>)</span><br><span class=\"line\">\tdataList = []</span><br><span class=\"line\">\turls = get_urls(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tstart = time.time()</span><br><span class=\"line\">\tdataList = pool.map(get_data,urls)</span><br><span class=\"line\">\tend = time.time()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">'use:%.2f s'</span>%(end-start)</span><br><span class=\"line\">\tjsonData = json.dumps(&#123;<span class=\"string\">'data'</span>:dataList&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">with</span> open(<span class=\"string\">'data.txt'</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> outfile:</span><br><span class=\"line\">\t\tjson.dump(jsonData,outfile)</span><br></pre></td></tr></table></figure>"},{"title":"Swift Currying(柯里化)","date":"2018-01-06T08:34:00.000Z","_content":"Currying\n<!-- more -->\n\n1. 函数式编程思想\n\n先举一个小例子：\n```\nfunc addOne(count: Int) -> Int {\n    return count + 1\n}\n//上面这个代码我们是返回一个加和，和是使参数增加1；\n//一个更加灵活的方法，我们可以取消上面的硬编码1；\n\nfunc add(count: Int, addition: Int) -> Int {\n    return count + addition\n}\n//然而这个函数还并不是那么友好，我们用另外一种方法实现看一下：\nfunc add(_ addition: Int) -> (Int) -> Int {\n    return {\n        count in \n        return count + addition\n    }\n}\n\n//调用一下以上方法，看看有什么区别：\nlet number = add(count: 10, addition: 2)    //函数2\n\nlet add2 = add(2)           //函数3\nlet number = add2(10)\n\nlet number = add(2)(10)     //函数3调用连起来是\n//是不是觉得这种调用方式很熟悉，有点类似于\n//classname.property.subproperty，点语法链\n\n```\n显然这种编程方式更加灵活，所展现的内容更加直观，可以减少函数写N多的参数；当然函数式编程有的可不只是这些，更多内容不在本篇所讨论之内；\n    \n基于上例我们来写一个方法：\n```\nfunc greaterThan(_ comparer: Int) -> (Int) -> Bool {\n    return { $0 > comparer }\n}\n\nlet compareResult = greaterThan(10)(11)\n```\n很明显下面这个式子的调用直观的表达了参数10和参数11的大小；\n\n2. target-action例子\n\n我们来看国外网上的一个例子：\n```\nprotocol TargetAction {\n    func performAction()\n}\n\nstruct TargetActionWrapper<T: AnyObject>: TargetAction {\n    weak var target: T?\n    let action: (T) -> () -> (Void)\n    \n    func performAction() -> (Void) {\n        if let t = target {\n            action(t)()\n        }\n    }\n}\n//\nenum ControlEvent {\n    case TouchUpInside\n    case ValueChanged\n    // ...\n}              \n\nclass Control {\n\n    var actions = [ControlEvent: TargetAction]()\n    \n    convenience init<T: AnyObject>(_ target: T, action: @escaping (T) -> () -> (Void), controlEvent: ControlEvent) {\n        actions[controlEvent] = TargetActionWrapper(\n            target: target, action: action)\n    }\n    \n    func setTarget<T: AnyObject>(target: T, action: @escaping (T) -> () -> (Void), controlEvent: ControlEvent) {\n            \n            actions[controlEvent] = TargetActionWrapper(target: target, action: action)\n    }\n    \n    func removeTargetForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent] = nil\n    }\n    \n    func performActionForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent]?.performAction()\n    }\n}\n\n//我们来使用一下我们的模板\n\nfunc viewDidLoad() {\n    Control().setTarget(self, action: ViewController.tapAction, controlEvent: .touchUpInside)\n    }\n}\n\nfunc tapAction() {\n    print(\"单击了\")\n}\n\n//如果我们不是用实例方法调用而是自定义构造函数的话\n//我们能看到更好的表现方式\n\nfunc viewDidLoad() {\n    Control.init(self, action: ViewController.tapAction controlEvent: .touchUpInside)\n}\n\n//当然这个便利构造函数的例子用在这里并不是很合逻辑，但是我们只是想展现一下柯里化的内容\n```","source":"_posts/Swift Currying（柯里化）.md","raw":"title: Swift Currying(柯里化)\ndate: 2018-01-06 16:34:00\ncategories: coder\ntags: [swift]\n-----------\nCurrying\n<!-- more -->\n\n1. 函数式编程思想\n\n先举一个小例子：\n```\nfunc addOne(count: Int) -> Int {\n    return count + 1\n}\n//上面这个代码我们是返回一个加和，和是使参数增加1；\n//一个更加灵活的方法，我们可以取消上面的硬编码1；\n\nfunc add(count: Int, addition: Int) -> Int {\n    return count + addition\n}\n//然而这个函数还并不是那么友好，我们用另外一种方法实现看一下：\nfunc add(_ addition: Int) -> (Int) -> Int {\n    return {\n        count in \n        return count + addition\n    }\n}\n\n//调用一下以上方法，看看有什么区别：\nlet number = add(count: 10, addition: 2)    //函数2\n\nlet add2 = add(2)           //函数3\nlet number = add2(10)\n\nlet number = add(2)(10)     //函数3调用连起来是\n//是不是觉得这种调用方式很熟悉，有点类似于\n//classname.property.subproperty，点语法链\n\n```\n显然这种编程方式更加灵活，所展现的内容更加直观，可以减少函数写N多的参数；当然函数式编程有的可不只是这些，更多内容不在本篇所讨论之内；\n    \n基于上例我们来写一个方法：\n```\nfunc greaterThan(_ comparer: Int) -> (Int) -> Bool {\n    return { $0 > comparer }\n}\n\nlet compareResult = greaterThan(10)(11)\n```\n很明显下面这个式子的调用直观的表达了参数10和参数11的大小；\n\n2. target-action例子\n\n我们来看国外网上的一个例子：\n```\nprotocol TargetAction {\n    func performAction()\n}\n\nstruct TargetActionWrapper<T: AnyObject>: TargetAction {\n    weak var target: T?\n    let action: (T) -> () -> (Void)\n    \n    func performAction() -> (Void) {\n        if let t = target {\n            action(t)()\n        }\n    }\n}\n//\nenum ControlEvent {\n    case TouchUpInside\n    case ValueChanged\n    // ...\n}              \n\nclass Control {\n\n    var actions = [ControlEvent: TargetAction]()\n    \n    convenience init<T: AnyObject>(_ target: T, action: @escaping (T) -> () -> (Void), controlEvent: ControlEvent) {\n        actions[controlEvent] = TargetActionWrapper(\n            target: target, action: action)\n    }\n    \n    func setTarget<T: AnyObject>(target: T, action: @escaping (T) -> () -> (Void), controlEvent: ControlEvent) {\n            \n            actions[controlEvent] = TargetActionWrapper(target: target, action: action)\n    }\n    \n    func removeTargetForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent] = nil\n    }\n    \n    func performActionForControlEvent(controlEvent: ControlEvent) {\n        actions[controlEvent]?.performAction()\n    }\n}\n\n//我们来使用一下我们的模板\n\nfunc viewDidLoad() {\n    Control().setTarget(self, action: ViewController.tapAction, controlEvent: .touchUpInside)\n    }\n}\n\nfunc tapAction() {\n    print(\"单击了\")\n}\n\n//如果我们不是用实例方法调用而是自定义构造函数的话\n//我们能看到更好的表现方式\n\nfunc viewDidLoad() {\n    Control.init(self, action: ViewController.tapAction controlEvent: .touchUpInside)\n}\n\n//当然这个便利构造函数的例子用在这里并不是很合逻辑，但是我们只是想展现一下柯里化的内容\n```","slug":"Swift Currying（柯里化）","published":1,"updated":"2018-05-04T08:49:29.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucio900101v60m3bwjchs","content":"<p>Currying<br><a id=\"more\"></a></p>\n<ol>\n<li>函数式编程思想</li>\n</ol>\n<p>先举一个小例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func addOne(count: Int) -&gt; Int &#123;</span><br><span class=\"line\">    return count + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//上面这个代码我们是返回一个加和，和是使参数增加1；</span><br><span class=\"line\">//一个更加灵活的方法，我们可以取消上面的硬编码1；</span><br><span class=\"line\"></span><br><span class=\"line\">func add(count: Int, addition: Int) -&gt; Int &#123;</span><br><span class=\"line\">    return count + addition</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//然而这个函数还并不是那么友好，我们用另外一种方法实现看一下：</span><br><span class=\"line\">func add(_ addition: Int) -&gt; (Int) -&gt; Int &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        count in </span><br><span class=\"line\">        return count + addition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//调用一下以上方法，看看有什么区别：</span><br><span class=\"line\">let number = add(count: 10, addition: 2)    //函数2</span><br><span class=\"line\"></span><br><span class=\"line\">let add2 = add(2)           //函数3</span><br><span class=\"line\">let number = add2(10)</span><br><span class=\"line\"></span><br><span class=\"line\">let number = add(2)(10)     //函数3调用连起来是</span><br><span class=\"line\">//是不是觉得这种调用方式很熟悉，有点类似于</span><br><span class=\"line\">//classname.property.subproperty，点语法链</span><br></pre></td></tr></table></figure></p>\n<p>显然这种编程方式更加灵活，所展现的内容更加直观，可以减少函数写N多的参数；当然函数式编程有的可不只是这些，更多内容不在本篇所讨论之内；</p>\n<p>基于上例我们来写一个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;</span><br><span class=\"line\">    return &#123; $0 &gt; comparer &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let compareResult = greaterThan(10)(11)</span><br></pre></td></tr></table></figure></p>\n<p>很明显下面这个式子的调用直观的表达了参数10和参数11的大小；</p>\n<ol start=\"2\">\n<li>target-action例子</li>\n</ol>\n<p>我们来看国外网上的一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protocol TargetAction &#123;</span><br><span class=\"line\">    func performAction()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct TargetActionWrapper&lt;T: AnyObject&gt;: TargetAction &#123;</span><br><span class=\"line\">    weak var target: T?</span><br><span class=\"line\">    let action: (T) -&gt; () -&gt; (Void)</span><br><span class=\"line\">    </span><br><span class=\"line\">    func performAction() -&gt; (Void) &#123;</span><br><span class=\"line\">        if let t = target &#123;</span><br><span class=\"line\">            action(t)()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//</span><br><span class=\"line\">enum ControlEvent &#123;</span><br><span class=\"line\">    case TouchUpInside</span><br><span class=\"line\">    case ValueChanged</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;              </span><br><span class=\"line\"></span><br><span class=\"line\">class Control &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var actions = [ControlEvent: TargetAction]()</span><br><span class=\"line\">    </span><br><span class=\"line\">    convenience init&lt;T: AnyObject&gt;(_ target: T, action: @escaping (T) -&gt; () -&gt; (Void), controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">        actions[controlEvent] = TargetActionWrapper(</span><br><span class=\"line\">            target: target, action: action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    func setTarget&lt;T: AnyObject&gt;(target: T, action: @escaping (T) -&gt; () -&gt; (Void), controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            actions[controlEvent] = TargetActionWrapper(target: target, action: action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    func removeTargetForControlEvent(controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">        actions[controlEvent] = nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    func performActionForControlEvent(controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">        actions[controlEvent]?.performAction()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//我们来使用一下我们的模板</span><br><span class=\"line\"></span><br><span class=\"line\">func viewDidLoad() &#123;</span><br><span class=\"line\">    Control().setTarget(self, action: ViewController.tapAction, controlEvent: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func tapAction() &#123;</span><br><span class=\"line\">    print(&quot;单击了&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//如果我们不是用实例方法调用而是自定义构造函数的话</span><br><span class=\"line\">//我们能看到更好的表现方式</span><br><span class=\"line\"></span><br><span class=\"line\">func viewDidLoad() &#123;</span><br><span class=\"line\">    Control.init(self, action: ViewController.tapAction controlEvent: .touchUpInside)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//当然这个便利构造函数的例子用在这里并不是很合逻辑，但是我们只是想展现一下柯里化的内容</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Currying<br>","more":"</p>\n<ol>\n<li>函数式编程思想</li>\n</ol>\n<p>先举一个小例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func addOne(count: Int) -&gt; Int &#123;</span><br><span class=\"line\">    return count + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//上面这个代码我们是返回一个加和，和是使参数增加1；</span><br><span class=\"line\">//一个更加灵活的方法，我们可以取消上面的硬编码1；</span><br><span class=\"line\"></span><br><span class=\"line\">func add(count: Int, addition: Int) -&gt; Int &#123;</span><br><span class=\"line\">    return count + addition</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//然而这个函数还并不是那么友好，我们用另外一种方法实现看一下：</span><br><span class=\"line\">func add(_ addition: Int) -&gt; (Int) -&gt; Int &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        count in </span><br><span class=\"line\">        return count + addition</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//调用一下以上方法，看看有什么区别：</span><br><span class=\"line\">let number = add(count: 10, addition: 2)    //函数2</span><br><span class=\"line\"></span><br><span class=\"line\">let add2 = add(2)           //函数3</span><br><span class=\"line\">let number = add2(10)</span><br><span class=\"line\"></span><br><span class=\"line\">let number = add(2)(10)     //函数3调用连起来是</span><br><span class=\"line\">//是不是觉得这种调用方式很熟悉，有点类似于</span><br><span class=\"line\">//classname.property.subproperty，点语法链</span><br></pre></td></tr></table></figure></p>\n<p>显然这种编程方式更加灵活，所展现的内容更加直观，可以减少函数写N多的参数；当然函数式编程有的可不只是这些，更多内容不在本篇所讨论之内；</p>\n<p>基于上例我们来写一个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;</span><br><span class=\"line\">    return &#123; $0 &gt; comparer &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let compareResult = greaterThan(10)(11)</span><br></pre></td></tr></table></figure></p>\n<p>很明显下面这个式子的调用直观的表达了参数10和参数11的大小；</p>\n<ol start=\"2\">\n<li>target-action例子</li>\n</ol>\n<p>我们来看国外网上的一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protocol TargetAction &#123;</span><br><span class=\"line\">    func performAction()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct TargetActionWrapper&lt;T: AnyObject&gt;: TargetAction &#123;</span><br><span class=\"line\">    weak var target: T?</span><br><span class=\"line\">    let action: (T) -&gt; () -&gt; (Void)</span><br><span class=\"line\">    </span><br><span class=\"line\">    func performAction() -&gt; (Void) &#123;</span><br><span class=\"line\">        if let t = target &#123;</span><br><span class=\"line\">            action(t)()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//</span><br><span class=\"line\">enum ControlEvent &#123;</span><br><span class=\"line\">    case TouchUpInside</span><br><span class=\"line\">    case ValueChanged</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;              </span><br><span class=\"line\"></span><br><span class=\"line\">class Control &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var actions = [ControlEvent: TargetAction]()</span><br><span class=\"line\">    </span><br><span class=\"line\">    convenience init&lt;T: AnyObject&gt;(_ target: T, action: @escaping (T) -&gt; () -&gt; (Void), controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">        actions[controlEvent] = TargetActionWrapper(</span><br><span class=\"line\">            target: target, action: action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    func setTarget&lt;T: AnyObject&gt;(target: T, action: @escaping (T) -&gt; () -&gt; (Void), controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            actions[controlEvent] = TargetActionWrapper(target: target, action: action)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    func removeTargetForControlEvent(controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">        actions[controlEvent] = nil</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    func performActionForControlEvent(controlEvent: ControlEvent) &#123;</span><br><span class=\"line\">        actions[controlEvent]?.performAction()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//我们来使用一下我们的模板</span><br><span class=\"line\"></span><br><span class=\"line\">func viewDidLoad() &#123;</span><br><span class=\"line\">    Control().setTarget(self, action: ViewController.tapAction, controlEvent: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func tapAction() &#123;</span><br><span class=\"line\">    print(&quot;单击了&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//如果我们不是用实例方法调用而是自定义构造函数的话</span><br><span class=\"line\">//我们能看到更好的表现方式</span><br><span class=\"line\"></span><br><span class=\"line\">func viewDidLoad() &#123;</span><br><span class=\"line\">    Control.init(self, action: ViewController.tapAction controlEvent: .touchUpInside)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//当然这个便利构造函数的例子用在这里并不是很合逻辑，但是我们只是想展现一下柯里化的内容</span><br></pre></td></tr></table></figure></p>"},{"title":"Python-pelican搭建个人博客","date":"2015-12-11T01:23:00.000Z","_content":"\nSummary:  本文使用python pelican搭建个人静态博客，并上传到个人git仓库，实现访问个人博客，本文作者所用就是基于该博客的个人主页。\n<!-- more -->\n\n>PS：提升到系统root权限：$ sudo -s；\n\n### 1.安装git；\n### 2.安装pip过程：\n\n查看pythion安装目录：\n`$ which python`\n/usr/local/bin/python\n安装pip:\n`$ sudo easy_install pip`\n第一次输入时出现无法安装，则可以选择进行下面的安装；\n安装最新版本的python,pip&setuptools:\n`$ brew install python`\n>PS:brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，只需要一个命令,非常方便brew类似ubuntu系统下的apt-get的功能,http://brew.sh/ 安装方法如下：`$ ruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\"`\n\n详细请见：http://www.cnblogs.com/TankXiao/p/3247113.html\n### 3.安装virtualenv:\n\n`$ pip install virtualenv`\n### 4.创建虚拟环境：\n\n```\n$ virtualenv ~/virtualenv/pelican\n$ cd ~/virtualenvs/pelican\n$ source bin/activate\n```\n### 5.安装pelican：\n\n`$ pip install pelican`\n### 6.安装markdown,typogrify：\n\n`$ pip install markdown`\n`$ pip install typogrify`\n### 7.创建博客站点：\n\n```\n$ mkdir blog\n$ cd blog\n$ pelican-quickstart\n```\npelican-quickstart执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 命令成功执行后，会出现pelican的框架，如下所示\n\nblog/\n\n\n├── content                # 存放输入的markdown或RST源文件\n\n\n│   └── (pages)            # 存放手工创建的静态页面，可选\n\n\n│   └── (posts)            # 存放手工创建的文章，可选\n\n\n├── output                 # 存放最终生成的静态博客\n\n\n├── develop_server.sh      # 测试服务器\n\n\n├── Makefile               # 管理博客的Makefile\n\n\n├── pelicanconf.py         # 配置文件\n\n\n└── publishconf.py         # 发布文件，可删除\n\n\n\n### 8.选择博客主题：\n\n在blog目录下，各页面主题可以在这个网址查看Pelican themes  http://pelicanthemes.com/, 克隆主题开源库 https://github.com/getpelican/pelican-themes\n- 克隆主题到本地\n`$ git clone https://github.com/getpelican/pelican-themes.git`\n\n- 打开pelicanconf.py配置文件，更改或添加THEME为自己喜欢的主题，例如本博客所挑选的elegant，更多的配置含义请关注官方文档。\n- 注意下面的这个主题需要填主题的目录路径\n\n`THEME = 'pelican-themes/gum'`\n\n添加评论系统:\n\n开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。在Disqus上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。然后同理，在pelicanconf.py添加\n\n`DISQUS_SITENAME = Shortname`\n\n生成博客站点:\n\n`$ Site generation`\n\n`$ pelican /path/to/your/content/ [-s path/to/your/settings.py]`\n\n\nPS：上面的这个路径是你自己博客的content路径；\n\n预览生成的站点\n\nFor Python 2, run:\n\n```\n$ cd output\n$ python -m SimpleHTTPServer\n```\n\nFor Python 3, run:\n\n```\n$ cd output\n$ python -m http.server\n```\n### 9.环境建好之后的事情：\n\nOK,到这里，pelican的环境部分我们已经配置完了，不过博主好奇刚才pelican的安装些什么了？也就是说pelican的依赖项：\n>\n- feedgenerator, to generate the Atom feeds\n- jinja2, for templating support\n- pygments, for syntax highlighting\n- docutils, for supporting reStructuredText as an input format\n- pytz, for timezone definitions\n- blinker, an object-to-object and broadcast signaling system\n- unidecode, for ASCII transliterations of Unicode text\n- six, for Python 2 and 3 compatibility utilities\n- MarkupSafe, for a markup safe string implementation\n- markdown, for supporting Markdown as an input format\n\n好家伙，这么多啊，都看看 发现都不错！之后用到了在展开慢慢来说。\n\n现在，让我们看看pelican是多么神奇吧，\n\n`$ pelican-quickstart`\n\n运行命令之后，在当前目录下有以下的文件\n\nyourproject/\n\n\n├── content\n\n\n│  └── (pages)\n\n\n├── output\n\n\n├── develop_server.sh\n\n\n├── fabfile.py\n\n\n├── Makefile\n\n\n├── pelicanconf.py      # Main settings file\n\n\n└── publishconf.py      # Settings to use when ready to publish\n\n\n\n我来说说都是些什么吧，\n\ncontent这里是放置你的博文的，例如我的hello_python.md文章；pages是让永和可以自己定制些页面，比如aboutme.md等等页面；\n\noutput这个目录下放置的就是一会利用pelican生成的静态博客内容，当然是html的；\n\npelicanconf.py，是博客的配置文件，后面慢慢讲；\n\nMakefile，make命令的配置文件，如果你懂linux这个就so easy！不过不懂也没事。\n\ndevelop_server.sh 本地服务的脚本;\n\n大致看完这个之后，我们可以先写一篇自己的文章瞅瞅啊，文章模板如下：\n\nTitle: My super title\n\n\nDate: 2010-12-03 10:20\n\n\nCategory: Python\n\n\nTags: pelican, publishing\n\n\nSlug: my-super-post\n\n\nAuthor: Alexis Metaireau\n\n\nSummary: Short version for index and feeds\n\n\n\nThis is the content of my super blog post.\n\n写完保存后，要有以下的几个命令来生成博客内容啦；\n\n### 10.git上创建个人主页\n\n首先在自己的git帐号下新建一个组织，填写组织名；添加一个repository:*usiege/usiege.github.com*(必须用自己用户名，且唯一)；这里需要解决git多用户的问题；将生成的静态页面push到repository中；此时可以访问username.github.com的静态页面；\n\n利用下面的命令来生成你的博客site：\n\n`$ make html`\n\n我比较喜欢下面的这个命令，它是实时生成你的站点，就是说你修改你的博客什么的它会实时的生成！很棒吧。\n\n`$ make regenerate`\n\n\nok，生成之后，我们要看下显示的效果，用下面的命令吧\n\n`$ make serve`\n\n下面这个我比较喜欢，理由同上面的那个regerate，哈哈\n\n`$ make devserver`\n\n至此，我们可以在本地浏览刚才建好的博客了，地址就是http://localhost:8000\n\n停止服务器则是下面的命令：\n\n`$ ./develop_server.sh>`\n\n创建成功以后，便可以把生成的页面push到github。\n\n```\n$ cd output\n$ git init\n$ git add .\n$ git commit -m \"first commit\"\n$ git remote add origin https://github.com/xxx/xxx.github.io.git\n$ git push -u origin master\n```\n关于上传的一些注意点：\n $ git push origin master\n   git push命令会将本地仓库推送到远程服务器。\n   git pull命令则相反。\n   修改完代码后，使用git status可以查看文件的差别，使用git add 添加要commit的文件，也可以用git add -i来智能添加文件。之后git commit提交本次修改，git push上传到github。\n\n","source":"_posts/Python-pelican搭建个人博客.md","raw":"title: Python-pelican搭建个人博客\ndate: 2015-12-11 09:23:00\ncategories: coder\ntags: [python, pelican]\n-----------\n\nSummary:  本文使用python pelican搭建个人静态博客，并上传到个人git仓库，实现访问个人博客，本文作者所用就是基于该博客的个人主页。\n<!-- more -->\n\n>PS：提升到系统root权限：$ sudo -s；\n\n### 1.安装git；\n### 2.安装pip过程：\n\n查看pythion安装目录：\n`$ which python`\n/usr/local/bin/python\n安装pip:\n`$ sudo easy_install pip`\n第一次输入时出现无法安装，则可以选择进行下面的安装；\n安装最新版本的python,pip&setuptools:\n`$ brew install python`\n>PS:brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，只需要一个命令,非常方便brew类似ubuntu系统下的apt-get的功能,http://brew.sh/ 安装方法如下：`$ ruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\"`\n\n详细请见：http://www.cnblogs.com/TankXiao/p/3247113.html\n### 3.安装virtualenv:\n\n`$ pip install virtualenv`\n### 4.创建虚拟环境：\n\n```\n$ virtualenv ~/virtualenv/pelican\n$ cd ~/virtualenvs/pelican\n$ source bin/activate\n```\n### 5.安装pelican：\n\n`$ pip install pelican`\n### 6.安装markdown,typogrify：\n\n`$ pip install markdown`\n`$ pip install typogrify`\n### 7.创建博客站点：\n\n```\n$ mkdir blog\n$ cd blog\n$ pelican-quickstart\n```\npelican-quickstart执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 命令成功执行后，会出现pelican的框架，如下所示\n\nblog/\n\n\n├── content                # 存放输入的markdown或RST源文件\n\n\n│   └── (pages)            # 存放手工创建的静态页面，可选\n\n\n│   └── (posts)            # 存放手工创建的文章，可选\n\n\n├── output                 # 存放最终生成的静态博客\n\n\n├── develop_server.sh      # 测试服务器\n\n\n├── Makefile               # 管理博客的Makefile\n\n\n├── pelicanconf.py         # 配置文件\n\n\n└── publishconf.py         # 发布文件，可删除\n\n\n\n### 8.选择博客主题：\n\n在blog目录下，各页面主题可以在这个网址查看Pelican themes  http://pelicanthemes.com/, 克隆主题开源库 https://github.com/getpelican/pelican-themes\n- 克隆主题到本地\n`$ git clone https://github.com/getpelican/pelican-themes.git`\n\n- 打开pelicanconf.py配置文件，更改或添加THEME为自己喜欢的主题，例如本博客所挑选的elegant，更多的配置含义请关注官方文档。\n- 注意下面的这个主题需要填主题的目录路径\n\n`THEME = 'pelican-themes/gum'`\n\n添加评论系统:\n\n开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。在Disqus上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。然后同理，在pelicanconf.py添加\n\n`DISQUS_SITENAME = Shortname`\n\n生成博客站点:\n\n`$ Site generation`\n\n`$ pelican /path/to/your/content/ [-s path/to/your/settings.py]`\n\n\nPS：上面的这个路径是你自己博客的content路径；\n\n预览生成的站点\n\nFor Python 2, run:\n\n```\n$ cd output\n$ python -m SimpleHTTPServer\n```\n\nFor Python 3, run:\n\n```\n$ cd output\n$ python -m http.server\n```\n### 9.环境建好之后的事情：\n\nOK,到这里，pelican的环境部分我们已经配置完了，不过博主好奇刚才pelican的安装些什么了？也就是说pelican的依赖项：\n>\n- feedgenerator, to generate the Atom feeds\n- jinja2, for templating support\n- pygments, for syntax highlighting\n- docutils, for supporting reStructuredText as an input format\n- pytz, for timezone definitions\n- blinker, an object-to-object and broadcast signaling system\n- unidecode, for ASCII transliterations of Unicode text\n- six, for Python 2 and 3 compatibility utilities\n- MarkupSafe, for a markup safe string implementation\n- markdown, for supporting Markdown as an input format\n\n好家伙，这么多啊，都看看 发现都不错！之后用到了在展开慢慢来说。\n\n现在，让我们看看pelican是多么神奇吧，\n\n`$ pelican-quickstart`\n\n运行命令之后，在当前目录下有以下的文件\n\nyourproject/\n\n\n├── content\n\n\n│  └── (pages)\n\n\n├── output\n\n\n├── develop_server.sh\n\n\n├── fabfile.py\n\n\n├── Makefile\n\n\n├── pelicanconf.py      # Main settings file\n\n\n└── publishconf.py      # Settings to use when ready to publish\n\n\n\n我来说说都是些什么吧，\n\ncontent这里是放置你的博文的，例如我的hello_python.md文章；pages是让永和可以自己定制些页面，比如aboutme.md等等页面；\n\noutput这个目录下放置的就是一会利用pelican生成的静态博客内容，当然是html的；\n\npelicanconf.py，是博客的配置文件，后面慢慢讲；\n\nMakefile，make命令的配置文件，如果你懂linux这个就so easy！不过不懂也没事。\n\ndevelop_server.sh 本地服务的脚本;\n\n大致看完这个之后，我们可以先写一篇自己的文章瞅瞅啊，文章模板如下：\n\nTitle: My super title\n\n\nDate: 2010-12-03 10:20\n\n\nCategory: Python\n\n\nTags: pelican, publishing\n\n\nSlug: my-super-post\n\n\nAuthor: Alexis Metaireau\n\n\nSummary: Short version for index and feeds\n\n\n\nThis is the content of my super blog post.\n\n写完保存后，要有以下的几个命令来生成博客内容啦；\n\n### 10.git上创建个人主页\n\n首先在自己的git帐号下新建一个组织，填写组织名；添加一个repository:*usiege/usiege.github.com*(必须用自己用户名，且唯一)；这里需要解决git多用户的问题；将生成的静态页面push到repository中；此时可以访问username.github.com的静态页面；\n\n利用下面的命令来生成你的博客site：\n\n`$ make html`\n\n我比较喜欢下面的这个命令，它是实时生成你的站点，就是说你修改你的博客什么的它会实时的生成！很棒吧。\n\n`$ make regenerate`\n\n\nok，生成之后，我们要看下显示的效果，用下面的命令吧\n\n`$ make serve`\n\n下面这个我比较喜欢，理由同上面的那个regerate，哈哈\n\n`$ make devserver`\n\n至此，我们可以在本地浏览刚才建好的博客了，地址就是http://localhost:8000\n\n停止服务器则是下面的命令：\n\n`$ ./develop_server.sh>`\n\n创建成功以后，便可以把生成的页面push到github。\n\n```\n$ cd output\n$ git init\n$ git add .\n$ git commit -m \"first commit\"\n$ git remote add origin https://github.com/xxx/xxx.github.io.git\n$ git push -u origin master\n```\n关于上传的一些注意点：\n $ git push origin master\n   git push命令会将本地仓库推送到远程服务器。\n   git pull命令则相反。\n   修改完代码后，使用git status可以查看文件的差别，使用git add 添加要commit的文件，也可以用git add -i来智能添加文件。之后git commit提交本次修改，git push上传到github。\n\n","slug":"Python-pelican搭建个人博客","published":1,"updated":"2018-05-04T08:49:28.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucioa00131v60wx7fhzw4","content":"<p>Summary:  本文使用python pelican搭建个人静态博客，并上传到个人git仓库，实现访问个人博客，本文作者所用就是基于该博客的个人主页。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>PS：提升到系统root权限：$ sudo -s；</p>\n</blockquote>\n<h3 id=\"1-安装git；\"><a href=\"#1-安装git；\" class=\"headerlink\" title=\"1.安装git；\"></a>1.安装git；</h3><h3 id=\"2-安装pip过程：\"><a href=\"#2-安装pip过程：\" class=\"headerlink\" title=\"2.安装pip过程：\"></a>2.安装pip过程：</h3><p>查看pythion安装目录：<br><code>$ which python</code><br>/usr/local/bin/python<br>安装pip:<br><code>$ sudo easy_install pip</code><br>第一次输入时出现无法安装，则可以选择进行下面的安装；<br>安装最新版本的python,pip&amp;setuptools:<br><code>$ brew install python</code></p>\n<blockquote>\n<p>PS:brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，只需要一个命令,非常方便brew类似ubuntu系统下的apt-get的功能,<a href=\"http://brew.sh/\" target=\"_blank\" rel=\"noopener\">http://brew.sh/</a> 安装方法如下：<code>$ ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</code></p>\n</blockquote>\n<p>详细请见：<a href=\"http://www.cnblogs.com/TankXiao/p/3247113.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/TankXiao/p/3247113.html</a></p>\n<h3 id=\"3-安装virtualenv\"><a href=\"#3-安装virtualenv\" class=\"headerlink\" title=\"3.安装virtualenv:\"></a>3.安装virtualenv:</h3><p><code>$ pip install virtualenv</code></p>\n<h3 id=\"4-创建虚拟环境：\"><a href=\"#4-创建虚拟环境：\" class=\"headerlink\" title=\"4.创建虚拟环境：\"></a>4.创建虚拟环境：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ virtualenv ~/virtualenv/pelican</span><br><span class=\"line\">$ cd ~/virtualenvs/pelican</span><br><span class=\"line\">$ source bin/activate</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-安装pelican：\"><a href=\"#5-安装pelican：\" class=\"headerlink\" title=\"5.安装pelican：\"></a>5.安装pelican：</h3><p><code>$ pip install pelican</code></p>\n<h3 id=\"6-安装markdown-typogrify：\"><a href=\"#6-安装markdown-typogrify：\" class=\"headerlink\" title=\"6.安装markdown,typogrify：\"></a>6.安装markdown,typogrify：</h3><p><code>$ pip install markdown</code><br><code>$ pip install typogrify</code></p>\n<h3 id=\"7-创建博客站点：\"><a href=\"#7-创建博客站点：\" class=\"headerlink\" title=\"7.创建博客站点：\"></a>7.创建博客站点：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir blog</span><br><span class=\"line\">$ cd blog</span><br><span class=\"line\">$ pelican-quickstart</span><br></pre></td></tr></table></figure>\n<p>pelican-quickstart执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 命令成功执行后，会出现pelican的框架，如下所示</p>\n<p>blog/</p>\n<p>├── content                # 存放输入的markdown或RST源文件</p>\n<p>│   └── (pages)            # 存放手工创建的静态页面，可选</p>\n<p>│   └── (posts)            # 存放手工创建的文章，可选</p>\n<p>├── output                 # 存放最终生成的静态博客</p>\n<p>├── develop_server.sh      # 测试服务器</p>\n<p>├── Makefile               # 管理博客的Makefile</p>\n<p>├── pelicanconf.py         # 配置文件</p>\n<p>└── publishconf.py         # 发布文件，可删除</p>\n<h3 id=\"8-选择博客主题：\"><a href=\"#8-选择博客主题：\" class=\"headerlink\" title=\"8.选择博客主题：\"></a>8.选择博客主题：</h3><p>在blog目录下，各页面主题可以在这个网址查看Pelican themes  <a href=\"http://pelicanthemes.com/\" target=\"_blank\" rel=\"noopener\">http://pelicanthemes.com/</a>, 克隆主题开源库 <a href=\"https://github.com/getpelican/pelican-themes\" target=\"_blank\" rel=\"noopener\">https://github.com/getpelican/pelican-themes</a></p>\n<ul>\n<li><p>克隆主题到本地<br><code>$ git clone https://github.com/getpelican/pelican-themes.git</code></p>\n</li>\n<li><p>打开pelicanconf.py配置文件，更改或添加THEME为自己喜欢的主题，例如本博客所挑选的elegant，更多的配置含义请关注官方文档。</p>\n</li>\n<li>注意下面的这个主题需要填主题的目录路径</li>\n</ul>\n<p><code>THEME = &#39;pelican-themes/gum&#39;</code></p>\n<p>添加评论系统:</p>\n<p>开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。在Disqus上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。然后同理，在pelicanconf.py添加</p>\n<p><code>DISQUS_SITENAME = Shortname</code></p>\n<p>生成博客站点:</p>\n<p><code>$ Site generation</code></p>\n<p><code>$ pelican /path/to/your/content/ [-s path/to/your/settings.py]</code></p>\n<p>PS：上面的这个路径是你自己博客的content路径；</p>\n<p>预览生成的站点</p>\n<p>For Python 2, run:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd output</span><br><span class=\"line\">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n<p>For Python 3, run:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd output</span><br><span class=\"line\">$ python -m http.server</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-环境建好之后的事情：\"><a href=\"#9-环境建好之后的事情：\" class=\"headerlink\" title=\"9.环境建好之后的事情：\"></a>9.环境建好之后的事情：</h3><p>OK,到这里，pelican的环境部分我们已经配置完了，不过博主好奇刚才pelican的安装些什么了？也就是说pelican的依赖项：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>feedgenerator, to generate the Atom feeds</li>\n<li>jinja2, for templating support</li>\n<li>pygments, for syntax highlighting</li>\n<li>docutils, for supporting reStructuredText as an input format</li>\n<li>pytz, for timezone definitions</li>\n<li>blinker, an object-to-object and broadcast signaling system</li>\n<li>unidecode, for ASCII transliterations of Unicode text</li>\n<li>six, for Python 2 and 3 compatibility utilities</li>\n<li>MarkupSafe, for a markup safe string implementation</li>\n<li>markdown, for supporting Markdown as an input format</li>\n</ul>\n<p>好家伙，这么多啊，都看看 发现都不错！之后用到了在展开慢慢来说。</p>\n<p>现在，让我们看看pelican是多么神奇吧，</p>\n<p><code>$ pelican-quickstart</code></p>\n<p>运行命令之后，在当前目录下有以下的文件</p>\n<p>yourproject/</p>\n<p>├── content</p>\n<p>│  └── (pages)</p>\n<p>├── output</p>\n<p>├── develop_server.sh</p>\n<p>├── fabfile.py</p>\n<p>├── Makefile</p>\n<p>├── pelicanconf.py      # Main settings file</p>\n<p>└── publishconf.py      # Settings to use when ready to publish</p>\n<p>我来说说都是些什么吧，</p>\n<p>content这里是放置你的博文的，例如我的hello_python.md文章；pages是让永和可以自己定制些页面，比如aboutme.md等等页面；</p>\n<p>output这个目录下放置的就是一会利用pelican生成的静态博客内容，当然是html的；</p>\n<p>pelicanconf.py，是博客的配置文件，后面慢慢讲；</p>\n<p>Makefile，make命令的配置文件，如果你懂linux这个就so easy！不过不懂也没事。</p>\n<p>develop_server.sh 本地服务的脚本;</p>\n<p>大致看完这个之后，我们可以先写一篇自己的文章瞅瞅啊，文章模板如下：</p>\n<p>Title: My super title</p>\n<p>Date: 2010-12-03 10:20</p>\n<p>Category: Python</p>\n<p>Tags: pelican, publishing</p>\n<p>Slug: my-super-post</p>\n<p>Author: Alexis Metaireau</p>\n<p>Summary: Short version for index and feeds</p>\n<p>This is the content of my super blog post.</p>\n<p>写完保存后，要有以下的几个命令来生成博客内容啦；</p>\n<h3 id=\"10-git上创建个人主页\"><a href=\"#10-git上创建个人主页\" class=\"headerlink\" title=\"10.git上创建个人主页\"></a>10.git上创建个人主页</h3><p>首先在自己的git帐号下新建一个组织，填写组织名；添加一个repository:<em>usiege/usiege.github.com</em>(必须用自己用户名，且唯一)；这里需要解决git多用户的问题；将生成的静态页面push到repository中；此时可以访问username.github.com的静态页面；</p>\n<p>利用下面的命令来生成你的博客site：</p>\n<p><code>$ make html</code></p>\n<p>我比较喜欢下面的这个命令，它是实时生成你的站点，就是说你修改你的博客什么的它会实时的生成！很棒吧。</p>\n<p><code>$ make regenerate</code></p>\n<p>ok，生成之后，我们要看下显示的效果，用下面的命令吧</p>\n<p><code>$ make serve</code></p>\n<p>下面这个我比较喜欢，理由同上面的那个regerate，哈哈</p>\n<p><code>$ make devserver</code></p>\n<p>至此，我们可以在本地浏览刚才建好的博客了，地址就是<a href=\"http://localhost:8000\" target=\"_blank\" rel=\"noopener\">http://localhost:8000</a></p>\n<p>停止服务器则是下面的命令：</p>\n<p><code>$ ./develop_server.sh&gt;</code></p>\n<p>创建成功以后，便可以把生成的页面push到github。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd output</span><br><span class=\"line\">$ git init</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m &quot;first commit&quot;</span><br><span class=\"line\">$ git remote add origin https://github.com/xxx/xxx.github.io.git</span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>关于上传的一些注意点：<br> $ git push origin master<br>   git push命令会将本地仓库推送到远程服务器。<br>   git pull命令则相反。<br>   修改完代码后，使用git status可以查看文件的差别，使用git add 添加要commit的文件，也可以用git add -i来智能添加文件。之后git commit提交本次修改，git push上传到github。</p>\n","site":{"data":{}},"excerpt":"<p>Summary:  本文使用python pelican搭建个人静态博客，并上传到个人git仓库，实现访问个人博客，本文作者所用就是基于该博客的个人主页。<br>","more":"</p>\n<blockquote>\n<p>PS：提升到系统root权限：$ sudo -s；</p>\n</blockquote>\n<h3 id=\"1-安装git；\"><a href=\"#1-安装git；\" class=\"headerlink\" title=\"1.安装git；\"></a>1.安装git；</h3><h3 id=\"2-安装pip过程：\"><a href=\"#2-安装pip过程：\" class=\"headerlink\" title=\"2.安装pip过程：\"></a>2.安装pip过程：</h3><p>查看pythion安装目录：<br><code>$ which python</code><br>/usr/local/bin/python<br>安装pip:<br><code>$ sudo easy_install pip</code><br>第一次输入时出现无法安装，则可以选择进行下面的安装；<br>安装最新版本的python,pip&amp;setuptools:<br><code>$ brew install python</code></p>\n<blockquote>\n<p>PS:brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，只需要一个命令,非常方便brew类似ubuntu系统下的apt-get的功能,<a href=\"http://brew.sh/\" target=\"_blank\" rel=\"noopener\">http://brew.sh/</a> 安装方法如下：<code>$ ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</code></p>\n</blockquote>\n<p>详细请见：<a href=\"http://www.cnblogs.com/TankXiao/p/3247113.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/TankXiao/p/3247113.html</a></p>\n<h3 id=\"3-安装virtualenv\"><a href=\"#3-安装virtualenv\" class=\"headerlink\" title=\"3.安装virtualenv:\"></a>3.安装virtualenv:</h3><p><code>$ pip install virtualenv</code></p>\n<h3 id=\"4-创建虚拟环境：\"><a href=\"#4-创建虚拟环境：\" class=\"headerlink\" title=\"4.创建虚拟环境：\"></a>4.创建虚拟环境：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ virtualenv ~/virtualenv/pelican</span><br><span class=\"line\">$ cd ~/virtualenvs/pelican</span><br><span class=\"line\">$ source bin/activate</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-安装pelican：\"><a href=\"#5-安装pelican：\" class=\"headerlink\" title=\"5.安装pelican：\"></a>5.安装pelican：</h3><p><code>$ pip install pelican</code></p>\n<h3 id=\"6-安装markdown-typogrify：\"><a href=\"#6-安装markdown-typogrify：\" class=\"headerlink\" title=\"6.安装markdown,typogrify：\"></a>6.安装markdown,typogrify：</h3><p><code>$ pip install markdown</code><br><code>$ pip install typogrify</code></p>\n<h3 id=\"7-创建博客站点：\"><a href=\"#7-创建博客站点：\" class=\"headerlink\" title=\"7.创建博客站点：\"></a>7.创建博客站点：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir blog</span><br><span class=\"line\">$ cd blog</span><br><span class=\"line\">$ pelican-quickstart</span><br></pre></td></tr></table></figure>\n<p>pelican-quickstart执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 命令成功执行后，会出现pelican的框架，如下所示</p>\n<p>blog/</p>\n<p>├── content                # 存放输入的markdown或RST源文件</p>\n<p>│   └── (pages)            # 存放手工创建的静态页面，可选</p>\n<p>│   └── (posts)            # 存放手工创建的文章，可选</p>\n<p>├── output                 # 存放最终生成的静态博客</p>\n<p>├── develop_server.sh      # 测试服务器</p>\n<p>├── Makefile               # 管理博客的Makefile</p>\n<p>├── pelicanconf.py         # 配置文件</p>\n<p>└── publishconf.py         # 发布文件，可删除</p>\n<h3 id=\"8-选择博客主题：\"><a href=\"#8-选择博客主题：\" class=\"headerlink\" title=\"8.选择博客主题：\"></a>8.选择博客主题：</h3><p>在blog目录下，各页面主题可以在这个网址查看Pelican themes  <a href=\"http://pelicanthemes.com/\" target=\"_blank\" rel=\"noopener\">http://pelicanthemes.com/</a>, 克隆主题开源库 <a href=\"https://github.com/getpelican/pelican-themes\" target=\"_blank\" rel=\"noopener\">https://github.com/getpelican/pelican-themes</a></p>\n<ul>\n<li><p>克隆主题到本地<br><code>$ git clone https://github.com/getpelican/pelican-themes.git</code></p>\n</li>\n<li><p>打开pelicanconf.py配置文件，更改或添加THEME为自己喜欢的主题，例如本博客所挑选的elegant，更多的配置含义请关注官方文档。</p>\n</li>\n<li>注意下面的这个主题需要填主题的目录路径</li>\n</ul>\n<p><code>THEME = &#39;pelican-themes/gum&#39;</code></p>\n<p>添加评论系统:</p>\n<p>开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。在Disqus上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。然后同理，在pelicanconf.py添加</p>\n<p><code>DISQUS_SITENAME = Shortname</code></p>\n<p>生成博客站点:</p>\n<p><code>$ Site generation</code></p>\n<p><code>$ pelican /path/to/your/content/ [-s path/to/your/settings.py]</code></p>\n<p>PS：上面的这个路径是你自己博客的content路径；</p>\n<p>预览生成的站点</p>\n<p>For Python 2, run:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd output</span><br><span class=\"line\">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n<p>For Python 3, run:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd output</span><br><span class=\"line\">$ python -m http.server</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-环境建好之后的事情：\"><a href=\"#9-环境建好之后的事情：\" class=\"headerlink\" title=\"9.环境建好之后的事情：\"></a>9.环境建好之后的事情：</h3><p>OK,到这里，pelican的环境部分我们已经配置完了，不过博主好奇刚才pelican的安装些什么了？也就是说pelican的依赖项：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>feedgenerator, to generate the Atom feeds</li>\n<li>jinja2, for templating support</li>\n<li>pygments, for syntax highlighting</li>\n<li>docutils, for supporting reStructuredText as an input format</li>\n<li>pytz, for timezone definitions</li>\n<li>blinker, an object-to-object and broadcast signaling system</li>\n<li>unidecode, for ASCII transliterations of Unicode text</li>\n<li>six, for Python 2 and 3 compatibility utilities</li>\n<li>MarkupSafe, for a markup safe string implementation</li>\n<li>markdown, for supporting Markdown as an input format</li>\n</ul>\n<p>好家伙，这么多啊，都看看 发现都不错！之后用到了在展开慢慢来说。</p>\n<p>现在，让我们看看pelican是多么神奇吧，</p>\n<p><code>$ pelican-quickstart</code></p>\n<p>运行命令之后，在当前目录下有以下的文件</p>\n<p>yourproject/</p>\n<p>├── content</p>\n<p>│  └── (pages)</p>\n<p>├── output</p>\n<p>├── develop_server.sh</p>\n<p>├── fabfile.py</p>\n<p>├── Makefile</p>\n<p>├── pelicanconf.py      # Main settings file</p>\n<p>└── publishconf.py      # Settings to use when ready to publish</p>\n<p>我来说说都是些什么吧，</p>\n<p>content这里是放置你的博文的，例如我的hello_python.md文章；pages是让永和可以自己定制些页面，比如aboutme.md等等页面；</p>\n<p>output这个目录下放置的就是一会利用pelican生成的静态博客内容，当然是html的；</p>\n<p>pelicanconf.py，是博客的配置文件，后面慢慢讲；</p>\n<p>Makefile，make命令的配置文件，如果你懂linux这个就so easy！不过不懂也没事。</p>\n<p>develop_server.sh 本地服务的脚本;</p>\n<p>大致看完这个之后，我们可以先写一篇自己的文章瞅瞅啊，文章模板如下：</p>\n<p>Title: My super title</p>\n<p>Date: 2010-12-03 10:20</p>\n<p>Category: Python</p>\n<p>Tags: pelican, publishing</p>\n<p>Slug: my-super-post</p>\n<p>Author: Alexis Metaireau</p>\n<p>Summary: Short version for index and feeds</p>\n<p>This is the content of my super blog post.</p>\n<p>写完保存后，要有以下的几个命令来生成博客内容啦；</p>\n<h3 id=\"10-git上创建个人主页\"><a href=\"#10-git上创建个人主页\" class=\"headerlink\" title=\"10.git上创建个人主页\"></a>10.git上创建个人主页</h3><p>首先在自己的git帐号下新建一个组织，填写组织名；添加一个repository:<em>usiege/usiege.github.com</em>(必须用自己用户名，且唯一)；这里需要解决git多用户的问题；将生成的静态页面push到repository中；此时可以访问username.github.com的静态页面；</p>\n<p>利用下面的命令来生成你的博客site：</p>\n<p><code>$ make html</code></p>\n<p>我比较喜欢下面的这个命令，它是实时生成你的站点，就是说你修改你的博客什么的它会实时的生成！很棒吧。</p>\n<p><code>$ make regenerate</code></p>\n<p>ok，生成之后，我们要看下显示的效果，用下面的命令吧</p>\n<p><code>$ make serve</code></p>\n<p>下面这个我比较喜欢，理由同上面的那个regerate，哈哈</p>\n<p><code>$ make devserver</code></p>\n<p>至此，我们可以在本地浏览刚才建好的博客了，地址就是<a href=\"http://localhost:8000\" target=\"_blank\" rel=\"noopener\">http://localhost:8000</a></p>\n<p>停止服务器则是下面的命令：</p>\n<p><code>$ ./develop_server.sh&gt;</code></p>\n<p>创建成功以后，便可以把生成的页面push到github。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd output</span><br><span class=\"line\">$ git init</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m &quot;first commit&quot;</span><br><span class=\"line\">$ git remote add origin https://github.com/xxx/xxx.github.io.git</span><br><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>关于上传的一些注意点：<br> $ git push origin master<br>   git push命令会将本地仓库推送到远程服务器。<br>   git pull命令则相反。<br>   修改完代码后，使用git status可以查看文件的差别，使用git add 添加要commit的文件，也可以用git add -i来智能添加文件。之后git commit提交本次修改，git push上传到github。</p>"},{"title":"git checkout 与 reset","date":"2017-08-18T09:34:00.000Z","_content":"\n公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。\n<!-- more -->\n\n首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：\n\n![image_1bu7k3nt22m3cmearq636qua9.png-14.8kB][1]\n\n本人在ios11上做了提交，发现问题进行分类：\n1. 第一个是第三方库存在x86_64,i386的链接库，有以下问题：\n\n```\niTunes Store Operation Failed\nERROR ITMS-90087: \"Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures '[x86_64, i386]'.\"\n```\n\nPS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；\n```\niTunes Store Operation Failed\nERROR ITMS-90209: \"Invalid Segment Alignment. The app binary at 'LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.\"\n无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。\n```\n\n```\niTunes Store Operation Failed\nERROR ITMS-90125: \"The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple's linker.\"\n“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”\n```\n```\niTunes Store Operation Failed\nWARNING ITMS-90080: \"The executable 'Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&A QA1788 - Building a Position Independent Executable in the iOS Developer Library.\"\n“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”\n```\n\n```\nERROR ITMS-90362: \"Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0\"\n```\n后面这个**90362**貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；\n\n解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：\n![image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB][2]\n```\nAPP_PATH=\"${TARGET_BUILD_DIR}/${WRAPPER_NAME}\"\n\n# This script loops through the frameworks embedded in the application and\n# removes unused architectures.\nfind \"$APP_PATH\" -name '*.framework' -type d | while read -r FRAMEWORK\ndo\nFRAMEWORK_EXECUTABLE_NAME=$(defaults read \"$FRAMEWORK/Info.plist\" CFBundleExecutable)\nFRAMEWORK_EXECUTABLE_PATH=\"$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME\"\necho \"Executable is $FRAMEWORK_EXECUTABLE_PATH\"\n\nEXTRACTED_ARCHS=()\n\nfor ARCH in $ARCHS\ndo\necho \"Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME\"\nlipo -extract \"$ARCH\" \"$FRAMEWORK_EXECUTABLE_PATH\" -o \"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\"\nEXTRACTED_ARCHS+=(\"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\")\ndone\n\necho \"Merging extracted architectures: ${ARCHS}\"\nlipo -o \"$FRAMEWORK_EXECUTABLE_PATH-merged\" -create \"${EXTRACTED_ARCHS[@]}\"\nrm \"${EXTRACTED_ARCHS[@]}\"\n\necho \"Replacing original executable with thinned version\"\nrm \"$FRAMEWORK_EXECUTABLE_PATH\"\nmv \"$FRAMEWORK_EXECUTABLE_PATH-merged\" \"$FRAMEWORK_EXECUTABLE_PATH\"\ndone\n```\n以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；\n\n2. 项目有icon不合规定的错误\n```\niTunes Store Operation Failed\nERROR ITMS-90717: \"Invalid App Store Icon. The App Store Icon in the asset catalog in 'LeWaiJiao.app' can't be transparent nor contain an alpha channel.\"\n无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”\n```\n该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；\n解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：\n\n![image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB][3]\n\n用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；\n![image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB][4]\n\n3. 提交上传结束后又出现了一个问题\n\n```\nApp Installation failed, No code signature found.\n```\n真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入\n\n```\nsudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk \n```\n\n修改文件权限，然后修改字段属性，打开：\n\n**/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist**\n\n，修改 **CODE_SIGNING_REQUIRED** 字段为 **YES** ，保存；\n\n\n\n  [1]: http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\n  [2]: http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\n  [3]: http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\n  [4]: http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png","source":"_posts/git checkout 与 reset.md","raw":"title: git checkout 与 reset\ndate: 2017-08-18 17:34:00\ncategories: coder\ntags: [git]\n-----------\n\n公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。\n<!-- more -->\n\n首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：\n\n![image_1bu7k3nt22m3cmearq636qua9.png-14.8kB][1]\n\n本人在ios11上做了提交，发现问题进行分类：\n1. 第一个是第三方库存在x86_64,i386的链接库，有以下问题：\n\n```\niTunes Store Operation Failed\nERROR ITMS-90087: \"Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures '[x86_64, i386]'.\"\n```\n\nPS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；\n```\niTunes Store Operation Failed\nERROR ITMS-90209: \"Invalid Segment Alignment. The app binary at 'LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.\"\n无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。\n```\n\n```\niTunes Store Operation Failed\nERROR ITMS-90125: \"The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple's linker.\"\n“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”\n```\n```\niTunes Store Operation Failed\nWARNING ITMS-90080: \"The executable 'Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&A QA1788 - Building a Position Independent Executable in the iOS Developer Library.\"\n“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”\n```\n\n```\nERROR ITMS-90362: \"Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0\"\n```\n后面这个**90362**貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；\n\n解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：\n![image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB][2]\n```\nAPP_PATH=\"${TARGET_BUILD_DIR}/${WRAPPER_NAME}\"\n\n# This script loops through the frameworks embedded in the application and\n# removes unused architectures.\nfind \"$APP_PATH\" -name '*.framework' -type d | while read -r FRAMEWORK\ndo\nFRAMEWORK_EXECUTABLE_NAME=$(defaults read \"$FRAMEWORK/Info.plist\" CFBundleExecutable)\nFRAMEWORK_EXECUTABLE_PATH=\"$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME\"\necho \"Executable is $FRAMEWORK_EXECUTABLE_PATH\"\n\nEXTRACTED_ARCHS=()\n\nfor ARCH in $ARCHS\ndo\necho \"Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME\"\nlipo -extract \"$ARCH\" \"$FRAMEWORK_EXECUTABLE_PATH\" -o \"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\"\nEXTRACTED_ARCHS+=(\"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\")\ndone\n\necho \"Merging extracted architectures: ${ARCHS}\"\nlipo -o \"$FRAMEWORK_EXECUTABLE_PATH-merged\" -create \"${EXTRACTED_ARCHS[@]}\"\nrm \"${EXTRACTED_ARCHS[@]}\"\n\necho \"Replacing original executable with thinned version\"\nrm \"$FRAMEWORK_EXECUTABLE_PATH\"\nmv \"$FRAMEWORK_EXECUTABLE_PATH-merged\" \"$FRAMEWORK_EXECUTABLE_PATH\"\ndone\n```\n以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；\n\n2. 项目有icon不合规定的错误\n```\niTunes Store Operation Failed\nERROR ITMS-90717: \"Invalid App Store Icon. The App Store Icon in the asset catalog in 'LeWaiJiao.app' can't be transparent nor contain an alpha channel.\"\n无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”\n```\n该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；\n解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：\n\n![image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB][3]\n\n用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；\n![image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB][4]\n\n3. 提交上传结束后又出现了一个问题\n\n```\nApp Installation failed, No code signature found.\n```\n真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入\n\n```\nsudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk \n```\n\n修改文件权限，然后修改字段属性，打开：\n\n**/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist**\n\n，修改 **CODE_SIGNING_REQUIRED** 字段为 **YES** ，保存；\n\n\n\n  [1]: http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\n  [2]: http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\n  [3]: http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\n  [4]: http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png","slug":"git checkout 与 reset","published":1,"updated":"2018-05-04T08:49:07.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciob00161v60svuz4fgq","content":"<p>公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。<br><a id=\"more\"></a></p>\n<p>首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\" alt=\"image_1bu7k3nt22m3cmearq636qua9.png-14.8kB\"></p>\n<p>本人在ios11上做了提交，发现问题进行分类：</p>\n<ol>\n<li>第一个是第三方库存在x86_64,i386的链接库，有以下问题：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;</span><br></pre></td></tr></table></figure>\n<p>PS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90209: &quot;Invalid Segment Alignment. The app binary at &apos;LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers&apos; does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.&quot;</span><br><span class=\"line\">无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90125: &quot;The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple&apos;s linker.&quot;</span><br><span class=\"line\">“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">WARNING ITMS-90080: &quot;The executable &apos;Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework&apos; is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&amp;A QA1788 - Building a Position Independent Executable in the iOS Developer Library.&quot;</span><br><span class=\"line\">“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR ITMS-90362: &quot;Invalid Info.plist value. The value for the key &apos;MinimumOSVersion&apos; in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0&quot;</span><br></pre></td></tr></table></figure>\n<p>后面这个<strong>90362</strong>貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；</p>\n<p>解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：<br><img src=\"http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\" alt=\"image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># This script loops through the frameworks embedded in the application and</span><br><span class=\"line\"># removes unused architectures.</span><br><span class=\"line\">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class=\"line\">do</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">EXTRACTED_ARCHS=()</span><br><span class=\"line\"></span><br><span class=\"line\">for ARCH in $ARCHS</span><br><span class=\"line\">do</span><br><span class=\"line\">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class=\"line\">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class=\"line\">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class=\"line\">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；</p>\n<ol start=\"2\">\n<li>项目有icon不合规定的错误<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90717: &quot;Invalid App Store Icon. The App Store Icon in the asset catalog in &apos;LeWaiJiao.app&apos; can&apos;t be transparent nor contain an alpha channel.&quot;</span><br><span class=\"line\">无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；<br>解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\" alt=\"image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB\"></p>\n<p>用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；<br><img src=\"http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png\" alt=\"image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB\"></p>\n<ol start=\"3\">\n<li>提交上传结束后又出现了一个问题</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App Installation failed, No code signature found.</span><br></pre></td></tr></table></figure>\n<p>真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk</span><br></pre></td></tr></table></figure>\n<p>修改文件权限，然后修改字段属性，打开：</p>\n<p><strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist</strong></p>\n<p>，修改 <strong>CODE_SIGNING_REQUIRED</strong> 字段为 <strong>YES</strong> ，保存；</p>\n","site":{"data":{}},"excerpt":"<p>公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。<br>","more":"</p>\n<p>首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\" alt=\"image_1bu7k3nt22m3cmearq636qua9.png-14.8kB\"></p>\n<p>本人在ios11上做了提交，发现问题进行分类：</p>\n<ol>\n<li>第一个是第三方库存在x86_64,i386的链接库，有以下问题：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;</span><br></pre></td></tr></table></figure>\n<p>PS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90209: &quot;Invalid Segment Alignment. The app binary at &apos;LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers&apos; does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.&quot;</span><br><span class=\"line\">无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90125: &quot;The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple&apos;s linker.&quot;</span><br><span class=\"line\">“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">WARNING ITMS-90080: &quot;The executable &apos;Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework&apos; is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&amp;A QA1788 - Building a Position Independent Executable in the iOS Developer Library.&quot;</span><br><span class=\"line\">“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR ITMS-90362: &quot;Invalid Info.plist value. The value for the key &apos;MinimumOSVersion&apos; in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0&quot;</span><br></pre></td></tr></table></figure>\n<p>后面这个<strong>90362</strong>貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；</p>\n<p>解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：<br><img src=\"http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\" alt=\"image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># This script loops through the frameworks embedded in the application and</span><br><span class=\"line\"># removes unused architectures.</span><br><span class=\"line\">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class=\"line\">do</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">EXTRACTED_ARCHS=()</span><br><span class=\"line\"></span><br><span class=\"line\">for ARCH in $ARCHS</span><br><span class=\"line\">do</span><br><span class=\"line\">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class=\"line\">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class=\"line\">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class=\"line\">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；</p>\n<ol start=\"2\">\n<li>项目有icon不合规定的错误<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90717: &quot;Invalid App Store Icon. The App Store Icon in the asset catalog in &apos;LeWaiJiao.app&apos; can&apos;t be transparent nor contain an alpha channel.&quot;</span><br><span class=\"line\">无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；<br>解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\" alt=\"image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB\"></p>\n<p>用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；<br><img src=\"http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png\" alt=\"image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB\"></p>\n<ol start=\"3\">\n<li>提交上传结束后又出现了一个问题</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App Installation failed, No code signature found.</span><br></pre></td></tr></table></figure>\n<p>真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk</span><br></pre></td></tr></table></figure>\n<p>修改文件权限，然后修改字段属性，打开：</p>\n<p><strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist</strong></p>\n<p>，修改 <strong>CODE_SIGNING_REQUIRED</strong> 字段为 <strong>YES</strong> ，保存；</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-05-03T07:14:45.717Z","updated":"2018-05-04T08:49:09.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciod00191v60rz8tljau","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.<br>","more":"</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"iOS 作为Central蓝牙连接外围（上）","date":"2016-05-21T10:06:00.000Z","_content":"\nSummary: 今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。\n<!-- more -->\n\n\n今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。难点主要集中在与蓝牙卡连接断开部分，因为蓝牙卡是低能耗的，每开启蓝牙卡片蓝牙后它会在8秒后自动断开连接，所以在处理蓝牙连接的的部分逻辑较为复杂。接下来我们把重点放在与蓝牙建立连接的部分，Google之，先来搞清楚与iOS有关的蓝牙库。    \n\n先说一下蓝牙版本问题，如果你的设备支持的是蓝牙4.0之前的版本，那么会涉及到一个MFI的概念，MFI（Make For ipod/ipad/iphone）是苹果的一套认证，只有少数的硬件厂商才有苹果的MFI认证，做之前需要搞定这个认证。使用蓝牙4.0的话，由于4.0苹果开放了BLE（Bluetooth Low Energy）通道，就不会有认证的问题了，而且向下兼容。    \n我们用到的蓝牙库为CoreBluetooth，而蓝牙库中首先要介绍下两个概念Central和Peripheral；\n\n# Central 和 Peripheral 在蓝牙交互中的角色\n\n><font color=#C0C0C0  size=4>所有涉及蓝牙低功耗的交互中有两个主要的角色：中心Central和外围设备Perpheral。根据一些传统的客户端-服务端结构，Peripheral通常具有其他设备所需要的数据，而Central通常通过使用Perpheral的信息来实现一些特定的功能。</font>\n\n这里我自己理解，如果你的设备连接的是本文这种蓝牙卡或者穿戴设备等，那么你的程序就是作为Central；如果你的设备是与另外一台iPhone设备，那么它既可以作为Central也可以作为Perpheral；\n\n想了解更详细请参照：[iOS蓝牙编程指南 -- 核心蓝牙概述](http://www.jianshu.com/p/760f042a1d81)\n\n# UUID\n\n每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。特征是与外界交互的最小单位。比如说，一台蓝牙4.0设备，用特征A来描述自己的出厂信息，用特征B来与收发数据等。\n\n服务和特征都是用UUID来唯一标识的，UUID的概念如果不清楚请自行google,国际蓝牙组织为一些很典型的设备(比如测量心跳和血压的设备)规定了标准的service UUID(特征的UUID比较多，这里就不列举了);        \n\n><font color=#C0C0C0  size=2>UUID含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。\nUUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。\n\n>UUID由以下几部分的组合：\n\n>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n\n>（2）时钟序列。\n\n>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\n>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。</font>\n\n# BLE中心模式流程\n\n1.建立中心角色    \n\n2.扫描外设(Discover Peripheral)    \n\n3.连接外设(Connect Peripheral)    \n\n4.扫描外设中的服务和特征(Discover Services And Characteristics)    \n\n5.利用特征与外设做数据交互(Explore And Interact)\n\n6.订阅Characteristic的通知\n\n7.断开连接(Disconnect)\n\n# 代码说明\n## 初始化 CBCentralManager\n\n```objective-c\ndispatch_queue_t centralQ = dispatch_queue_create(BLUETOOCH_QUEUE_IDENTIFER, DISPATCH_QUEUE_CONCURRENT);\n _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQ];\n```\n上面的代码中，将self设置为代理，用于接收各种 central 事件。将queue设置为nil，则表示直接在主线程中运行，这里是我自己定义的任务队列。\n\n创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。\n\n初始化 central manager 之后，设置的代理会调用centralManagerDidUpdateState:方法，所以需要去遵循<CBCentralManagerDelegate>协议。这个 did update state 的方法，能获得当前设备是否能作为 central。关于这个协议的实现和其他方法，接下来会讲到，也可以先看看[官方API](https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManagerDelegate_Protocol/index.html#//apple_ref/doc/uid/TP40011285)\n\n## 搜索当前可用的 peripheral\n\n可以使用*CBCentralManager的scanForPeripheralsWithServices:options:*方法来扫描周围正在发出广播的 Peripheral 设备。peripheral 每秒都在发送大量的数据包，*scanForPeripheralsWithServices:options:*方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral  都会调用 *centralManager:didDiscoverPeripheral:advertisementData:RSSI:* 方法。另外，当已发现的 peripheral  发送的数据包有变化时，这个代理方法同样会调用。\n\n```\nNSArray *services = @[[CBUUID UUIDWithString:BUSINESS_SERVICE_UUID_STRING]\nNSDictionary *scanOption = @{CBCentralManagerScanOptionAllowDuplicatesKey:@(NO)};\n[_centralManager scanForPeripheralsWithServices:services options:scanOption];\n```\n这里的services是中心要扫描的蓝牙设备类型，表示只搜索当前数组包含的设备（每个 peripheral 的 service 都有唯一标识——UUID）；而scanOption中的`CBCentralManagerScanOptionAllowDuplicatesKey`设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option 会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。\n\n在调用`scanForPeripheralsWithServices:options:`方法之后，找到可用设备，系统会回调（每找到一个都会回调）`centralManager:didDiscoverPeripheral:advertisementData:RSSI:`。该方法会已CBPeripheral返回找到的 peripheral，所以你可以使用数组将找到的 peripheral 存起来。\n\n```\n//扫描到蓝牙后的回调\n-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{\n    //RSSI(Received Signal Strength Indication接收的信号强度指示)   \n    printf(\"didDiscoverPeripheral\\n\");\n    NSLog(@\"advertisement data is :%@\",advertisementData);\n    NSString* identifer = [peripheral.identifier UUIDString];\n}\n```\n\n## 连接 peripheral\n\n```\n//连接外围设备\n[_centralManager connectPeripheral:peripheral options:nil];\n```\n当连接成功后，会回调方法*centralManager:didConnectPeripheral:*。在这个方法中，你可以去记录当前的连接状态等数据。\n\n```\n-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{\n    printf(\"已连接上设备：\");\n    printf(\"name = %s\\n\",[peripheral.name UTF8String]);\n    \n    //连接到设备后要设置设备的代理，这样才可以接收到外围的服务与特性\n    peripheral.delegate = self;\n    \n    NSArray<CBUUID*>* uuids =@[\n\t[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],\n\t[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];\n\t//发现服务\n\t[peripheral discoverServices:uuids];\n}\n```\n如果连接断开则会回调：\n\n```\n//断开回调处理\n- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error{\n    printf(\"设备 %s 已断开！\\n\",[peripheral.name UTF8String]);\n}\n```\n失败的情况下则是： \n   \n```\n//连接失败回调\n-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error{\n    NSLog(@\"didFailToConnectPeripheral error:%@\",error);\n}\n```\n\n## 搜索 peripheral 的 service\n\n当与 peripheral 成功建立连接以后，就可以通信了。第一步是先找到当前 peripheral 提供的 service，因为 service 广播的数据有大小限制（貌似是 31 bytes），所以你实际找到的 service 的数量可能要比它广播时候说的数量要多。调用CBPeripheral的 `discoverServices:`方法可以找到当前 peripheral 的所有 service。\n\n```\n//在搜索过程中，并不是所有的 service和characteristic 都是我们需要的,如果全部搜索，依然会造成不必要的资源浪费。\n//这里的uuids是我工程中用到的UUID\nNSArray<CBUUID*>* uuids =@[\n[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],\n[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];\n//发现服务\n[peripheral discoverServices:uuids];\n```\n当找到特定的 Service 以后，会回调<CBPeripheralDelegate>的`peripheral:didDiscoverServices:`方法。Core Bluetooth 提供了CBService类来表示 service，找到以后，它们以数组的形式存入了当前 peripheral 的services属性中，你可以在当前回调中遍历这个属性。\n\n```\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ \n    if(error){\n        NSLog(@\"发现服务错误：%@\",error);\n        return;\n    }\n    printf(\"发现周边设备的服务:\\n\");\n    printf(\"==== didDiscoverServices ==== \\n\");\n \t\n     //发现服务中的特性 \n    for (CBService *service in peripheral.services) {\n        printf(\"-- service : %s\\n\",[[service.UUID UUIDString] UTF8String]);\n        [peripheral discoverCharacteristics:nil forService:service];\n    }\n}\n```\n## 搜索 service 的 characteristic\n\n找到需要的 service 之后，下一步是找它所提供的 characteristic。如果搜索全部 characteristic，那调用CBPeripheral的`discoverCharacteristics:forService:`方法即可。如果是搜索当前service的characteristic，那还应该传入相应的CBService对象：\n\n```\n[peripheral discoverCharacteristics:nil forService:service];\n```\n找到所有 characteristic 之后，回调`peripheral:didDiscoverCharacteristicsForService:error:`方法，此时 Core Bluetooth 提供了CBCharacteristic类来表示characteristic。可以通过以下代码来遍历找到的 characteristic ：\n\n```\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{\n    printf(\"发现服务 :(%s)\\n\",[[service.UUID UUIDString] UTF8String]);\n    \n    if (error) {\n        NSLog(@\"There is a error in peripheral:didDiscoverCharacteristicsForService:error: which called:%@\",error);\n        return;\n    } \n    printf(\"开始读取服务数据...\\n\");\n    for (CBCharacteristic *characteristic in service.characteristics) {\n        NSLog(@\"properties is %lu\",characteristic.properties);\n        if (characteristic.properties & CBCharacteristicPropertyNotify) {\n//            [peripheral readValueForCharacteristic:characteristic];\n            [peripheral setNotifyValue:YES forCharacteristic:characteristic];\n        }\n    }\n}\n```\n## 读取 characteristic 数据\n\n这里读取涉及到两个方法：\n\n```\n[peripheral readValueForCharacteristic:characteristic];\n[peripheral setNotifyValue:YES forCharacteristic:characteristic];\n\n```\nread这种方法是需要主动去接收的；notify方法订阅，当有数据发送时，可以直接在回调中接收,如果 characteristic 的数据经常变化，那么采用订阅的方式更好；\n\n\n```\n//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n    if (error) {\n        NSLog(@\"There is a error in peripheral:didUpdateValueForCharacteristic:error: which called:%@\",error);\n        return;\n    }\n    NSLog(@\"characteristic data is:%@ \",characteristic.value);\n    NSLog(@\"characteristic data length is %ld\",characteristic.value.length);\n}\n\n```\n所以nofify可能会被调用多次，而且它获取的是实时数据，如果你接收蓝牙信息不是一次次接收的话，那么会用到它：\n\n```\n//中心读取外设实时数据\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n    printf(\"didUpdateNotificationStateForCharacteristic (%s)\\n\",[[characteristic.UUID UUIDString] UTF8String]);\n    if(error){\n        printf(\"error is : %s\\n\",[error.description UTF8String]);\n        return;\n    }\n    printf(\" update notification success !!\");\n    NSLog(@\"接收到的数据：%@\",characteristic.value);\n    }   \n}\n```\n[本文参考](http://www.saitjr.com/ios/core-bluetooth-read-write-as-central-role.html)，之后会继续讲解写数据和重连等问题；\n\n\n\n\n\n\n","source":"_posts/iOS 作为Central蓝牙连接外围（上）.md","raw":"title: iOS 作为Central蓝牙连接外围（上）\ndate: 2016-05-21 18:06:00\ncategories: coder\ntags: [iOS, bluetooth]\n-----------\n\nSummary: 今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。\n<!-- more -->\n\n\n今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。难点主要集中在与蓝牙卡连接断开部分，因为蓝牙卡是低能耗的，每开启蓝牙卡片蓝牙后它会在8秒后自动断开连接，所以在处理蓝牙连接的的部分逻辑较为复杂。接下来我们把重点放在与蓝牙建立连接的部分，Google之，先来搞清楚与iOS有关的蓝牙库。    \n\n先说一下蓝牙版本问题，如果你的设备支持的是蓝牙4.0之前的版本，那么会涉及到一个MFI的概念，MFI（Make For ipod/ipad/iphone）是苹果的一套认证，只有少数的硬件厂商才有苹果的MFI认证，做之前需要搞定这个认证。使用蓝牙4.0的话，由于4.0苹果开放了BLE（Bluetooth Low Energy）通道，就不会有认证的问题了，而且向下兼容。    \n我们用到的蓝牙库为CoreBluetooth，而蓝牙库中首先要介绍下两个概念Central和Peripheral；\n\n# Central 和 Peripheral 在蓝牙交互中的角色\n\n><font color=#C0C0C0  size=4>所有涉及蓝牙低功耗的交互中有两个主要的角色：中心Central和外围设备Perpheral。根据一些传统的客户端-服务端结构，Peripheral通常具有其他设备所需要的数据，而Central通常通过使用Perpheral的信息来实现一些特定的功能。</font>\n\n这里我自己理解，如果你的设备连接的是本文这种蓝牙卡或者穿戴设备等，那么你的程序就是作为Central；如果你的设备是与另外一台iPhone设备，那么它既可以作为Central也可以作为Perpheral；\n\n想了解更详细请参照：[iOS蓝牙编程指南 -- 核心蓝牙概述](http://www.jianshu.com/p/760f042a1d81)\n\n# UUID\n\n每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。特征是与外界交互的最小单位。比如说，一台蓝牙4.0设备，用特征A来描述自己的出厂信息，用特征B来与收发数据等。\n\n服务和特征都是用UUID来唯一标识的，UUID的概念如果不清楚请自行google,国际蓝牙组织为一些很典型的设备(比如测量心跳和血压的设备)规定了标准的service UUID(特征的UUID比较多，这里就不列举了);        \n\n><font color=#C0C0C0  size=2>UUID含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。\nUUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。\n\n>UUID由以下几部分的组合：\n\n>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n\n>（2）时钟序列。\n\n>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\n>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。</font>\n\n# BLE中心模式流程\n\n1.建立中心角色    \n\n2.扫描外设(Discover Peripheral)    \n\n3.连接外设(Connect Peripheral)    \n\n4.扫描外设中的服务和特征(Discover Services And Characteristics)    \n\n5.利用特征与外设做数据交互(Explore And Interact)\n\n6.订阅Characteristic的通知\n\n7.断开连接(Disconnect)\n\n# 代码说明\n## 初始化 CBCentralManager\n\n```objective-c\ndispatch_queue_t centralQ = dispatch_queue_create(BLUETOOCH_QUEUE_IDENTIFER, DISPATCH_QUEUE_CONCURRENT);\n _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQ];\n```\n上面的代码中，将self设置为代理，用于接收各种 central 事件。将queue设置为nil，则表示直接在主线程中运行，这里是我自己定义的任务队列。\n\n创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。\n\n初始化 central manager 之后，设置的代理会调用centralManagerDidUpdateState:方法，所以需要去遵循<CBCentralManagerDelegate>协议。这个 did update state 的方法，能获得当前设备是否能作为 central。关于这个协议的实现和其他方法，接下来会讲到，也可以先看看[官方API](https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManagerDelegate_Protocol/index.html#//apple_ref/doc/uid/TP40011285)\n\n## 搜索当前可用的 peripheral\n\n可以使用*CBCentralManager的scanForPeripheralsWithServices:options:*方法来扫描周围正在发出广播的 Peripheral 设备。peripheral 每秒都在发送大量的数据包，*scanForPeripheralsWithServices:options:*方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral  都会调用 *centralManager:didDiscoverPeripheral:advertisementData:RSSI:* 方法。另外，当已发现的 peripheral  发送的数据包有变化时，这个代理方法同样会调用。\n\n```\nNSArray *services = @[[CBUUID UUIDWithString:BUSINESS_SERVICE_UUID_STRING]\nNSDictionary *scanOption = @{CBCentralManagerScanOptionAllowDuplicatesKey:@(NO)};\n[_centralManager scanForPeripheralsWithServices:services options:scanOption];\n```\n这里的services是中心要扫描的蓝牙设备类型，表示只搜索当前数组包含的设备（每个 peripheral 的 service 都有唯一标识——UUID）；而scanOption中的`CBCentralManagerScanOptionAllowDuplicatesKey`设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option 会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。\n\n在调用`scanForPeripheralsWithServices:options:`方法之后，找到可用设备，系统会回调（每找到一个都会回调）`centralManager:didDiscoverPeripheral:advertisementData:RSSI:`。该方法会已CBPeripheral返回找到的 peripheral，所以你可以使用数组将找到的 peripheral 存起来。\n\n```\n//扫描到蓝牙后的回调\n-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI{\n    //RSSI(Received Signal Strength Indication接收的信号强度指示)   \n    printf(\"didDiscoverPeripheral\\n\");\n    NSLog(@\"advertisement data is :%@\",advertisementData);\n    NSString* identifer = [peripheral.identifier UUIDString];\n}\n```\n\n## 连接 peripheral\n\n```\n//连接外围设备\n[_centralManager connectPeripheral:peripheral options:nil];\n```\n当连接成功后，会回调方法*centralManager:didConnectPeripheral:*。在这个方法中，你可以去记录当前的连接状态等数据。\n\n```\n-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{\n    printf(\"已连接上设备：\");\n    printf(\"name = %s\\n\",[peripheral.name UTF8String]);\n    \n    //连接到设备后要设置设备的代理，这样才可以接收到外围的服务与特性\n    peripheral.delegate = self;\n    \n    NSArray<CBUUID*>* uuids =@[\n\t[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],\n\t[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];\n\t//发现服务\n\t[peripheral discoverServices:uuids];\n}\n```\n如果连接断开则会回调：\n\n```\n//断开回调处理\n- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error{\n    printf(\"设备 %s 已断开！\\n\",[peripheral.name UTF8String]);\n}\n```\n失败的情况下则是： \n   \n```\n//连接失败回调\n-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error{\n    NSLog(@\"didFailToConnectPeripheral error:%@\",error);\n}\n```\n\n## 搜索 peripheral 的 service\n\n当与 peripheral 成功建立连接以后，就可以通信了。第一步是先找到当前 peripheral 提供的 service，因为 service 广播的数据有大小限制（貌似是 31 bytes），所以你实际找到的 service 的数量可能要比它广播时候说的数量要多。调用CBPeripheral的 `discoverServices:`方法可以找到当前 peripheral 的所有 service。\n\n```\n//在搜索过程中，并不是所有的 service和characteristic 都是我们需要的,如果全部搜索，依然会造成不必要的资源浪费。\n//这里的uuids是我工程中用到的UUID\nNSArray<CBUUID*>* uuids =@[\n[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],\n[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];\n//发现服务\n[peripheral discoverServices:uuids];\n```\n当找到特定的 Service 以后，会回调<CBPeripheralDelegate>的`peripheral:didDiscoverServices:`方法。Core Bluetooth 提供了CBService类来表示 service，找到以后，它们以数组的形式存入了当前 peripheral 的services属性中，你可以在当前回调中遍历这个属性。\n\n```\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error{ \n    if(error){\n        NSLog(@\"发现服务错误：%@\",error);\n        return;\n    }\n    printf(\"发现周边设备的服务:\\n\");\n    printf(\"==== didDiscoverServices ==== \\n\");\n \t\n     //发现服务中的特性 \n    for (CBService *service in peripheral.services) {\n        printf(\"-- service : %s\\n\",[[service.UUID UUIDString] UTF8String]);\n        [peripheral discoverCharacteristics:nil forService:service];\n    }\n}\n```\n## 搜索 service 的 characteristic\n\n找到需要的 service 之后，下一步是找它所提供的 characteristic。如果搜索全部 characteristic，那调用CBPeripheral的`discoverCharacteristics:forService:`方法即可。如果是搜索当前service的characteristic，那还应该传入相应的CBService对象：\n\n```\n[peripheral discoverCharacteristics:nil forService:service];\n```\n找到所有 characteristic 之后，回调`peripheral:didDiscoverCharacteristicsForService:error:`方法，此时 Core Bluetooth 提供了CBCharacteristic类来表示characteristic。可以通过以下代码来遍历找到的 characteristic ：\n\n```\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error{\n    printf(\"发现服务 :(%s)\\n\",[[service.UUID UUIDString] UTF8String]);\n    \n    if (error) {\n        NSLog(@\"There is a error in peripheral:didDiscoverCharacteristicsForService:error: which called:%@\",error);\n        return;\n    } \n    printf(\"开始读取服务数据...\\n\");\n    for (CBCharacteristic *characteristic in service.characteristics) {\n        NSLog(@\"properties is %lu\",characteristic.properties);\n        if (characteristic.properties & CBCharacteristicPropertyNotify) {\n//            [peripheral readValueForCharacteristic:characteristic];\n            [peripheral setNotifyValue:YES forCharacteristic:characteristic];\n        }\n    }\n}\n```\n## 读取 characteristic 数据\n\n这里读取涉及到两个方法：\n\n```\n[peripheral readValueForCharacteristic:characteristic];\n[peripheral setNotifyValue:YES forCharacteristic:characteristic];\n\n```\nread这种方法是需要主动去接收的；notify方法订阅，当有数据发送时，可以直接在回调中接收,如果 characteristic 的数据经常变化，那么采用订阅的方式更好；\n\n\n```\n//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n    if (error) {\n        NSLog(@\"There is a error in peripheral:didUpdateValueForCharacteristic:error: which called:%@\",error);\n        return;\n    }\n    NSLog(@\"characteristic data is:%@ \",characteristic.value);\n    NSLog(@\"characteristic data length is %ld\",characteristic.value.length);\n}\n\n```\n所以nofify可能会被调用多次，而且它获取的是实时数据，如果你接收蓝牙信息不是一次次接收的话，那么会用到它：\n\n```\n//中心读取外设实时数据\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n    printf(\"didUpdateNotificationStateForCharacteristic (%s)\\n\",[[characteristic.UUID UUIDString] UTF8String]);\n    if(error){\n        printf(\"error is : %s\\n\",[error.description UTF8String]);\n        return;\n    }\n    printf(\" update notification success !!\");\n    NSLog(@\"接收到的数据：%@\",characteristic.value);\n    }   \n}\n```\n[本文参考](http://www.saitjr.com/ios/core-bluetooth-read-write-as-central-role.html)，之后会继续讲解写数据和重连等问题；\n\n\n\n\n\n\n","slug":"iOS 作为Central蓝牙连接外围（上）","published":1,"updated":"2018-05-04T08:49:10.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucioe001b1v60jchmsj3s","content":"<p>Summary: 今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。<br><a id=\"more\"></a></p>\n<p>今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。难点主要集中在与蓝牙卡连接断开部分，因为蓝牙卡是低能耗的，每开启蓝牙卡片蓝牙后它会在8秒后自动断开连接，所以在处理蓝牙连接的的部分逻辑较为复杂。接下来我们把重点放在与蓝牙建立连接的部分，Google之，先来搞清楚与iOS有关的蓝牙库。    </p>\n<p>先说一下蓝牙版本问题，如果你的设备支持的是蓝牙4.0之前的版本，那么会涉及到一个MFI的概念，MFI（Make For ipod/ipad/iphone）是苹果的一套认证，只有少数的硬件厂商才有苹果的MFI认证，做之前需要搞定这个认证。使用蓝牙4.0的话，由于4.0苹果开放了BLE（Bluetooth Low Energy）通道，就不会有认证的问题了，而且向下兼容。<br>我们用到的蓝牙库为CoreBluetooth，而蓝牙库中首先要介绍下两个概念Central和Peripheral；</p>\n<h1 id=\"Central-和-Peripheral-在蓝牙交互中的角色\"><a href=\"#Central-和-Peripheral-在蓝牙交互中的角色\" class=\"headerlink\" title=\"Central 和 Peripheral 在蓝牙交互中的角色\"></a>Central 和 Peripheral 在蓝牙交互中的角色</h1><blockquote>\n<font color=\"#C0C0C0\" size=\"4\">所有涉及蓝牙低功耗的交互中有两个主要的角色：中心Central和外围设备Perpheral。根据一些传统的客户端-服务端结构，Peripheral通常具有其他设备所需要的数据，而Central通常通过使用Perpheral的信息来实现一些特定的功能。</font>\n</blockquote>\n<p>这里我自己理解，如果你的设备连接的是本文这种蓝牙卡或者穿戴设备等，那么你的程序就是作为Central；如果你的设备是与另外一台iPhone设备，那么它既可以作为Central也可以作为Perpheral；</p>\n<p>想了解更详细请参照：<a href=\"http://www.jianshu.com/p/760f042a1d81\" target=\"_blank\" rel=\"noopener\">iOS蓝牙编程指南 – 核心蓝牙概述</a></p>\n<h1 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h1><p>每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。特征是与外界交互的最小单位。比如说，一台蓝牙4.0设备，用特征A来描述自己的出厂信息，用特征B来与收发数据等。</p>\n<p>服务和特征都是用UUID来唯一标识的，UUID的概念如果不清楚请自行google,国际蓝牙组织为一些很典型的设备(比如测量心跳和血压的设备)规定了标准的service UUID(特征的UUID比较多，这里就不列举了);        </p>\n<blockquote>\n<p><font color=\"#C0C0C0\" size=\"2\">UUID含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。<br>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</font></p>\n</blockquote>\n<blockquote>\n<p>UUID由以下几部分的组合：</p>\n</blockquote>\n<blockquote>\n<p>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>\n</blockquote>\n<blockquote>\n<p>（2）时钟序列。</p>\n</blockquote>\n<blockquote>\n<p>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。<br>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。</p>\n</blockquote>\n<h1 id=\"BLE中心模式流程\"><a href=\"#BLE中心模式流程\" class=\"headerlink\" title=\"BLE中心模式流程\"></a>BLE中心模式流程</h1><p>1.建立中心角色    </p>\n<p>2.扫描外设(Discover Peripheral)    </p>\n<p>3.连接外设(Connect Peripheral)    </p>\n<p>4.扫描外设中的服务和特征(Discover Services And Characteristics)    </p>\n<p>5.利用特征与外设做数据交互(Explore And Interact)</p>\n<p>6.订阅Characteristic的通知</p>\n<p>7.断开连接(Disconnect)</p>\n<h1 id=\"代码说明\"><a href=\"#代码说明\" class=\"headerlink\" title=\"代码说明\"></a>代码说明</h1><h2 id=\"初始化-CBCentralManager\"><a href=\"#初始化-CBCentralManager\" class=\"headerlink\" title=\"初始化 CBCentralManager\"></a>初始化 CBCentralManager</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t centralQ = dispatch_queue_create(BLUETOOCH_QUEUE_IDENTIFER, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"> _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQ];</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，将self设置为代理，用于接收各种 central 事件。将queue设置为nil，则表示直接在主线程中运行，这里是我自己定义的任务队列。</p>\n<p>创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>\n<p>初始化 central manager 之后，设置的代理会调用centralManagerDidUpdateState:方法，所以需要去遵循<cbcentralmanagerdelegate>协议。这个 did update state 的方法，能获得当前设备是否能作为 central。关于这个协议的实现和其他方法，接下来会讲到，也可以先看看<a href=\"https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManagerDelegate_Protocol/index.html#//apple_ref/doc/uid/TP40011285\" target=\"_blank\" rel=\"noopener\">官方API</a></cbcentralmanagerdelegate></p>\n<h2 id=\"搜索当前可用的-peripheral\"><a href=\"#搜索当前可用的-peripheral\" class=\"headerlink\" title=\"搜索当前可用的 peripheral\"></a>搜索当前可用的 peripheral</h2><p>可以使用<em>CBCentralManager的scanForPeripheralsWithServices:options:</em>方法来扫描周围正在发出广播的 Peripheral 设备。peripheral 每秒都在发送大量的数据包，<em>scanForPeripheralsWithServices:options:</em>方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral  都会调用 <em>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</em> 方法。另外，当已发现的 peripheral  发送的数据包有变化时，这个代理方法同样会调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray *services = @[[CBUUID UUIDWithString:BUSINESS_SERVICE_UUID_STRING]</span><br><span class=\"line\">NSDictionary *scanOption = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@(NO)&#125;;</span><br><span class=\"line\">[_centralManager scanForPeripheralsWithServices:services options:scanOption];</span><br></pre></td></tr></table></figure>\n<p>这里的services是中心要扫描的蓝牙设备类型，表示只搜索当前数组包含的设备（每个 peripheral 的 service 都有唯一标识——UUID）；而scanOption中的<code>CBCentralManagerScanOptionAllowDuplicatesKey</code>设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option 会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。</p>\n<p>在调用<code>scanForPeripheralsWithServices:options:</code>方法之后，找到可用设备，系统会回调（每找到一个都会回调）<code>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</code>。该方法会已CBPeripheral返回找到的 peripheral，所以你可以使用数组将找到的 peripheral 存起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//扫描到蓝牙后的回调</span><br><span class=\"line\">-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123;</span><br><span class=\"line\">    //RSSI(Received Signal Strength Indication接收的信号强度指示)   </span><br><span class=\"line\">    printf(&quot;didDiscoverPeripheral\\n&quot;);</span><br><span class=\"line\">    NSLog(@&quot;advertisement data is :%@&quot;,advertisementData);</span><br><span class=\"line\">    NSString* identifer = [peripheral.identifier UUIDString];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"连接-peripheral\"><a href=\"#连接-peripheral\" class=\"headerlink\" title=\"连接 peripheral\"></a>连接 peripheral</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//连接外围设备</span><br><span class=\"line\">[_centralManager connectPeripheral:peripheral options:nil];</span><br></pre></td></tr></table></figure>\n<p>当连接成功后，会回调方法<em>centralManager:didConnectPeripheral:</em>。在这个方法中，你可以去记录当前的连接状态等数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123;</span><br><span class=\"line\">    printf(&quot;已连接上设备：&quot;);</span><br><span class=\"line\">    printf(&quot;name = %s\\n&quot;,[peripheral.name UTF8String]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //连接到设备后要设置设备的代理，这样才可以接收到外围的服务与特性</span><br><span class=\"line\">    peripheral.delegate = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray&lt;CBUUID*&gt;* uuids =@[</span><br><span class=\"line\">\t[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],</span><br><span class=\"line\">\t[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];</span><br><span class=\"line\">\t//发现服务</span><br><span class=\"line\">\t[peripheral discoverServices:uuids];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果连接断开则会回调：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//断开回调处理</span><br><span class=\"line\">- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</span><br><span class=\"line\">    printf(&quot;设备 %s 已断开！\\n&quot;,[peripheral.name UTF8String]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>失败的情况下则是： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//连接失败回调</span><br><span class=\"line\">-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</span><br><span class=\"line\">    NSLog(@&quot;didFailToConnectPeripheral error:%@&quot;,error);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"搜索-peripheral-的-service\"><a href=\"#搜索-peripheral-的-service\" class=\"headerlink\" title=\"搜索 peripheral 的 service\"></a>搜索 peripheral 的 service</h2><p>当与 peripheral 成功建立连接以后，就可以通信了。第一步是先找到当前 peripheral 提供的 service，因为 service 广播的数据有大小限制（貌似是 31 bytes），所以你实际找到的 service 的数量可能要比它广播时候说的数量要多。调用CBPeripheral的 <code>discoverServices:</code>方法可以找到当前 peripheral 的所有 service。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在搜索过程中，并不是所有的 service和characteristic 都是我们需要的,如果全部搜索，依然会造成不必要的资源浪费。</span><br><span class=\"line\">//这里的uuids是我工程中用到的UUID</span><br><span class=\"line\">NSArray&lt;CBUUID*&gt;* uuids =@[</span><br><span class=\"line\">[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],</span><br><span class=\"line\">[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];</span><br><span class=\"line\">//发现服务</span><br><span class=\"line\">[peripheral discoverServices:uuids];</span><br></pre></td></tr></table></figure>\n<p>当找到特定的 Service 以后，会回调<cbperipheraldelegate>的<code>peripheral:didDiscoverServices:</code>方法。Core Bluetooth 提供了CBService类来表示 service，找到以后，它们以数组的形式存入了当前 peripheral 的services属性中，你可以在当前回调中遍历这个属性。</cbperipheraldelegate></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; </span><br><span class=\"line\">    if(error)&#123;</span><br><span class=\"line\">        NSLog(@&quot;发现服务错误：%@&quot;,error);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;发现周边设备的服务:\\n&quot;);</span><br><span class=\"line\">    printf(&quot;==== didDiscoverServices ==== \\n&quot;);</span><br><span class=\"line\"> \t</span><br><span class=\"line\">     //发现服务中的特性 </span><br><span class=\"line\">    for (CBService *service in peripheral.services) &#123;</span><br><span class=\"line\">        printf(&quot;-- service : %s\\n&quot;,[[service.UUID UUIDString] UTF8String]);</span><br><span class=\"line\">        [peripheral discoverCharacteristics:nil forService:service];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"搜索-service-的-characteristic\"><a href=\"#搜索-service-的-characteristic\" class=\"headerlink\" title=\"搜索 service 的 characteristic\"></a>搜索 service 的 characteristic</h2><p>找到需要的 service 之后，下一步是找它所提供的 characteristic。如果搜索全部 characteristic，那调用CBPeripheral的<code>discoverCharacteristics:forService:</code>方法即可。如果是搜索当前service的characteristic，那还应该传入相应的CBService对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral discoverCharacteristics:nil forService:service];</span><br></pre></td></tr></table></figure>\n<p>找到所有 characteristic 之后，回调<code>peripheral:didDiscoverCharacteristicsForService:error:</code>方法，此时 Core Bluetooth 提供了CBCharacteristic类来表示characteristic。可以通过以下代码来遍历找到的 characteristic ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123;</span><br><span class=\"line\">    printf(&quot;发现服务 :(%s)\\n&quot;,[[service.UUID UUIDString] UTF8String]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;There is a error in peripheral:didDiscoverCharacteristicsForService:error: which called:%@&quot;,error);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    printf(&quot;开始读取服务数据...\\n&quot;);</span><br><span class=\"line\">    for (CBCharacteristic *characteristic in service.characteristics) &#123;</span><br><span class=\"line\">        NSLog(@&quot;properties is %lu&quot;,characteristic.properties);</span><br><span class=\"line\">        if (characteristic.properties &amp; CBCharacteristicPropertyNotify) &#123;</span><br><span class=\"line\">//            [peripheral readValueForCharacteristic:characteristic];</span><br><span class=\"line\">            [peripheral setNotifyValue:YES forCharacteristic:characteristic];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"读取-characteristic-数据\"><a href=\"#读取-characteristic-数据\" class=\"headerlink\" title=\"读取 characteristic 数据\"></a>读取 characteristic 数据</h2><p>这里读取涉及到两个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral readValueForCharacteristic:characteristic];</span><br><span class=\"line\">[peripheral setNotifyValue:YES forCharacteristic:characteristic];</span><br></pre></td></tr></table></figure>\n<p>read这种方法是需要主动去接收的；notify方法订阅，当有数据发送时，可以直接在回调中接收,如果 characteristic 的数据经常变化，那么采用订阅的方式更好；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。</span><br><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;There is a error in peripheral:didUpdateValueForCharacteristic:error: which called:%@&quot;,error);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSLog(@&quot;characteristic data is:%@ &quot;,characteristic.value);</span><br><span class=\"line\">    NSLog(@&quot;characteristic data length is %ld&quot;,characteristic.value.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以nofify可能会被调用多次，而且它获取的是实时数据，如果你接收蓝牙信息不是一次次接收的话，那么会用到它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//中心读取外设实时数据</span><br><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</span><br><span class=\"line\">    printf(&quot;didUpdateNotificationStateForCharacteristic (%s)\\n&quot;,[[characteristic.UUID UUIDString] UTF8String]);</span><br><span class=\"line\">    if(error)&#123;</span><br><span class=\"line\">        printf(&quot;error is : %s\\n&quot;,[error.description UTF8String]);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot; update notification success !!&quot;);</span><br><span class=\"line\">    NSLog(@&quot;接收到的数据：%@&quot;,characteristic.value);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.saitjr.com/ios/core-bluetooth-read-write-as-central-role.html\" target=\"_blank\" rel=\"noopener\">本文参考</a>，之后会继续讲解写数据和重连等问题；</p>\n","site":{"data":{}},"excerpt":"<p>Summary: 今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。<br>","more":"</p>\n<p>今天说一说iOS蓝牙相关的东西，本文背景是公司的蓝牙项目，项目要求是利用手机蓝牙模块与低功耗蓝牙卡进行通信，蓝牙卡信息解析由卡厂商提供，而我们先要做的就是建立手机与蓝牙卡的连接。难点主要集中在与蓝牙卡连接断开部分，因为蓝牙卡是低能耗的，每开启蓝牙卡片蓝牙后它会在8秒后自动断开连接，所以在处理蓝牙连接的的部分逻辑较为复杂。接下来我们把重点放在与蓝牙建立连接的部分，Google之，先来搞清楚与iOS有关的蓝牙库。    </p>\n<p>先说一下蓝牙版本问题，如果你的设备支持的是蓝牙4.0之前的版本，那么会涉及到一个MFI的概念，MFI（Make For ipod/ipad/iphone）是苹果的一套认证，只有少数的硬件厂商才有苹果的MFI认证，做之前需要搞定这个认证。使用蓝牙4.0的话，由于4.0苹果开放了BLE（Bluetooth Low Energy）通道，就不会有认证的问题了，而且向下兼容。<br>我们用到的蓝牙库为CoreBluetooth，而蓝牙库中首先要介绍下两个概念Central和Peripheral；</p>\n<h1 id=\"Central-和-Peripheral-在蓝牙交互中的角色\"><a href=\"#Central-和-Peripheral-在蓝牙交互中的角色\" class=\"headerlink\" title=\"Central 和 Peripheral 在蓝牙交互中的角色\"></a>Central 和 Peripheral 在蓝牙交互中的角色</h1><blockquote>\n<font color=\"#C0C0C0\" size=\"4\">所有涉及蓝牙低功耗的交互中有两个主要的角色：中心Central和外围设备Perpheral。根据一些传统的客户端-服务端结构，Peripheral通常具有其他设备所需要的数据，而Central通常通过使用Perpheral的信息来实现一些特定的功能。</font>\n</blockquote>\n<p>这里我自己理解，如果你的设备连接的是本文这种蓝牙卡或者穿戴设备等，那么你的程序就是作为Central；如果你的设备是与另外一台iPhone设备，那么它既可以作为Central也可以作为Perpheral；</p>\n<p>想了解更详细请参照：<a href=\"http://www.jianshu.com/p/760f042a1d81\" target=\"_blank\" rel=\"noopener\">iOS蓝牙编程指南 – 核心蓝牙概述</a></p>\n<h1 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h1><p>每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。特征是与外界交互的最小单位。比如说，一台蓝牙4.0设备，用特征A来描述自己的出厂信息，用特征B来与收发数据等。</p>\n<p>服务和特征都是用UUID来唯一标识的，UUID的概念如果不清楚请自行google,国际蓝牙组织为一些很典型的设备(比如测量心跳和血压的设备)规定了标准的service UUID(特征的UUID比较多，这里就不列举了);        </p>\n<blockquote>\n<p><font color=\"#C0C0C0\" size=\"2\">UUID含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。<br>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</font></p>\n</blockquote>\n<blockquote>\n<p>UUID由以下几部分的组合：</p>\n</blockquote>\n<blockquote>\n<p>（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>\n</blockquote>\n<blockquote>\n<p>（2）时钟序列。</p>\n</blockquote>\n<blockquote>\n<p>（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。<br>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。</p>\n</blockquote>\n<h1 id=\"BLE中心模式流程\"><a href=\"#BLE中心模式流程\" class=\"headerlink\" title=\"BLE中心模式流程\"></a>BLE中心模式流程</h1><p>1.建立中心角色    </p>\n<p>2.扫描外设(Discover Peripheral)    </p>\n<p>3.连接外设(Connect Peripheral)    </p>\n<p>4.扫描外设中的服务和特征(Discover Services And Characteristics)    </p>\n<p>5.利用特征与外设做数据交互(Explore And Interact)</p>\n<p>6.订阅Characteristic的通知</p>\n<p>7.断开连接(Disconnect)</p>\n<h1 id=\"代码说明\"><a href=\"#代码说明\" class=\"headerlink\" title=\"代码说明\"></a>代码说明</h1><h2 id=\"初始化-CBCentralManager\"><a href=\"#初始化-CBCentralManager\" class=\"headerlink\" title=\"初始化 CBCentralManager\"></a>初始化 CBCentralManager</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t centralQ = dispatch_queue_create(BLUETOOCH_QUEUE_IDENTIFER, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"> _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:centralQ];</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，将self设置为代理，用于接收各种 central 事件。将queue设置为nil，则表示直接在主线程中运行，这里是我自己定义的任务队列。</p>\n<p>创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>\n<p>初始化 central manager 之后，设置的代理会调用centralManagerDidUpdateState:方法，所以需要去遵循<cbcentralmanagerdelegate>协议。这个 did update state 的方法，能获得当前设备是否能作为 central。关于这个协议的实现和其他方法，接下来会讲到，也可以先看看<a href=\"https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBCentralManagerDelegate_Protocol/index.html#//apple_ref/doc/uid/TP40011285\" target=\"_blank\" rel=\"noopener\">官方API</a></cbcentralmanagerdelegate></p>\n<h2 id=\"搜索当前可用的-peripheral\"><a href=\"#搜索当前可用的-peripheral\" class=\"headerlink\" title=\"搜索当前可用的 peripheral\"></a>搜索当前可用的 peripheral</h2><p>可以使用<em>CBCentralManager的scanForPeripheralsWithServices:options:</em>方法来扫描周围正在发出广播的 Peripheral 设备。peripheral 每秒都在发送大量的数据包，<em>scanForPeripheralsWithServices:options:</em>方法会将同一 peripheral 发出的多个数据包合并为一个事件，然后每找到一个 peripheral  都会调用 <em>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</em> 方法。另外，当已发现的 peripheral  发送的数据包有变化时，这个代理方法同样会调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray *services = @[[CBUUID UUIDWithString:BUSINESS_SERVICE_UUID_STRING]</span><br><span class=\"line\">NSDictionary *scanOption = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@(NO)&#125;;</span><br><span class=\"line\">[_centralManager scanForPeripheralsWithServices:services options:scanOption];</span><br></pre></td></tr></table></figure>\n<p>这里的services是中心要扫描的蓝牙设备类型，表示只搜索当前数组包含的设备（每个 peripheral 的 service 都有唯一标识——UUID）；而scanOption中的<code>CBCentralManagerScanOptionAllowDuplicatesKey</code>设置以后，每收到广播，就会调用上面的回调（无论广播数据是否一样）。关闭默认行为一般用于以下场景：根据 peripheral 的距离来初始化连接（距离可用信号强度 RSSI 来判断）。设置这个 option 会对电池寿命和 app 的性能产生不利影响，所以一定要在必要的时候，再对其进行设置。</p>\n<p>在调用<code>scanForPeripheralsWithServices:options:</code>方法之后，找到可用设备，系统会回调（每找到一个都会回调）<code>centralManager:didDiscoverPeripheral:advertisementData:RSSI:</code>。该方法会已CBPeripheral返回找到的 peripheral，所以你可以使用数组将找到的 peripheral 存起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//扫描到蓝牙后的回调</span><br><span class=\"line\">-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI&#123;</span><br><span class=\"line\">    //RSSI(Received Signal Strength Indication接收的信号强度指示)   </span><br><span class=\"line\">    printf(&quot;didDiscoverPeripheral\\n&quot;);</span><br><span class=\"line\">    NSLog(@&quot;advertisement data is :%@&quot;,advertisementData);</span><br><span class=\"line\">    NSString* identifer = [peripheral.identifier UUIDString];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"连接-peripheral\"><a href=\"#连接-peripheral\" class=\"headerlink\" title=\"连接 peripheral\"></a>连接 peripheral</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//连接外围设备</span><br><span class=\"line\">[_centralManager connectPeripheral:peripheral options:nil];</span><br></pre></td></tr></table></figure>\n<p>当连接成功后，会回调方法<em>centralManager:didConnectPeripheral:</em>。在这个方法中，你可以去记录当前的连接状态等数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123;</span><br><span class=\"line\">    printf(&quot;已连接上设备：&quot;);</span><br><span class=\"line\">    printf(&quot;name = %s\\n&quot;,[peripheral.name UTF8String]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //连接到设备后要设置设备的代理，这样才可以接收到外围的服务与特性</span><br><span class=\"line\">    peripheral.delegate = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray&lt;CBUUID*&gt;* uuids =@[</span><br><span class=\"line\">\t[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],</span><br><span class=\"line\">\t[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];</span><br><span class=\"line\">\t//发现服务</span><br><span class=\"line\">\t[peripheral discoverServices:uuids];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果连接断开则会回调：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//断开回调处理</span><br><span class=\"line\">- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</span><br><span class=\"line\">    printf(&quot;设备 %s 已断开！\\n&quot;,[peripheral.name UTF8String]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>失败的情况下则是： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//连接失败回调</span><br><span class=\"line\">-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</span><br><span class=\"line\">    NSLog(@&quot;didFailToConnectPeripheral error:%@&quot;,error);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"搜索-peripheral-的-service\"><a href=\"#搜索-peripheral-的-service\" class=\"headerlink\" title=\"搜索 peripheral 的 service\"></a>搜索 peripheral 的 service</h2><p>当与 peripheral 成功建立连接以后，就可以通信了。第一步是先找到当前 peripheral 提供的 service，因为 service 广播的数据有大小限制（貌似是 31 bytes），所以你实际找到的 service 的数量可能要比它广播时候说的数量要多。调用CBPeripheral的 <code>discoverServices:</code>方法可以找到当前 peripheral 的所有 service。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在搜索过程中，并不是所有的 service和characteristic 都是我们需要的,如果全部搜索，依然会造成不必要的资源浪费。</span><br><span class=\"line\">//这里的uuids是我工程中用到的UUID</span><br><span class=\"line\">NSArray&lt;CBUUID*&gt;* uuids =@[</span><br><span class=\"line\">[CBUUID UUIDWithString:WRITE_CHARACTERISTIC_UUID_STRING],</span><br><span class=\"line\">[CBUUID UUIDWithString:READ_CHARACTERISTIC_UUID_STRING]];</span><br><span class=\"line\">//发现服务</span><br><span class=\"line\">[peripheral discoverServices:uuids];</span><br></pre></td></tr></table></figure>\n<p>当找到特定的 Service 以后，会回调<cbperipheraldelegate>的<code>peripheral:didDiscoverServices:</code>方法。Core Bluetooth 提供了CBService类来表示 service，找到以后，它们以数组的形式存入了当前 peripheral 的services属性中，你可以在当前回调中遍历这个属性。</cbperipheraldelegate></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; </span><br><span class=\"line\">    if(error)&#123;</span><br><span class=\"line\">        NSLog(@&quot;发现服务错误：%@&quot;,error);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot;发现周边设备的服务:\\n&quot;);</span><br><span class=\"line\">    printf(&quot;==== didDiscoverServices ==== \\n&quot;);</span><br><span class=\"line\"> \t</span><br><span class=\"line\">     //发现服务中的特性 </span><br><span class=\"line\">    for (CBService *service in peripheral.services) &#123;</span><br><span class=\"line\">        printf(&quot;-- service : %s\\n&quot;,[[service.UUID UUIDString] UTF8String]);</span><br><span class=\"line\">        [peripheral discoverCharacteristics:nil forService:service];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"搜索-service-的-characteristic\"><a href=\"#搜索-service-的-characteristic\" class=\"headerlink\" title=\"搜索 service 的 characteristic\"></a>搜索 service 的 characteristic</h2><p>找到需要的 service 之后，下一步是找它所提供的 characteristic。如果搜索全部 characteristic，那调用CBPeripheral的<code>discoverCharacteristics:forService:</code>方法即可。如果是搜索当前service的characteristic，那还应该传入相应的CBService对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral discoverCharacteristics:nil forService:service];</span><br></pre></td></tr></table></figure>\n<p>找到所有 characteristic 之后，回调<code>peripheral:didDiscoverCharacteristicsForService:error:</code>方法，此时 Core Bluetooth 提供了CBCharacteristic类来表示characteristic。可以通过以下代码来遍历找到的 characteristic ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123;</span><br><span class=\"line\">    printf(&quot;发现服务 :(%s)\\n&quot;,[[service.UUID UUIDString] UTF8String]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;There is a error in peripheral:didDiscoverCharacteristicsForService:error: which called:%@&quot;,error);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    printf(&quot;开始读取服务数据...\\n&quot;);</span><br><span class=\"line\">    for (CBCharacteristic *characteristic in service.characteristics) &#123;</span><br><span class=\"line\">        NSLog(@&quot;properties is %lu&quot;,characteristic.properties);</span><br><span class=\"line\">        if (characteristic.properties &amp; CBCharacteristicPropertyNotify) &#123;</span><br><span class=\"line\">//            [peripheral readValueForCharacteristic:characteristic];</span><br><span class=\"line\">            [peripheral setNotifyValue:YES forCharacteristic:characteristic];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"读取-characteristic-数据\"><a href=\"#读取-characteristic-数据\" class=\"headerlink\" title=\"读取 characteristic 数据\"></a>读取 characteristic 数据</h2><p>这里读取涉及到两个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral readValueForCharacteristic:characteristic];</span><br><span class=\"line\">[peripheral setNotifyValue:YES forCharacteristic:characteristic];</span><br></pre></td></tr></table></figure>\n<p>read这种方法是需要主动去接收的；notify方法订阅，当有数据发送时，可以直接在回调中接收,如果 characteristic 的数据经常变化，那么采用订阅的方式更好；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取外设发来的数据，不论是read和notify,获取数据都是从这个方法中读取。</span><br><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;There is a error in peripheral:didUpdateValueForCharacteristic:error: which called:%@&quot;,error);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSLog(@&quot;characteristic data is:%@ &quot;,characteristic.value);</span><br><span class=\"line\">    NSLog(@&quot;characteristic data length is %ld&quot;,characteristic.value.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以nofify可能会被调用多次，而且它获取的是实时数据，如果你接收蓝牙信息不是一次次接收的话，那么会用到它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//中心读取外设实时数据</span><br><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</span><br><span class=\"line\">    printf(&quot;didUpdateNotificationStateForCharacteristic (%s)\\n&quot;,[[characteristic.UUID UUIDString] UTF8String]);</span><br><span class=\"line\">    if(error)&#123;</span><br><span class=\"line\">        printf(&quot;error is : %s\\n&quot;,[error.description UTF8String]);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printf(&quot; update notification success !!&quot;);</span><br><span class=\"line\">    NSLog(@&quot;接收到的数据：%@&quot;,characteristic.value);</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.saitjr.com/ios/core-bluetooth-read-write-as-central-role.html\" target=\"_blank\" rel=\"noopener\">本文参考</a>，之后会继续讲解写数据和重连等问题；</p>"},{"title":"iOS 作为Central蓝牙连接外围（下）","date":"2016-05-29T12:48:00.000Z","_content":"\nSummary: 仍然是公司蓝牙卡项目，搞了两周，现在大致搞定，作一个总结；首先要把上篇遗留下来的蓝牙外围设备写数据等问题解决下...\n<!-- more -->\n\n\n## 解决蓝牙写数据等问题\n### 更正读数据的一个问题\n\n更正一个问题，就是读数据时notify和read的两个回调，本人实测回调notification只是在之后回调一次，而不论读数据采用以上哪种，updataValue方法总是会执行，而且有时还不只是一次；\n\n\n总结：\n\n1.read方法时，回调updataValue；nofify时，notification回调一次后，updataValue再开始调，且不只一次；\n\n2.接收 characteristic 数据的方式有两种：\n\n在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。\n用 setNotifyValue:forCharacteristic: 方法订阅，当有数据发送时，可以直接在回调中接收。\n\n### 向 characteristic 写数据\n\n写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。\n\n```\n[peripheral writeValue:dataToWrite forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n```\n\n上面的那个type参数是表示是否需要在写入后进行回调，这里的意思是需要回调，那么将在下面这个函数回调:\n\n```\n- (void)peripheral:(CBPeripheral *)peripheral\ndidWriteValueForCharacteristic:(CBCharacteristic *)characteristic\n             error:(NSError *)error {\n \n    if (error) {\n        NSLog(@\"Error writing characteristic value: %@\", [error localizedDescription]);\n    }\n}\n```\n\n### 读写补充\n\n在不用和 peripheral 通信的时候，应当将连接断开，这也对节能有好处。在以下两种情况下，连接应该被断开：\n\n当 characteristic 不再发送数据时。（可以通过 isNotifying 属性来判断）\n你已经接收到了你所需要的所有数据时。\n以上两种情况，都需要先结束订阅，然后断开连接。\n\n```\n[peripheral setNotifyValue:NO forCharacteristic:characteristic];\n[myCentralManager cancelPeripheralConnection:peripheral];\n```\n\n**cancelPeripheralConnection:** 是非阻塞性的，如果在 peripheral 挂起的状态去尝试断开连接，那么这个断开操作可能执行，也可能不会。因为可能还有其他的 central 连着它，所以取消连接并不代表底层连接也断开。从 app 的层面来讲，在 peripheral 决定断开的时候，会调用 **CBCentralManagerDelegate**  的 **centralManager:didDisconnectPeripheral:error:** 方法。\n\n另外关于蓝牙重连等的相关东西，这里就不一一说了，有兴趣的还是到本文参考文章中去找答案吧！再次感谢广大的代码工作者们！\n\n------------------------------------\n\n# 项目总结\n## 关于结构方面的\n\n这一点呢是个人习惯的问题，我们一般在工作中会接手到一些别人做了一半的任务，只有部分功能被实现的很好，那么这时就需要大量改动代码了。个人的建议是，不要在原来的模块中做修改，而是添加一个中间层，新实现的功能封装在新的类中，等到所有功能全部实现，再进行项目整合，因为这个时候对项目基本上能算作是了解，重构的时候也相对容易些。\n\n第二点是关于iOS block与delegate选择上的意见，上面一点中说的中间层最好选用block，因为在逻辑上真的是很好理解，而且不容易出错，少写很多代码；而代理的话适合暴露出去，被其他人使用，这样调用你代码的人会在结构上相对好把握，自由度要大些。\n\nPS:既然说到了block，我们补充一点，如果你想让自己的block失效，ARC下只要让他的指针置空就可以了，当然如果你只是对它进行了第二次赋值，那么之前指针所指向的block块是没有被失效的。\n\n## 说说写代码的一些\n\n1.就像本项目中用到的蓝牙，这些都是不需要在主线程中做的事情，诸如此类的相关还有网络连接，喇叭，话筒等（），将它们扔在后台线程中，任务完成之后回到主线程中修改UI;\n\n2.一些超时操作，我们需要的把它也扔在后台线程中，你可以用:\n\n```\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            _scanTimer = [NSTimer scheduledTimerWithTimeInterval:seconds target:self selector:@selector(scanTimeoutHandler:) userInfo:nil repeats:NO];\n            });\n\n```\n也可以这样：\n\n\n```\n[self performSelector:@selector(scanTimeoutHandler:) withObject:nil afterDelay:seconds inModes:@[NSDefaultRunLoopMode]];\n```\n或者直接把它加到你的一个runloop中：\n\n```\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n否则它一直占用着当前的线程会给你带来很大的困扰；\n\n3.NSStream Socket网络编程\n\nNSStream很简单，用到的东西并不是很多就可以做一个简单的socket；NSStreamDelegate,NSInputStream,NSOutStream，一个代理和两个对象，连接的时候像这样：\n\n\n```\n- (void)connectToHostUseStreamWithIP:(NSString *)host port:(int)port data:(NSData *)data{\n    // 1.建立连接\n    // 定义C语言输入输出流\n    CFReadStreamRef readStream;\n    CFWriteStreamRef writeStream;\n    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &readStream, &writeStream);\n    \n    // 把C语言的输入输出流转化成OC对象\n    _inputStream = (__bridge NSInputStream *)(readStream);\n    _outputStream = (__bridge NSOutputStream *)(writeStream);\n    \n    // 设置代理\n    _inputStream.delegate = self;\n    _outputStream.delegate = self;\n    \n    // 把输入输入流添加到运行循环\n    [_inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    [_outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    \n    // 打开输入输出流\n    [_inputStream open];\n    [_outputStream open];\n    \n    //发送数据\n    [[NSRunLoop currentRunLoop] run];\n}\n```\n\n断开时候：\n\n```\n- (void)stopConnect{\n    // 从运行循环移除\n    [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    // 关闭输入输出流\n    [_inputStream close];\n    [_outputStream close];\n    \n    _inputStream = nil;\n    _outputStream = nil;\n    \n    NSLog(@\"Socket 连接已断开！\");\n}\n```\n代理只有一个回调函数，你所有的事情全部需要在这里面解决；\n\n```\n-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode{\n    NSLog(@\"%@\",[NSThread currentThread]);\n    //    NSStreamEventOpenCompleted = 1UL << 0,//输入输出流打开完成\n    //    NSStreamEventHasBytesAvailable = 1UL << 1,//有字节可读\n    //    NSStreamEventHasSpaceAvailable = 1UL << 2,//可以发放字节\n    //    NSStreamEventErrorOccurred = 1UL << 3,// 连接出现错误\n    //    NSStreamEventEndEncountered = 1UL << 4// 连接结束\n    \n    switch (eventCode) {\n        case NSStreamEventOpenCompleted:\n                NSLog(@\"输入输出流打开完成\");\n                break;\n        case NSStreamEventHasBytesAvailable:\n                NSLog(@\"有字节可读\");\n                [self readDataFromSocket];\n                break;\n        case NSStreamEventHasSpaceAvailable:\n                NSLog(@\"可以发送字节\");\n            [self sendDataToSocket];\n                break;\n        case NSStreamEventErrorOccurred:\n                NSLog(@\"连接出现错误\");\n                break;\n        case NSStreamEventEndEncountered:\n                NSLog(@\"连接结束\");\n     \n     \n        // 从运行循环移除\n        [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n        [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n            \n            \n        // 关闭输入输出流\n        [_inputStream close];\n        [_outputStream close];\n                break;\n        default:\n                break;\n     }\n}\n```\n\n记住，一定是自己单独开一个线程，socket会一直占用着线程，如果你不把它自己关掉，那么它会无休止的连接着，你无法做一些其他的事情，所以，这一点很重要；\n\n另外，用完一定要关掉它，一定，一定，重要的事情多说几遍；\n\n4.状态机\n\n我们在项目中有时会遇到一些状态值，一般情况下枚举将会是个好选择，然而当你遇到的状态是多选择的就显得不那么好用了；于是本项目中我用到的option会是一个好的点子；我们先上代码，然后来解释；\n\n```\ntypedef NS_OPTIONS(NSUInteger,CardOperationState) {\n    CardOperationState_idle = 0,\n    \n    CardOperationState_ReadCorrect = 1 << 0, //读卡成功 1\n    CardOperationState_ReadWrong = 1 << 1,   //读卡失败 2\n    \n    CardOperationState_Checkouted = 1 << 2,      //已校验密码 4\n    CardOperationState_Written = 1 << 3,         //数据已写入成功 8\n    CardOperationState_ChangedPass = 1 << 4,     //已修改密码\n};\n\n```\n\n举个例子，如果你要表示的状态是已校验，已写入，已修改，那你的这个状态应该是:\n\n\n```\nstate == CardOperationState_Checkouted | CardOperationState_Written| CardOperationState_ChangedPass\n```\n用枚举的话那要用好几个判断:\n\n\n```\nstate == CardOperationState_Checkouted && state == CardOperationState_Written && state == CardOperationState_ChangedPass \n```\n很明显，option少写了很多判断；\n\n当前状态添加一个状态：\n\n```\ncurrentState = currentState | CardOperationState_Checkouted;//增加已校验状态\n```\n减少一个状态：\n\n```\ncurrentState = currentState & (~CardOperationState_ReadCorrect);\n```\n\n判断是否包含一个状态:\n\n```\ncurrentState & CardOperationState_Checkouted\n```\n\n\n","source":"_posts/iOS 作为Central蓝牙连接外围（下）.md","raw":"title: iOS 作为Central蓝牙连接外围（下）\ndate: 2016-05-29 20:48:00\ncategories: coder\ntags: [iOS, bluetooth]\n-----------\n\nSummary: 仍然是公司蓝牙卡项目，搞了两周，现在大致搞定，作一个总结；首先要把上篇遗留下来的蓝牙外围设备写数据等问题解决下...\n<!-- more -->\n\n\n## 解决蓝牙写数据等问题\n### 更正读数据的一个问题\n\n更正一个问题，就是读数据时notify和read的两个回调，本人实测回调notification只是在之后回调一次，而不论读数据采用以上哪种，updataValue方法总是会执行，而且有时还不只是一次；\n\n\n总结：\n\n1.read方法时，回调updataValue；nofify时，notification回调一次后，updataValue再开始调，且不只一次；\n\n2.接收 characteristic 数据的方式有两种：\n\n在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。\n用 setNotifyValue:forCharacteristic: 方法订阅，当有数据发送时，可以直接在回调中接收。\n\n### 向 characteristic 写数据\n\n写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。\n\n```\n[peripheral writeValue:dataToWrite forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];\n```\n\n上面的那个type参数是表示是否需要在写入后进行回调，这里的意思是需要回调，那么将在下面这个函数回调:\n\n```\n- (void)peripheral:(CBPeripheral *)peripheral\ndidWriteValueForCharacteristic:(CBCharacteristic *)characteristic\n             error:(NSError *)error {\n \n    if (error) {\n        NSLog(@\"Error writing characteristic value: %@\", [error localizedDescription]);\n    }\n}\n```\n\n### 读写补充\n\n在不用和 peripheral 通信的时候，应当将连接断开，这也对节能有好处。在以下两种情况下，连接应该被断开：\n\n当 characteristic 不再发送数据时。（可以通过 isNotifying 属性来判断）\n你已经接收到了你所需要的所有数据时。\n以上两种情况，都需要先结束订阅，然后断开连接。\n\n```\n[peripheral setNotifyValue:NO forCharacteristic:characteristic];\n[myCentralManager cancelPeripheralConnection:peripheral];\n```\n\n**cancelPeripheralConnection:** 是非阻塞性的，如果在 peripheral 挂起的状态去尝试断开连接，那么这个断开操作可能执行，也可能不会。因为可能还有其他的 central 连着它，所以取消连接并不代表底层连接也断开。从 app 的层面来讲，在 peripheral 决定断开的时候，会调用 **CBCentralManagerDelegate**  的 **centralManager:didDisconnectPeripheral:error:** 方法。\n\n另外关于蓝牙重连等的相关东西，这里就不一一说了，有兴趣的还是到本文参考文章中去找答案吧！再次感谢广大的代码工作者们！\n\n------------------------------------\n\n# 项目总结\n## 关于结构方面的\n\n这一点呢是个人习惯的问题，我们一般在工作中会接手到一些别人做了一半的任务，只有部分功能被实现的很好，那么这时就需要大量改动代码了。个人的建议是，不要在原来的模块中做修改，而是添加一个中间层，新实现的功能封装在新的类中，等到所有功能全部实现，再进行项目整合，因为这个时候对项目基本上能算作是了解，重构的时候也相对容易些。\n\n第二点是关于iOS block与delegate选择上的意见，上面一点中说的中间层最好选用block，因为在逻辑上真的是很好理解，而且不容易出错，少写很多代码；而代理的话适合暴露出去，被其他人使用，这样调用你代码的人会在结构上相对好把握，自由度要大些。\n\nPS:既然说到了block，我们补充一点，如果你想让自己的block失效，ARC下只要让他的指针置空就可以了，当然如果你只是对它进行了第二次赋值，那么之前指针所指向的block块是没有被失效的。\n\n## 说说写代码的一些\n\n1.就像本项目中用到的蓝牙，这些都是不需要在主线程中做的事情，诸如此类的相关还有网络连接，喇叭，话筒等（），将它们扔在后台线程中，任务完成之后回到主线程中修改UI;\n\n2.一些超时操作，我们需要的把它也扔在后台线程中，你可以用:\n\n```\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            _scanTimer = [NSTimer scheduledTimerWithTimeInterval:seconds target:self selector:@selector(scanTimeoutHandler:) userInfo:nil repeats:NO];\n            });\n\n```\n也可以这样：\n\n\n```\n[self performSelector:@selector(scanTimeoutHandler:) withObject:nil afterDelay:seconds inModes:@[NSDefaultRunLoopMode]];\n```\n或者直接把它加到你的一个runloop中：\n\n```\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n否则它一直占用着当前的线程会给你带来很大的困扰；\n\n3.NSStream Socket网络编程\n\nNSStream很简单，用到的东西并不是很多就可以做一个简单的socket；NSStreamDelegate,NSInputStream,NSOutStream，一个代理和两个对象，连接的时候像这样：\n\n\n```\n- (void)connectToHostUseStreamWithIP:(NSString *)host port:(int)port data:(NSData *)data{\n    // 1.建立连接\n    // 定义C语言输入输出流\n    CFReadStreamRef readStream;\n    CFWriteStreamRef writeStream;\n    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &readStream, &writeStream);\n    \n    // 把C语言的输入输出流转化成OC对象\n    _inputStream = (__bridge NSInputStream *)(readStream);\n    _outputStream = (__bridge NSOutputStream *)(writeStream);\n    \n    // 设置代理\n    _inputStream.delegate = self;\n    _outputStream.delegate = self;\n    \n    // 把输入输入流添加到运行循环\n    [_inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    [_outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    \n    // 打开输入输出流\n    [_inputStream open];\n    [_outputStream open];\n    \n    //发送数据\n    [[NSRunLoop currentRunLoop] run];\n}\n```\n\n断开时候：\n\n```\n- (void)stopConnect{\n    // 从运行循环移除\n    [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    // 关闭输入输出流\n    [_inputStream close];\n    [_outputStream close];\n    \n    _inputStream = nil;\n    _outputStream = nil;\n    \n    NSLog(@\"Socket 连接已断开！\");\n}\n```\n代理只有一个回调函数，你所有的事情全部需要在这里面解决；\n\n```\n-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode{\n    NSLog(@\"%@\",[NSThread currentThread]);\n    //    NSStreamEventOpenCompleted = 1UL << 0,//输入输出流打开完成\n    //    NSStreamEventHasBytesAvailable = 1UL << 1,//有字节可读\n    //    NSStreamEventHasSpaceAvailable = 1UL << 2,//可以发放字节\n    //    NSStreamEventErrorOccurred = 1UL << 3,// 连接出现错误\n    //    NSStreamEventEndEncountered = 1UL << 4// 连接结束\n    \n    switch (eventCode) {\n        case NSStreamEventOpenCompleted:\n                NSLog(@\"输入输出流打开完成\");\n                break;\n        case NSStreamEventHasBytesAvailable:\n                NSLog(@\"有字节可读\");\n                [self readDataFromSocket];\n                break;\n        case NSStreamEventHasSpaceAvailable:\n                NSLog(@\"可以发送字节\");\n            [self sendDataToSocket];\n                break;\n        case NSStreamEventErrorOccurred:\n                NSLog(@\"连接出现错误\");\n                break;\n        case NSStreamEventEndEncountered:\n                NSLog(@\"连接结束\");\n     \n     \n        // 从运行循环移除\n        [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n        [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n            \n            \n        // 关闭输入输出流\n        [_inputStream close];\n        [_outputStream close];\n                break;\n        default:\n                break;\n     }\n}\n```\n\n记住，一定是自己单独开一个线程，socket会一直占用着线程，如果你不把它自己关掉，那么它会无休止的连接着，你无法做一些其他的事情，所以，这一点很重要；\n\n另外，用完一定要关掉它，一定，一定，重要的事情多说几遍；\n\n4.状态机\n\n我们在项目中有时会遇到一些状态值，一般情况下枚举将会是个好选择，然而当你遇到的状态是多选择的就显得不那么好用了；于是本项目中我用到的option会是一个好的点子；我们先上代码，然后来解释；\n\n```\ntypedef NS_OPTIONS(NSUInteger,CardOperationState) {\n    CardOperationState_idle = 0,\n    \n    CardOperationState_ReadCorrect = 1 << 0, //读卡成功 1\n    CardOperationState_ReadWrong = 1 << 1,   //读卡失败 2\n    \n    CardOperationState_Checkouted = 1 << 2,      //已校验密码 4\n    CardOperationState_Written = 1 << 3,         //数据已写入成功 8\n    CardOperationState_ChangedPass = 1 << 4,     //已修改密码\n};\n\n```\n\n举个例子，如果你要表示的状态是已校验，已写入，已修改，那你的这个状态应该是:\n\n\n```\nstate == CardOperationState_Checkouted | CardOperationState_Written| CardOperationState_ChangedPass\n```\n用枚举的话那要用好几个判断:\n\n\n```\nstate == CardOperationState_Checkouted && state == CardOperationState_Written && state == CardOperationState_ChangedPass \n```\n很明显，option少写了很多判断；\n\n当前状态添加一个状态：\n\n```\ncurrentState = currentState | CardOperationState_Checkouted;//增加已校验状态\n```\n减少一个状态：\n\n```\ncurrentState = currentState & (~CardOperationState_ReadCorrect);\n```\n\n判断是否包含一个状态:\n\n```\ncurrentState & CardOperationState_Checkouted\n```\n\n\n","slug":"iOS 作为Central蓝牙连接外围（下）","published":1,"updated":"2018-05-04T10:26:12.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciog001e1v60cz6qvowt","content":"<p>Summary: 仍然是公司蓝牙卡项目，搞了两周，现在大致搞定，作一个总结；首先要把上篇遗留下来的蓝牙外围设备写数据等问题解决下…<br><a id=\"more\"></a></p>\n<h2 id=\"解决蓝牙写数据等问题\"><a href=\"#解决蓝牙写数据等问题\" class=\"headerlink\" title=\"解决蓝牙写数据等问题\"></a>解决蓝牙写数据等问题</h2><h3 id=\"更正读数据的一个问题\"><a href=\"#更正读数据的一个问题\" class=\"headerlink\" title=\"更正读数据的一个问题\"></a>更正读数据的一个问题</h3><p>更正一个问题，就是读数据时notify和read的两个回调，本人实测回调notification只是在之后回调一次，而不论读数据采用以上哪种，updataValue方法总是会执行，而且有时还不只是一次；</p>\n<p>总结：</p>\n<p>1.read方法时，回调updataValue；nofify时，notification回调一次后，updataValue再开始调，且不只一次；</p>\n<p>2.接收 characteristic 数据的方式有两种：</p>\n<p>在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。<br>用 setNotifyValue:forCharacteristic: 方法订阅，当有数据发送时，可以直接在回调中接收。</p>\n<h3 id=\"向-characteristic-写数据\"><a href=\"#向-characteristic-写数据\" class=\"headerlink\" title=\"向 characteristic 写数据\"></a>向 characteristic 写数据</h3><p>写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral writeValue:dataToWrite forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];</span><br></pre></td></tr></table></figure>\n<p>上面的那个type参数是表示是否需要在写入后进行回调，这里的意思是需要回调，那么将在下面这个函数回调:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral</span><br><span class=\"line\">didWriteValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class=\"line\">             error:(NSError *)error &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Error writing characteristic value: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"读写补充\"><a href=\"#读写补充\" class=\"headerlink\" title=\"读写补充\"></a>读写补充</h3><p>在不用和 peripheral 通信的时候，应当将连接断开，这也对节能有好处。在以下两种情况下，连接应该被断开：</p>\n<p>当 characteristic 不再发送数据时。（可以通过 isNotifying 属性来判断）<br>你已经接收到了你所需要的所有数据时。<br>以上两种情况，都需要先结束订阅，然后断开连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral setNotifyValue:NO forCharacteristic:characteristic];</span><br><span class=\"line\">[myCentralManager cancelPeripheralConnection:peripheral];</span><br></pre></td></tr></table></figure>\n<p><strong>cancelPeripheralConnection:</strong> 是非阻塞性的，如果在 peripheral 挂起的状态去尝试断开连接，那么这个断开操作可能执行，也可能不会。因为可能还有其他的 central 连着它，所以取消连接并不代表底层连接也断开。从 app 的层面来讲，在 peripheral 决定断开的时候，会调用 <strong>CBCentralManagerDelegate</strong>  的 <strong>centralManager:didDisconnectPeripheral:error:</strong> 方法。</p>\n<p>另外关于蓝牙重连等的相关东西，这里就不一一说了，有兴趣的还是到本文参考文章中去找答案吧！再次感谢广大的代码工作者们！</p>\n<hr>\n<h1 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h1><h2 id=\"关于结构方面的\"><a href=\"#关于结构方面的\" class=\"headerlink\" title=\"关于结构方面的\"></a>关于结构方面的</h2><p>这一点呢是个人习惯的问题，我们一般在工作中会接手到一些别人做了一半的任务，只有部分功能被实现的很好，那么这时就需要大量改动代码了。个人的建议是，不要在原来的模块中做修改，而是添加一个中间层，新实现的功能封装在新的类中，等到所有功能全部实现，再进行项目整合，因为这个时候对项目基本上能算作是了解，重构的时候也相对容易些。</p>\n<p>第二点是关于iOS block与delegate选择上的意见，上面一点中说的中间层最好选用block，因为在逻辑上真的是很好理解，而且不容易出错，少写很多代码；而代理的话适合暴露出去，被其他人使用，这样调用你代码的人会在结构上相对好把握，自由度要大些。</p>\n<p>PS:既然说到了block，我们补充一点，如果你想让自己的block失效，ARC下只要让他的指针置空就可以了，当然如果你只是对它进行了第二次赋值，那么之前指针所指向的block块是没有被失效的。</p>\n<h2 id=\"说说写代码的一些\"><a href=\"#说说写代码的一些\" class=\"headerlink\" title=\"说说写代码的一些\"></a>说说写代码的一些</h2><p>1.就像本项目中用到的蓝牙，这些都是不需要在主线程中做的事情，诸如此类的相关还有网络连接，喇叭，话筒等（），将它们扔在后台线程中，任务完成之后回到主线程中修改UI;</p>\n<p>2.一些超时操作，我们需要的把它也扔在后台线程中，你可以用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">            _scanTimer = [NSTimer scheduledTimerWithTimeInterval:seconds target:self selector:@selector(scanTimeoutHandler:) userInfo:nil repeats:NO];</span><br><span class=\"line\">            &#125;);</span><br></pre></td></tr></table></figure>\n<p>也可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self performSelector:@selector(scanTimeoutHandler:) withObject:nil afterDelay:seconds inModes:@[NSDefaultRunLoopMode]];</span><br></pre></td></tr></table></figure>\n<p>或者直接把它加到你的一个runloop中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>\n<p>否则它一直占用着当前的线程会给你带来很大的困扰；</p>\n<p>3.NSStream Socket网络编程</p>\n<p>NSStream很简单，用到的东西并不是很多就可以做一个简单的socket；NSStreamDelegate,NSInputStream,NSOutStream，一个代理和两个对象，连接的时候像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)connectToHostUseStreamWithIP:(NSString *)host port:(int)port data:(NSData *)data&#123;</span><br><span class=\"line\">    // 1.建立连接</span><br><span class=\"line\">    // 定义C语言输入输出流</span><br><span class=\"line\">    CFReadStreamRef readStream;</span><br><span class=\"line\">    CFWriteStreamRef writeStream;</span><br><span class=\"line\">    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 把C语言的输入输出流转化成OC对象</span><br><span class=\"line\">    _inputStream = (__bridge NSInputStream *)(readStream);</span><br><span class=\"line\">    _outputStream = (__bridge NSOutputStream *)(writeStream);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置代理</span><br><span class=\"line\">    _inputStream.delegate = self;</span><br><span class=\"line\">    _outputStream.delegate = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 把输入输入流添加到运行循环</span><br><span class=\"line\">    [_inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    [_outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 打开输入输出流</span><br><span class=\"line\">    [_inputStream open];</span><br><span class=\"line\">    [_outputStream open];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //发送数据</span><br><span class=\"line\">    [[NSRunLoop currentRunLoop] run];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>断开时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)stopConnect&#123;</span><br><span class=\"line\">    // 从运行循环移除</span><br><span class=\"line\">    [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    // 关闭输入输出流</span><br><span class=\"line\">    [_inputStream close];</span><br><span class=\"line\">    [_outputStream close];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _inputStream = nil;</span><br><span class=\"line\">    _outputStream = nil;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;Socket 连接已断开！&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代理只有一个回调函数，你所有的事情全部需要在这里面解决；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    //    NSStreamEventOpenCompleted = 1UL &lt;&lt; 0,//输入输出流打开完成</span><br><span class=\"line\">    //    NSStreamEventHasBytesAvailable = 1UL &lt;&lt; 1,//有字节可读</span><br><span class=\"line\">    //    NSStreamEventHasSpaceAvailable = 1UL &lt;&lt; 2,//可以发放字节</span><br><span class=\"line\">    //    NSStreamEventErrorOccurred = 1UL &lt;&lt; 3,// 连接出现错误</span><br><span class=\"line\">    //    NSStreamEventEndEncountered = 1UL &lt;&lt; 4// 连接结束</span><br><span class=\"line\">    </span><br><span class=\"line\">    switch (eventCode) &#123;</span><br><span class=\"line\">        case NSStreamEventOpenCompleted:</span><br><span class=\"line\">                NSLog(@&quot;输入输出流打开完成&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventHasBytesAvailable:</span><br><span class=\"line\">                NSLog(@&quot;有字节可读&quot;);</span><br><span class=\"line\">                [self readDataFromSocket];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventHasSpaceAvailable:</span><br><span class=\"line\">                NSLog(@&quot;可以发送字节&quot;);</span><br><span class=\"line\">            [self sendDataToSocket];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventErrorOccurred:</span><br><span class=\"line\">                NSLog(@&quot;连接出现错误&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventEndEncountered:</span><br><span class=\"line\">                NSLog(@&quot;连接结束&quot;);</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">        // 从运行循环移除</span><br><span class=\"line\">        [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">        [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">        // 关闭输入输出流</span><br><span class=\"line\">        [_inputStream close];</span><br><span class=\"line\">        [_outputStream close];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">                break;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记住，一定是自己单独开一个线程，socket会一直占用着线程，如果你不把它自己关掉，那么它会无休止的连接着，你无法做一些其他的事情，所以，这一点很重要；</p>\n<p>另外，用完一定要关掉它，一定，一定，重要的事情多说几遍；</p>\n<p>4.状态机</p>\n<p>我们在项目中有时会遇到一些状态值，一般情况下枚举将会是个好选择，然而当你遇到的状态是多选择的就显得不那么好用了；于是本项目中我用到的option会是一个好的点子；我们先上代码，然后来解释；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger,CardOperationState) &#123;</span><br><span class=\"line\">    CardOperationState_idle = 0,</span><br><span class=\"line\">    </span><br><span class=\"line\">    CardOperationState_ReadCorrect = 1 &lt;&lt; 0, //读卡成功 1</span><br><span class=\"line\">    CardOperationState_ReadWrong = 1 &lt;&lt; 1,   //读卡失败 2</span><br><span class=\"line\">    </span><br><span class=\"line\">    CardOperationState_Checkouted = 1 &lt;&lt; 2,      //已校验密码 4</span><br><span class=\"line\">    CardOperationState_Written = 1 &lt;&lt; 3,         //数据已写入成功 8</span><br><span class=\"line\">    CardOperationState_ChangedPass = 1 &lt;&lt; 4,     //已修改密码</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>举个例子，如果你要表示的状态是已校验，已写入，已修改，那你的这个状态应该是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state == CardOperationState_Checkouted | CardOperationState_Written| CardOperationState_ChangedPass</span><br></pre></td></tr></table></figure>\n<p>用枚举的话那要用好几个判断:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state == CardOperationState_Checkouted &amp;&amp; state == CardOperationState_Written &amp;&amp; state == CardOperationState_ChangedPass</span><br></pre></td></tr></table></figure>\n<p>很明显，option少写了很多判断；</p>\n<p>当前状态添加一个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentState = currentState | CardOperationState_Checkouted;//增加已校验状态</span><br></pre></td></tr></table></figure>\n<p>减少一个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentState = currentState &amp; (~CardOperationState_ReadCorrect);</span><br></pre></td></tr></table></figure>\n<p>判断是否包含一个状态:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentState &amp; CardOperationState_Checkouted</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Summary: 仍然是公司蓝牙卡项目，搞了两周，现在大致搞定，作一个总结；首先要把上篇遗留下来的蓝牙外围设备写数据等问题解决下…<br>","more":"</p>\n<h2 id=\"解决蓝牙写数据等问题\"><a href=\"#解决蓝牙写数据等问题\" class=\"headerlink\" title=\"解决蓝牙写数据等问题\"></a>解决蓝牙写数据等问题</h2><h3 id=\"更正读数据的一个问题\"><a href=\"#更正读数据的一个问题\" class=\"headerlink\" title=\"更正读数据的一个问题\"></a>更正读数据的一个问题</h3><p>更正一个问题，就是读数据时notify和read的两个回调，本人实测回调notification只是在之后回调一次，而不论读数据采用以上哪种，updataValue方法总是会执行，而且有时还不只是一次；</p>\n<p>总结：</p>\n<p>1.read方法时，回调updataValue；nofify时，notification回调一次后，updataValue再开始调，且不只一次；</p>\n<p>2.接收 characteristic 数据的方式有两种：</p>\n<p>在需要接收数据的时候，调用 readValueForCharacteristic:，这种是需要主动去接收的。<br>用 setNotifyValue:forCharacteristic: 方法订阅，当有数据发送时，可以直接在回调中接收。</p>\n<h3 id=\"向-characteristic-写数据\"><a href=\"#向-characteristic-写数据\" class=\"headerlink\" title=\"向 characteristic 写数据\"></a>向 characteristic 写数据</h3><p>写数据其实是一个很常见的需求，如果 characteristic 可写，你可以通过CBPeripheral类的writeValue:forCharacteristic:type:方法来向设备写入NSData数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral writeValue:dataToWrite forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];</span><br></pre></td></tr></table></figure>\n<p>上面的那个type参数是表示是否需要在写入后进行回调，这里的意思是需要回调，那么将在下面这个函数回调:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral</span><br><span class=\"line\">didWriteValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class=\"line\">             error:(NSError *)error &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Error writing characteristic value: %@&quot;, [error localizedDescription]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"读写补充\"><a href=\"#读写补充\" class=\"headerlink\" title=\"读写补充\"></a>读写补充</h3><p>在不用和 peripheral 通信的时候，应当将连接断开，这也对节能有好处。在以下两种情况下，连接应该被断开：</p>\n<p>当 characteristic 不再发送数据时。（可以通过 isNotifying 属性来判断）<br>你已经接收到了你所需要的所有数据时。<br>以上两种情况，都需要先结束订阅，然后断开连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[peripheral setNotifyValue:NO forCharacteristic:characteristic];</span><br><span class=\"line\">[myCentralManager cancelPeripheralConnection:peripheral];</span><br></pre></td></tr></table></figure>\n<p><strong>cancelPeripheralConnection:</strong> 是非阻塞性的，如果在 peripheral 挂起的状态去尝试断开连接，那么这个断开操作可能执行，也可能不会。因为可能还有其他的 central 连着它，所以取消连接并不代表底层连接也断开。从 app 的层面来讲，在 peripheral 决定断开的时候，会调用 <strong>CBCentralManagerDelegate</strong>  的 <strong>centralManager:didDisconnectPeripheral:error:</strong> 方法。</p>\n<p>另外关于蓝牙重连等的相关东西，这里就不一一说了，有兴趣的还是到本文参考文章中去找答案吧！再次感谢广大的代码工作者们！</p>\n<hr>\n<h1 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h1><h2 id=\"关于结构方面的\"><a href=\"#关于结构方面的\" class=\"headerlink\" title=\"关于结构方面的\"></a>关于结构方面的</h2><p>这一点呢是个人习惯的问题，我们一般在工作中会接手到一些别人做了一半的任务，只有部分功能被实现的很好，那么这时就需要大量改动代码了。个人的建议是，不要在原来的模块中做修改，而是添加一个中间层，新实现的功能封装在新的类中，等到所有功能全部实现，再进行项目整合，因为这个时候对项目基本上能算作是了解，重构的时候也相对容易些。</p>\n<p>第二点是关于iOS block与delegate选择上的意见，上面一点中说的中间层最好选用block，因为在逻辑上真的是很好理解，而且不容易出错，少写很多代码；而代理的话适合暴露出去，被其他人使用，这样调用你代码的人会在结构上相对好把握，自由度要大些。</p>\n<p>PS:既然说到了block，我们补充一点，如果你想让自己的block失效，ARC下只要让他的指针置空就可以了，当然如果你只是对它进行了第二次赋值，那么之前指针所指向的block块是没有被失效的。</p>\n<h2 id=\"说说写代码的一些\"><a href=\"#说说写代码的一些\" class=\"headerlink\" title=\"说说写代码的一些\"></a>说说写代码的一些</h2><p>1.就像本项目中用到的蓝牙，这些都是不需要在主线程中做的事情，诸如此类的相关还有网络连接，喇叭，话筒等（），将它们扔在后台线程中，任务完成之后回到主线程中修改UI;</p>\n<p>2.一些超时操作，我们需要的把它也扔在后台线程中，你可以用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">            _scanTimer = [NSTimer scheduledTimerWithTimeInterval:seconds target:self selector:@selector(scanTimeoutHandler:) userInfo:nil repeats:NO];</span><br><span class=\"line\">            &#125;);</span><br></pre></td></tr></table></figure>\n<p>也可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self performSelector:@selector(scanTimeoutHandler:) withObject:nil afterDelay:seconds inModes:@[NSDefaultRunLoopMode]];</span><br></pre></td></tr></table></figure>\n<p>或者直接把它加到你的一个runloop中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>\n<p>否则它一直占用着当前的线程会给你带来很大的困扰；</p>\n<p>3.NSStream Socket网络编程</p>\n<p>NSStream很简单，用到的东西并不是很多就可以做一个简单的socket；NSStreamDelegate,NSInputStream,NSOutStream，一个代理和两个对象，连接的时候像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)connectToHostUseStreamWithIP:(NSString *)host port:(int)port data:(NSData *)data&#123;</span><br><span class=\"line\">    // 1.建立连接</span><br><span class=\"line\">    // 定义C语言输入输出流</span><br><span class=\"line\">    CFReadStreamRef readStream;</span><br><span class=\"line\">    CFWriteStreamRef writeStream;</span><br><span class=\"line\">    CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 把C语言的输入输出流转化成OC对象</span><br><span class=\"line\">    _inputStream = (__bridge NSInputStream *)(readStream);</span><br><span class=\"line\">    _outputStream = (__bridge NSOutputStream *)(writeStream);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 设置代理</span><br><span class=\"line\">    _inputStream.delegate = self;</span><br><span class=\"line\">    _outputStream.delegate = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 把输入输入流添加到运行循环</span><br><span class=\"line\">    [_inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    [_outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 打开输入输出流</span><br><span class=\"line\">    [_inputStream open];</span><br><span class=\"line\">    [_outputStream open];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //发送数据</span><br><span class=\"line\">    [[NSRunLoop currentRunLoop] run];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>断开时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)stopConnect&#123;</span><br><span class=\"line\">    // 从运行循环移除</span><br><span class=\"line\">    [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">    // 关闭输入输出流</span><br><span class=\"line\">    [_inputStream close];</span><br><span class=\"line\">    [_outputStream close];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _inputStream = nil;</span><br><span class=\"line\">    _outputStream = nil;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;Socket 连接已断开！&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代理只有一个回调函数，你所有的事情全部需要在这里面解决；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    //    NSStreamEventOpenCompleted = 1UL &lt;&lt; 0,//输入输出流打开完成</span><br><span class=\"line\">    //    NSStreamEventHasBytesAvailable = 1UL &lt;&lt; 1,//有字节可读</span><br><span class=\"line\">    //    NSStreamEventHasSpaceAvailable = 1UL &lt;&lt; 2,//可以发放字节</span><br><span class=\"line\">    //    NSStreamEventErrorOccurred = 1UL &lt;&lt; 3,// 连接出现错误</span><br><span class=\"line\">    //    NSStreamEventEndEncountered = 1UL &lt;&lt; 4// 连接结束</span><br><span class=\"line\">    </span><br><span class=\"line\">    switch (eventCode) &#123;</span><br><span class=\"line\">        case NSStreamEventOpenCompleted:</span><br><span class=\"line\">                NSLog(@&quot;输入输出流打开完成&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventHasBytesAvailable:</span><br><span class=\"line\">                NSLog(@&quot;有字节可读&quot;);</span><br><span class=\"line\">                [self readDataFromSocket];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventHasSpaceAvailable:</span><br><span class=\"line\">                NSLog(@&quot;可以发送字节&quot;);</span><br><span class=\"line\">            [self sendDataToSocket];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventErrorOccurred:</span><br><span class=\"line\">                NSLog(@&quot;连接出现错误&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        case NSStreamEventEndEncountered:</span><br><span class=\"line\">                NSLog(@&quot;连接结束&quot;);</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">        // 从运行循环移除</span><br><span class=\"line\">        [_inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">        [_outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">        // 关闭输入输出流</span><br><span class=\"line\">        [_inputStream close];</span><br><span class=\"line\">        [_outputStream close];</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">                break;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记住，一定是自己单独开一个线程，socket会一直占用着线程，如果你不把它自己关掉，那么它会无休止的连接着，你无法做一些其他的事情，所以，这一点很重要；</p>\n<p>另外，用完一定要关掉它，一定，一定，重要的事情多说几遍；</p>\n<p>4.状态机</p>\n<p>我们在项目中有时会遇到一些状态值，一般情况下枚举将会是个好选择，然而当你遇到的状态是多选择的就显得不那么好用了；于是本项目中我用到的option会是一个好的点子；我们先上代码，然后来解释；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger,CardOperationState) &#123;</span><br><span class=\"line\">    CardOperationState_idle = 0,</span><br><span class=\"line\">    </span><br><span class=\"line\">    CardOperationState_ReadCorrect = 1 &lt;&lt; 0, //读卡成功 1</span><br><span class=\"line\">    CardOperationState_ReadWrong = 1 &lt;&lt; 1,   //读卡失败 2</span><br><span class=\"line\">    </span><br><span class=\"line\">    CardOperationState_Checkouted = 1 &lt;&lt; 2,      //已校验密码 4</span><br><span class=\"line\">    CardOperationState_Written = 1 &lt;&lt; 3,         //数据已写入成功 8</span><br><span class=\"line\">    CardOperationState_ChangedPass = 1 &lt;&lt; 4,     //已修改密码</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>举个例子，如果你要表示的状态是已校验，已写入，已修改，那你的这个状态应该是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state == CardOperationState_Checkouted | CardOperationState_Written| CardOperationState_ChangedPass</span><br></pre></td></tr></table></figure>\n<p>用枚举的话那要用好几个判断:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state == CardOperationState_Checkouted &amp;&amp; state == CardOperationState_Written &amp;&amp; state == CardOperationState_ChangedPass</span><br></pre></td></tr></table></figure>\n<p>很明显，option少写了很多判断；</p>\n<p>当前状态添加一个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentState = currentState | CardOperationState_Checkouted;//增加已校验状态</span><br></pre></td></tr></table></figure>\n<p>减少一个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentState = currentState &amp; (~CardOperationState_ReadCorrect);</span><br></pre></td></tr></table></figure>\n<p>判断是否包含一个状态:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentState &amp; CardOperationState_Checkouted</span><br></pre></td></tr></table></figure>"},{"title":"World of WarCarft插件的构成","date":"2016-08-25T03:21:00.000Z","_content":"\n今天来说一说wow插件是个什么鬼？\n<!-- more -->\n\n插件是魔兽世界开放的第三个接口，有朋友会问，什么是第三方？这个是软件业的一个术语，简单的说，就是游戏当中能让我们自己来定制DIY的部分，比方说对话界面，还有一些数据显示之类的功能。\n\nwow的插件全部保存在*World of Warcraft/Interface/AddOns*目录下，在这个目录下会有一些暴雪自带的功能插件，它们均是以*Blizzard_*开头的，我们自己做的插件可以随意命名，不同插件可以分别放在不同的文件夹下面（我们在做插件的过程中，强烈建议用英文命名，避免因为中文导致插件无法被识别的问题）。[http://www.townlong-yak.com/framexml/](http://www.townlong-yak.com/framexml/)这个网址可以下载暴雪自带插件。\n\n说一下插件的构成，打开插件目录，你会发现大致会有三种类型文件，分别是toc文件，xml文件和lua文件。\n\n## toc文件\n\n这个文件是一个必要文件，它的名字与你的插件文件夹名字同名，只不过带了一个后缀toc，如果不同名的话，打开魔兽客户端将会无法识别你的插件；\n\n注意！！！这个文件的每行开头不能有空格，每行仅作一个说明。\n\n用文本工具打开toc文件，内容说明分三种类型：\n\n### 以##开头的数据\n\n用来进行插件描述，一般会有插件名称，作者名称，功能描述等；它的基本格式是\n\n```\n## 标签名：标签值\n```\n\n标签的名字可以随便写，但是有一些wow自带的标签名我们进行一下解释：\n\n```\nInterface:标记插件可用在的wow游戏版本，当该值小于低于当前游戏版本插件不会被加载；\nTitle:插件名称，这个会被显示在游戏选择人物的插件列表里；\nTitle-zhCN:插件的中文显示，如果想要在其他语言中显示，则修改-后面的就可以了；下面的Notes也是如此；\nNotes:插件列表中，鼠标移到插件名上时显示的信息；\nRequiredDeps, Dependencies, 或者任意以 \"Dep\" 开始的字符串：表示我们当前的插件必须需要加载的其他插件；\nOptionalDeps:与上面的对照，这里的插件是可选的；\nLoadOnDemand:值为1时，表示这个插件不会在游戏开始就加载，而是在需要的时候才加载；\nLoadWith:如果上面的值为1时，本条所描述的插件会随着本插件一起加载；\nLoadManagers:本条中所描述的插件如果都不存在的话，则会自动加载本插件；如果有一个存在，则按LoadOnDemand值为1处理；\nSavedVariables:一些以逗号分割的变量名称，这些变量会被保存在硬盘上，下次加载时可以被读取到；\nSavedVariablesPerCharacter:与上面的标签是相同的作用，不过该标签只用于保存不同角色的不同配置；\nDefaultState:本插件默认开启状态，值为disabled/enabled；\nAuthor:作者名字\nVersion:插件的版本号\n\n```\n\n另外你可以定义自己的标签，以上中最重要的就是前两个，尽量不要出错；\n\n### 本插件需要加载的代码文件\n\n列出需要加载的代码类文件，只支持lua和xml两种格式，这里的文件需要给出以当前目录为根目录的文件完整路径，就是说如果你插件目录下有一个`myaddon.lua`的文件则需要添加：\n\n```\nmyaddon.lua\n```\n而如果你插件目录下有一个子文件夹*MyAddon*，而该目录下有一个`myaddon2.lua`的话，则需要添加：\n\n```\nMyAddon/myaddon2.lua\n```\n\n### 以#开头的文件\n\n这些是注释文本，在toc中可以随便添加，主要用作插件制作者自己记录，这些不会被插件加载；\n\n\n## XML文件\n\nxml文件主要用于插件的界面制作，以及事件绑定，事件绑定通俗的讲就是你对插件做某些操作（按一个按钮之类的）游戏中会出现的事件，这些事件会以一个方法的形式出现在lua文件中，你可以把你自己想做的事情写在这个方法中，如果你学过些编程，应该知道我们这里说的方法就是lua函数；\n\n在你插件的根目录下会有一个叫做**Bindings.xml**的文件，这个文件会被游戏客户端自动读取，不必写在toc文件中；\n\n我们来看一个该文件的例子：\n\n```\n<Bindings> \n    <Binding name=\"CUBE_CODE\" header=\"CUBE\"> \n      if IGAS.UIParent.Cube_Main then \n         IGAS.UIParent.Cube_Main.Visible = not IGAS.UIParent.Cube_Main.Visible \n      end \n    </Binding> \n    <Binding name=\"CUBE_DEBUG\"> \n      if IGAS.UIParent.Cube_Debug then \n         IGAS.UIParent.Cube_Debug.Visible = not IGAS.UIParent.Cube_Debug.Visible \n      end \n    </Binding> \n</Bindings>\n```\n\n\n我们暂时先不要管这些代码的意思，只需要知道这个文件设置了界面元素与游戏事件的绑定，而绑定的事件是由Lua文件完成的；**Bindings.xml**文件绑定了一个与插件名同名的lua文件，并且还将界面上的元素与该文件所描述的事件绑定在了一起：\n\n```\n-- Binding Text \n_G.BINDING_HEADER_CUBE = L[\"Cube\"] \n_G.BINDING_NAME_CUBE_CODE = L[\"Simple Dev Tool\"] \n_G.BINDING_NAME_CUBE_DEBUG = L[\"Simple Debug Tool\"]\n\n```\n\n我们现在先不要管他们是怎么联系起来的，具体我们在之后的写代码过程中会慢慢讲到，现在只要理解一点，xml会定义我们的界面，并且还可以设置界面元素与事件的绑定，而绑定的事件会交由lua文件处理；\n\n我们还可以加载其他的xml和lua文件，如下例：\n\n```\n<Ui xmlns=\"http://www.blizzard.com/wow/ui/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.blizzard.com/wow/ui/..\\FrameXML\\UI.xsd\"> \n   <!-- Init --> \n   <Script file = \"IGAS_Toolkit.lua\"/> \n\n   <!-- Modules --> \n   <Include file = \"Modules\\AutoRepair\\AutoRepair.xml\"/> \n   <Include file = \"Modules\\AutoSell\\AutoSell.xml\"/> \n</Ui>\n```\n\n其中**<** **/>**这间的就是xml文件的标签，标签的类型会由**<**后面的名称标识，如上`Script`这个标签用于加载lua文件，而`Include`用于加载其他的xml文件；\n\n## lua文件\n\nLua是wow插件逻辑的主要语言，做插件前需要先熟悉一下lua的语法，感兴趣的不防去知乎下搜索一些学习的建议，找一些入门的资料，在我的公众号给我留言，我们可以一起学习探讨下；这里我们给一些简短的片断，目的是了解一下它的作用；\n\n假设我们现在做一个插件，名为DHAddon（想想DH是不是恶魔猎手的缩写呀？Devil Hunter?），插件里有两个Lua文件devil.lua hunter.lua;\n\nwow加载它们的方式，类似下面的代码：\n\n```\n-- Load DHAddon \nlocal DHAddon = {} \n\nf = loadfile(\"devil.lua\") \nf( \"DHAddon\", DHAddon ) \n\nf = loadfile(\"hunter.lua\") \nf( \"DHAddon\", DHAddon )\n```\n\nloadfile就是加载文件，文件名称用字符串表示（lua语法“”表示字符串）；加载的结果保存在f中；\n\ndevil.lua:\n\n```\nlocal addonName, addon = ... \n\nprint(addonName .. \" is loaded.\") \n\naddon.DHAddon = 123\n\n```\n\nhunter.lua:\n\n```\nlocal addonName, addon = ... \n\nprint( \"DHAddon is \" .. addon.DHAddon )\n```\n\n不出意外的话，运行结果会是：\n\nDHAddon is loaded.\nDHAddon is 123\n\n另外上面的两个lua文件也可以下面这么写，其中有好多lua的内容，暂不解释原因，贴在这里之后了解到了再来回顾：\n\n```\n-- 插件第一个Lua文件使用，这行代码确保以下的代码以addon为环境，而不是以_G为环境， \n-- 并且在addon环境中可以访问_G的任意变量，访问的变量值也将存储到addon中，便于下次直接访问 \n-- 下面的代码定义的全局变量都将保存在addon表中，而非_G \nsetfenv(1, setmetatable(select(2, ...), { __index = function(self,  key) local v = _G[key]; rawset(self, key, v); return v end })) \n\nfunction testA() \n    print(\"devil case A\") \nend\n\n```\n```\n-- 插件的其他lua文件仅需要设置运行环境 \nsetfenv(1, select(2, ...)) \n\n-- devil.lua 中定义的函数可以被直接调用 \ntestA()\n\n```\n\n插件的构成就说这么多，好多东西不是很懂，慢慢深入了解就好了；本篇就到这了，有兴趣的可以关注公众号“艾泽拉斯日常”，我们一同来探讨...","source":"_posts/wow插件的构成.md","raw":"title: World of WarCarft插件的构成\ndate: 2016-08-25 11:21:00\ncategories: wower\ntags: [addons, wow, toc]\n-----------\n\n今天来说一说wow插件是个什么鬼？\n<!-- more -->\n\n插件是魔兽世界开放的第三个接口，有朋友会问，什么是第三方？这个是软件业的一个术语，简单的说，就是游戏当中能让我们自己来定制DIY的部分，比方说对话界面，还有一些数据显示之类的功能。\n\nwow的插件全部保存在*World of Warcraft/Interface/AddOns*目录下，在这个目录下会有一些暴雪自带的功能插件，它们均是以*Blizzard_*开头的，我们自己做的插件可以随意命名，不同插件可以分别放在不同的文件夹下面（我们在做插件的过程中，强烈建议用英文命名，避免因为中文导致插件无法被识别的问题）。[http://www.townlong-yak.com/framexml/](http://www.townlong-yak.com/framexml/)这个网址可以下载暴雪自带插件。\n\n说一下插件的构成，打开插件目录，你会发现大致会有三种类型文件，分别是toc文件，xml文件和lua文件。\n\n## toc文件\n\n这个文件是一个必要文件，它的名字与你的插件文件夹名字同名，只不过带了一个后缀toc，如果不同名的话，打开魔兽客户端将会无法识别你的插件；\n\n注意！！！这个文件的每行开头不能有空格，每行仅作一个说明。\n\n用文本工具打开toc文件，内容说明分三种类型：\n\n### 以##开头的数据\n\n用来进行插件描述，一般会有插件名称，作者名称，功能描述等；它的基本格式是\n\n```\n## 标签名：标签值\n```\n\n标签的名字可以随便写，但是有一些wow自带的标签名我们进行一下解释：\n\n```\nInterface:标记插件可用在的wow游戏版本，当该值小于低于当前游戏版本插件不会被加载；\nTitle:插件名称，这个会被显示在游戏选择人物的插件列表里；\nTitle-zhCN:插件的中文显示，如果想要在其他语言中显示，则修改-后面的就可以了；下面的Notes也是如此；\nNotes:插件列表中，鼠标移到插件名上时显示的信息；\nRequiredDeps, Dependencies, 或者任意以 \"Dep\" 开始的字符串：表示我们当前的插件必须需要加载的其他插件；\nOptionalDeps:与上面的对照，这里的插件是可选的；\nLoadOnDemand:值为1时，表示这个插件不会在游戏开始就加载，而是在需要的时候才加载；\nLoadWith:如果上面的值为1时，本条所描述的插件会随着本插件一起加载；\nLoadManagers:本条中所描述的插件如果都不存在的话，则会自动加载本插件；如果有一个存在，则按LoadOnDemand值为1处理；\nSavedVariables:一些以逗号分割的变量名称，这些变量会被保存在硬盘上，下次加载时可以被读取到；\nSavedVariablesPerCharacter:与上面的标签是相同的作用，不过该标签只用于保存不同角色的不同配置；\nDefaultState:本插件默认开启状态，值为disabled/enabled；\nAuthor:作者名字\nVersion:插件的版本号\n\n```\n\n另外你可以定义自己的标签，以上中最重要的就是前两个，尽量不要出错；\n\n### 本插件需要加载的代码文件\n\n列出需要加载的代码类文件，只支持lua和xml两种格式，这里的文件需要给出以当前目录为根目录的文件完整路径，就是说如果你插件目录下有一个`myaddon.lua`的文件则需要添加：\n\n```\nmyaddon.lua\n```\n而如果你插件目录下有一个子文件夹*MyAddon*，而该目录下有一个`myaddon2.lua`的话，则需要添加：\n\n```\nMyAddon/myaddon2.lua\n```\n\n### 以#开头的文件\n\n这些是注释文本，在toc中可以随便添加，主要用作插件制作者自己记录，这些不会被插件加载；\n\n\n## XML文件\n\nxml文件主要用于插件的界面制作，以及事件绑定，事件绑定通俗的讲就是你对插件做某些操作（按一个按钮之类的）游戏中会出现的事件，这些事件会以一个方法的形式出现在lua文件中，你可以把你自己想做的事情写在这个方法中，如果你学过些编程，应该知道我们这里说的方法就是lua函数；\n\n在你插件的根目录下会有一个叫做**Bindings.xml**的文件，这个文件会被游戏客户端自动读取，不必写在toc文件中；\n\n我们来看一个该文件的例子：\n\n```\n<Bindings> \n    <Binding name=\"CUBE_CODE\" header=\"CUBE\"> \n      if IGAS.UIParent.Cube_Main then \n         IGAS.UIParent.Cube_Main.Visible = not IGAS.UIParent.Cube_Main.Visible \n      end \n    </Binding> \n    <Binding name=\"CUBE_DEBUG\"> \n      if IGAS.UIParent.Cube_Debug then \n         IGAS.UIParent.Cube_Debug.Visible = not IGAS.UIParent.Cube_Debug.Visible \n      end \n    </Binding> \n</Bindings>\n```\n\n\n我们暂时先不要管这些代码的意思，只需要知道这个文件设置了界面元素与游戏事件的绑定，而绑定的事件是由Lua文件完成的；**Bindings.xml**文件绑定了一个与插件名同名的lua文件，并且还将界面上的元素与该文件所描述的事件绑定在了一起：\n\n```\n-- Binding Text \n_G.BINDING_HEADER_CUBE = L[\"Cube\"] \n_G.BINDING_NAME_CUBE_CODE = L[\"Simple Dev Tool\"] \n_G.BINDING_NAME_CUBE_DEBUG = L[\"Simple Debug Tool\"]\n\n```\n\n我们现在先不要管他们是怎么联系起来的，具体我们在之后的写代码过程中会慢慢讲到，现在只要理解一点，xml会定义我们的界面，并且还可以设置界面元素与事件的绑定，而绑定的事件会交由lua文件处理；\n\n我们还可以加载其他的xml和lua文件，如下例：\n\n```\n<Ui xmlns=\"http://www.blizzard.com/wow/ui/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.blizzard.com/wow/ui/..\\FrameXML\\UI.xsd\"> \n   <!-- Init --> \n   <Script file = \"IGAS_Toolkit.lua\"/> \n\n   <!-- Modules --> \n   <Include file = \"Modules\\AutoRepair\\AutoRepair.xml\"/> \n   <Include file = \"Modules\\AutoSell\\AutoSell.xml\"/> \n</Ui>\n```\n\n其中**<** **/>**这间的就是xml文件的标签，标签的类型会由**<**后面的名称标识，如上`Script`这个标签用于加载lua文件，而`Include`用于加载其他的xml文件；\n\n## lua文件\n\nLua是wow插件逻辑的主要语言，做插件前需要先熟悉一下lua的语法，感兴趣的不防去知乎下搜索一些学习的建议，找一些入门的资料，在我的公众号给我留言，我们可以一起学习探讨下；这里我们给一些简短的片断，目的是了解一下它的作用；\n\n假设我们现在做一个插件，名为DHAddon（想想DH是不是恶魔猎手的缩写呀？Devil Hunter?），插件里有两个Lua文件devil.lua hunter.lua;\n\nwow加载它们的方式，类似下面的代码：\n\n```\n-- Load DHAddon \nlocal DHAddon = {} \n\nf = loadfile(\"devil.lua\") \nf( \"DHAddon\", DHAddon ) \n\nf = loadfile(\"hunter.lua\") \nf( \"DHAddon\", DHAddon )\n```\n\nloadfile就是加载文件，文件名称用字符串表示（lua语法“”表示字符串）；加载的结果保存在f中；\n\ndevil.lua:\n\n```\nlocal addonName, addon = ... \n\nprint(addonName .. \" is loaded.\") \n\naddon.DHAddon = 123\n\n```\n\nhunter.lua:\n\n```\nlocal addonName, addon = ... \n\nprint( \"DHAddon is \" .. addon.DHAddon )\n```\n\n不出意外的话，运行结果会是：\n\nDHAddon is loaded.\nDHAddon is 123\n\n另外上面的两个lua文件也可以下面这么写，其中有好多lua的内容，暂不解释原因，贴在这里之后了解到了再来回顾：\n\n```\n-- 插件第一个Lua文件使用，这行代码确保以下的代码以addon为环境，而不是以_G为环境， \n-- 并且在addon环境中可以访问_G的任意变量，访问的变量值也将存储到addon中，便于下次直接访问 \n-- 下面的代码定义的全局变量都将保存在addon表中，而非_G \nsetfenv(1, setmetatable(select(2, ...), { __index = function(self,  key) local v = _G[key]; rawset(self, key, v); return v end })) \n\nfunction testA() \n    print(\"devil case A\") \nend\n\n```\n```\n-- 插件的其他lua文件仅需要设置运行环境 \nsetfenv(1, select(2, ...)) \n\n-- devil.lua 中定义的函数可以被直接调用 \ntestA()\n\n```\n\n插件的构成就说这么多，好多东西不是很懂，慢慢深入了解就好了；本篇就到这了，有兴趣的可以关注公众号“艾泽拉斯日常”，我们一同来探讨...","slug":"wow插件的构成","published":1,"updated":"2018-05-04T10:27:26.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucioh001g1v60qzu3s0kd","content":"<p>今天来说一说wow插件是个什么鬼？<br><a id=\"more\"></a></p>\n<p>插件是魔兽世界开放的第三个接口，有朋友会问，什么是第三方？这个是软件业的一个术语，简单的说，就是游戏当中能让我们自己来定制DIY的部分，比方说对话界面，还有一些数据显示之类的功能。</p>\n<p>wow的插件全部保存在<em>World of Warcraft/Interface/AddOns</em>目录下，在这个目录下会有一些暴雪自带的功能插件，它们均是以<em>Blizzard_</em>开头的，我们自己做的插件可以随意命名，不同插件可以分别放在不同的文件夹下面（我们在做插件的过程中，强烈建议用英文命名，避免因为中文导致插件无法被识别的问题）。<a href=\"http://www.townlong-yak.com/framexml/\" target=\"_blank\" rel=\"noopener\">http://www.townlong-yak.com/framexml/</a>这个网址可以下载暴雪自带插件。</p>\n<p>说一下插件的构成，打开插件目录，你会发现大致会有三种类型文件，分别是toc文件，xml文件和lua文件。</p>\n<h2 id=\"toc文件\"><a href=\"#toc文件\" class=\"headerlink\" title=\"toc文件\"></a>toc文件</h2><p>这个文件是一个必要文件，它的名字与你的插件文件夹名字同名，只不过带了一个后缀toc，如果不同名的话，打开魔兽客户端将会无法识别你的插件；</p>\n<p>注意！！！这个文件的每行开头不能有空格，每行仅作一个说明。</p>\n<p>用文本工具打开toc文件，内容说明分三种类型：</p>\n<h3 id=\"以-开头的数据\"><a href=\"#以-开头的数据\" class=\"headerlink\" title=\"以##开头的数据\"></a>以##开头的数据</h3><p>用来进行插件描述，一般会有插件名称，作者名称，功能描述等；它的基本格式是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 标签名：标签值</span><br></pre></td></tr></table></figure>\n<p>标签的名字可以随便写，但是有一些wow自带的标签名我们进行一下解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Interface:标记插件可用在的wow游戏版本，当该值小于低于当前游戏版本插件不会被加载；</span><br><span class=\"line\">Title:插件名称，这个会被显示在游戏选择人物的插件列表里；</span><br><span class=\"line\">Title-zhCN:插件的中文显示，如果想要在其他语言中显示，则修改-后面的就可以了；下面的Notes也是如此；</span><br><span class=\"line\">Notes:插件列表中，鼠标移到插件名上时显示的信息；</span><br><span class=\"line\">RequiredDeps, Dependencies, 或者任意以 &quot;Dep&quot; 开始的字符串：表示我们当前的插件必须需要加载的其他插件；</span><br><span class=\"line\">OptionalDeps:与上面的对照，这里的插件是可选的；</span><br><span class=\"line\">LoadOnDemand:值为1时，表示这个插件不会在游戏开始就加载，而是在需要的时候才加载；</span><br><span class=\"line\">LoadWith:如果上面的值为1时，本条所描述的插件会随着本插件一起加载；</span><br><span class=\"line\">LoadManagers:本条中所描述的插件如果都不存在的话，则会自动加载本插件；如果有一个存在，则按LoadOnDemand值为1处理；</span><br><span class=\"line\">SavedVariables:一些以逗号分割的变量名称，这些变量会被保存在硬盘上，下次加载时可以被读取到；</span><br><span class=\"line\">SavedVariablesPerCharacter:与上面的标签是相同的作用，不过该标签只用于保存不同角色的不同配置；</span><br><span class=\"line\">DefaultState:本插件默认开启状态，值为disabled/enabled；</span><br><span class=\"line\">Author:作者名字</span><br><span class=\"line\">Version:插件的版本号</span><br></pre></td></tr></table></figure>\n<p>另外你可以定义自己的标签，以上中最重要的就是前两个，尽量不要出错；</p>\n<h3 id=\"本插件需要加载的代码文件\"><a href=\"#本插件需要加载的代码文件\" class=\"headerlink\" title=\"本插件需要加载的代码文件\"></a>本插件需要加载的代码文件</h3><p>列出需要加载的代码类文件，只支持lua和xml两种格式，这里的文件需要给出以当前目录为根目录的文件完整路径，就是说如果你插件目录下有一个<code>myaddon.lua</code>的文件则需要添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myaddon.lua</span><br></pre></td></tr></table></figure>\n<p>而如果你插件目录下有一个子文件夹<em>MyAddon</em>，而该目录下有一个<code>myaddon2.lua</code>的话，则需要添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyAddon/myaddon2.lua</span><br></pre></td></tr></table></figure>\n<h3 id=\"以-开头的文件\"><a href=\"#以-开头的文件\" class=\"headerlink\" title=\"以#开头的文件\"></a>以#开头的文件</h3><p>这些是注释文本，在toc中可以随便添加，主要用作插件制作者自己记录，这些不会被插件加载；</p>\n<h2 id=\"XML文件\"><a href=\"#XML文件\" class=\"headerlink\" title=\"XML文件\"></a>XML文件</h2><p>xml文件主要用于插件的界面制作，以及事件绑定，事件绑定通俗的讲就是你对插件做某些操作（按一个按钮之类的）游戏中会出现的事件，这些事件会以一个方法的形式出现在lua文件中，你可以把你自己想做的事情写在这个方法中，如果你学过些编程，应该知道我们这里说的方法就是lua函数；</p>\n<p>在你插件的根目录下会有一个叫做<strong>Bindings.xml</strong>的文件，这个文件会被游戏客户端自动读取，不必写在toc文件中；</p>\n<p>我们来看一个该文件的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Bindings&gt; </span><br><span class=\"line\">    &lt;Binding name=&quot;CUBE_CODE&quot; header=&quot;CUBE&quot;&gt; </span><br><span class=\"line\">      if IGAS.UIParent.Cube_Main then </span><br><span class=\"line\">         IGAS.UIParent.Cube_Main.Visible = not IGAS.UIParent.Cube_Main.Visible </span><br><span class=\"line\">      end </span><br><span class=\"line\">    &lt;/Binding&gt; </span><br><span class=\"line\">    &lt;Binding name=&quot;CUBE_DEBUG&quot;&gt; </span><br><span class=\"line\">      if IGAS.UIParent.Cube_Debug then </span><br><span class=\"line\">         IGAS.UIParent.Cube_Debug.Visible = not IGAS.UIParent.Cube_Debug.Visible </span><br><span class=\"line\">      end </span><br><span class=\"line\">    &lt;/Binding&gt; </span><br><span class=\"line\">&lt;/Bindings&gt;</span><br></pre></td></tr></table></figure>\n<p>我们暂时先不要管这些代码的意思，只需要知道这个文件设置了界面元素与游戏事件的绑定，而绑定的事件是由Lua文件完成的；<strong>Bindings.xml</strong>文件绑定了一个与插件名同名的lua文件，并且还将界面上的元素与该文件所描述的事件绑定在了一起：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Binding Text </span><br><span class=\"line\">_G.BINDING_HEADER_CUBE = L[&quot;Cube&quot;] </span><br><span class=\"line\">_G.BINDING_NAME_CUBE_CODE = L[&quot;Simple Dev Tool&quot;] </span><br><span class=\"line\">_G.BINDING_NAME_CUBE_DEBUG = L[&quot;Simple Debug Tool&quot;]</span><br></pre></td></tr></table></figure>\n<p>我们现在先不要管他们是怎么联系起来的，具体我们在之后的写代码过程中会慢慢讲到，现在只要理解一点，xml会定义我们的界面，并且还可以设置界面元素与事件的绑定，而绑定的事件会交由lua文件处理；</p>\n<p>我们还可以加载其他的xml和lua文件，如下例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Ui xmlns=&quot;http://www.blizzard.com/wow/ui/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.blizzard.com/wow/ui/..\\FrameXML\\UI.xsd&quot;&gt; </span><br><span class=\"line\">   &lt;!-- Init --&gt; </span><br><span class=\"line\">   &lt;Script file = &quot;IGAS_Toolkit.lua&quot;/&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;!-- Modules --&gt; </span><br><span class=\"line\">   &lt;Include file = &quot;Modules\\AutoRepair\\AutoRepair.xml&quot;/&gt; </span><br><span class=\"line\">   &lt;Include file = &quot;Modules\\AutoSell\\AutoSell.xml&quot;/&gt; </span><br><span class=\"line\">&lt;/Ui&gt;</span><br></pre></td></tr></table></figure>\n<p>其中<strong>&lt;</strong> <strong>/&gt;</strong>这间的就是xml文件的标签，标签的类型会由<strong>&lt;</strong>后面的名称标识，如上<code>Script</code>这个标签用于加载lua文件，而<code>Include</code>用于加载其他的xml文件；</p>\n<h2 id=\"lua文件\"><a href=\"#lua文件\" class=\"headerlink\" title=\"lua文件\"></a>lua文件</h2><p>Lua是wow插件逻辑的主要语言，做插件前需要先熟悉一下lua的语法，感兴趣的不防去知乎下搜索一些学习的建议，找一些入门的资料，在我的公众号给我留言，我们可以一起学习探讨下；这里我们给一些简短的片断，目的是了解一下它的作用；</p>\n<p>假设我们现在做一个插件，名为DHAddon（想想DH是不是恶魔猎手的缩写呀？Devil Hunter?），插件里有两个Lua文件devil.lua hunter.lua;</p>\n<p>wow加载它们的方式，类似下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Load DHAddon </span><br><span class=\"line\">local DHAddon = &#123;&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">f = loadfile(&quot;devil.lua&quot;) </span><br><span class=\"line\">f( &quot;DHAddon&quot;, DHAddon ) </span><br><span class=\"line\"></span><br><span class=\"line\">f = loadfile(&quot;hunter.lua&quot;) </span><br><span class=\"line\">f( &quot;DHAddon&quot;, DHAddon )</span><br></pre></td></tr></table></figure>\n<p>loadfile就是加载文件，文件名称用字符串表示（lua语法“”表示字符串）；加载的结果保存在f中；</p>\n<p>devil.lua:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local addonName, addon = ... </span><br><span class=\"line\"></span><br><span class=\"line\">print(addonName .. &quot; is loaded.&quot;) </span><br><span class=\"line\"></span><br><span class=\"line\">addon.DHAddon = 123</span><br></pre></td></tr></table></figure>\n<p>hunter.lua:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local addonName, addon = ... </span><br><span class=\"line\"></span><br><span class=\"line\">print( &quot;DHAddon is &quot; .. addon.DHAddon )</span><br></pre></td></tr></table></figure>\n<p>不出意外的话，运行结果会是：</p>\n<p>DHAddon is loaded.<br>DHAddon is 123</p>\n<p>另外上面的两个lua文件也可以下面这么写，其中有好多lua的内容，暂不解释原因，贴在这里之后了解到了再来回顾：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 插件第一个Lua文件使用，这行代码确保以下的代码以addon为环境，而不是以_G为环境， </span><br><span class=\"line\">-- 并且在addon环境中可以访问_G的任意变量，访问的变量值也将存储到addon中，便于下次直接访问 </span><br><span class=\"line\">-- 下面的代码定义的全局变量都将保存在addon表中，而非_G </span><br><span class=\"line\">setfenv(1, setmetatable(select(2, ...), &#123; __index = function(self,  key) local v = _G[key]; rawset(self, key, v); return v end &#125;)) </span><br><span class=\"line\"></span><br><span class=\"line\">function testA() </span><br><span class=\"line\">    print(&quot;devil case A&quot;) </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 插件的其他lua文件仅需要设置运行环境 </span><br><span class=\"line\">setfenv(1, select(2, ...)) </span><br><span class=\"line\"></span><br><span class=\"line\">-- devil.lua 中定义的函数可以被直接调用 </span><br><span class=\"line\">testA()</span><br></pre></td></tr></table></figure>\n<p>插件的构成就说这么多，好多东西不是很懂，慢慢深入了解就好了；本篇就到这了，有兴趣的可以关注公众号“艾泽拉斯日常”，我们一同来探讨…</p>\n","site":{"data":{}},"excerpt":"<p>今天来说一说wow插件是个什么鬼？<br>","more":"</p>\n<p>插件是魔兽世界开放的第三个接口，有朋友会问，什么是第三方？这个是软件业的一个术语，简单的说，就是游戏当中能让我们自己来定制DIY的部分，比方说对话界面，还有一些数据显示之类的功能。</p>\n<p>wow的插件全部保存在<em>World of Warcraft/Interface/AddOns</em>目录下，在这个目录下会有一些暴雪自带的功能插件，它们均是以<em>Blizzard_</em>开头的，我们自己做的插件可以随意命名，不同插件可以分别放在不同的文件夹下面（我们在做插件的过程中，强烈建议用英文命名，避免因为中文导致插件无法被识别的问题）。<a href=\"http://www.townlong-yak.com/framexml/\" target=\"_blank\" rel=\"noopener\">http://www.townlong-yak.com/framexml/</a>这个网址可以下载暴雪自带插件。</p>\n<p>说一下插件的构成，打开插件目录，你会发现大致会有三种类型文件，分别是toc文件，xml文件和lua文件。</p>\n<h2 id=\"toc文件\"><a href=\"#toc文件\" class=\"headerlink\" title=\"toc文件\"></a>toc文件</h2><p>这个文件是一个必要文件，它的名字与你的插件文件夹名字同名，只不过带了一个后缀toc，如果不同名的话，打开魔兽客户端将会无法识别你的插件；</p>\n<p>注意！！！这个文件的每行开头不能有空格，每行仅作一个说明。</p>\n<p>用文本工具打开toc文件，内容说明分三种类型：</p>\n<h3 id=\"以-开头的数据\"><a href=\"#以-开头的数据\" class=\"headerlink\" title=\"以##开头的数据\"></a>以##开头的数据</h3><p>用来进行插件描述，一般会有插件名称，作者名称，功能描述等；它的基本格式是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 标签名：标签值</span><br></pre></td></tr></table></figure>\n<p>标签的名字可以随便写，但是有一些wow自带的标签名我们进行一下解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Interface:标记插件可用在的wow游戏版本，当该值小于低于当前游戏版本插件不会被加载；</span><br><span class=\"line\">Title:插件名称，这个会被显示在游戏选择人物的插件列表里；</span><br><span class=\"line\">Title-zhCN:插件的中文显示，如果想要在其他语言中显示，则修改-后面的就可以了；下面的Notes也是如此；</span><br><span class=\"line\">Notes:插件列表中，鼠标移到插件名上时显示的信息；</span><br><span class=\"line\">RequiredDeps, Dependencies, 或者任意以 &quot;Dep&quot; 开始的字符串：表示我们当前的插件必须需要加载的其他插件；</span><br><span class=\"line\">OptionalDeps:与上面的对照，这里的插件是可选的；</span><br><span class=\"line\">LoadOnDemand:值为1时，表示这个插件不会在游戏开始就加载，而是在需要的时候才加载；</span><br><span class=\"line\">LoadWith:如果上面的值为1时，本条所描述的插件会随着本插件一起加载；</span><br><span class=\"line\">LoadManagers:本条中所描述的插件如果都不存在的话，则会自动加载本插件；如果有一个存在，则按LoadOnDemand值为1处理；</span><br><span class=\"line\">SavedVariables:一些以逗号分割的变量名称，这些变量会被保存在硬盘上，下次加载时可以被读取到；</span><br><span class=\"line\">SavedVariablesPerCharacter:与上面的标签是相同的作用，不过该标签只用于保存不同角色的不同配置；</span><br><span class=\"line\">DefaultState:本插件默认开启状态，值为disabled/enabled；</span><br><span class=\"line\">Author:作者名字</span><br><span class=\"line\">Version:插件的版本号</span><br></pre></td></tr></table></figure>\n<p>另外你可以定义自己的标签，以上中最重要的就是前两个，尽量不要出错；</p>\n<h3 id=\"本插件需要加载的代码文件\"><a href=\"#本插件需要加载的代码文件\" class=\"headerlink\" title=\"本插件需要加载的代码文件\"></a>本插件需要加载的代码文件</h3><p>列出需要加载的代码类文件，只支持lua和xml两种格式，这里的文件需要给出以当前目录为根目录的文件完整路径，就是说如果你插件目录下有一个<code>myaddon.lua</code>的文件则需要添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myaddon.lua</span><br></pre></td></tr></table></figure>\n<p>而如果你插件目录下有一个子文件夹<em>MyAddon</em>，而该目录下有一个<code>myaddon2.lua</code>的话，则需要添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyAddon/myaddon2.lua</span><br></pre></td></tr></table></figure>\n<h3 id=\"以-开头的文件\"><a href=\"#以-开头的文件\" class=\"headerlink\" title=\"以#开头的文件\"></a>以#开头的文件</h3><p>这些是注释文本，在toc中可以随便添加，主要用作插件制作者自己记录，这些不会被插件加载；</p>\n<h2 id=\"XML文件\"><a href=\"#XML文件\" class=\"headerlink\" title=\"XML文件\"></a>XML文件</h2><p>xml文件主要用于插件的界面制作，以及事件绑定，事件绑定通俗的讲就是你对插件做某些操作（按一个按钮之类的）游戏中会出现的事件，这些事件会以一个方法的形式出现在lua文件中，你可以把你自己想做的事情写在这个方法中，如果你学过些编程，应该知道我们这里说的方法就是lua函数；</p>\n<p>在你插件的根目录下会有一个叫做<strong>Bindings.xml</strong>的文件，这个文件会被游戏客户端自动读取，不必写在toc文件中；</p>\n<p>我们来看一个该文件的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Bindings&gt; </span><br><span class=\"line\">    &lt;Binding name=&quot;CUBE_CODE&quot; header=&quot;CUBE&quot;&gt; </span><br><span class=\"line\">      if IGAS.UIParent.Cube_Main then </span><br><span class=\"line\">         IGAS.UIParent.Cube_Main.Visible = not IGAS.UIParent.Cube_Main.Visible </span><br><span class=\"line\">      end </span><br><span class=\"line\">    &lt;/Binding&gt; </span><br><span class=\"line\">    &lt;Binding name=&quot;CUBE_DEBUG&quot;&gt; </span><br><span class=\"line\">      if IGAS.UIParent.Cube_Debug then </span><br><span class=\"line\">         IGAS.UIParent.Cube_Debug.Visible = not IGAS.UIParent.Cube_Debug.Visible </span><br><span class=\"line\">      end </span><br><span class=\"line\">    &lt;/Binding&gt; </span><br><span class=\"line\">&lt;/Bindings&gt;</span><br></pre></td></tr></table></figure>\n<p>我们暂时先不要管这些代码的意思，只需要知道这个文件设置了界面元素与游戏事件的绑定，而绑定的事件是由Lua文件完成的；<strong>Bindings.xml</strong>文件绑定了一个与插件名同名的lua文件，并且还将界面上的元素与该文件所描述的事件绑定在了一起：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Binding Text </span><br><span class=\"line\">_G.BINDING_HEADER_CUBE = L[&quot;Cube&quot;] </span><br><span class=\"line\">_G.BINDING_NAME_CUBE_CODE = L[&quot;Simple Dev Tool&quot;] </span><br><span class=\"line\">_G.BINDING_NAME_CUBE_DEBUG = L[&quot;Simple Debug Tool&quot;]</span><br></pre></td></tr></table></figure>\n<p>我们现在先不要管他们是怎么联系起来的，具体我们在之后的写代码过程中会慢慢讲到，现在只要理解一点，xml会定义我们的界面，并且还可以设置界面元素与事件的绑定，而绑定的事件会交由lua文件处理；</p>\n<p>我们还可以加载其他的xml和lua文件，如下例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Ui xmlns=&quot;http://www.blizzard.com/wow/ui/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.blizzard.com/wow/ui/..\\FrameXML\\UI.xsd&quot;&gt; </span><br><span class=\"line\">   &lt;!-- Init --&gt; </span><br><span class=\"line\">   &lt;Script file = &quot;IGAS_Toolkit.lua&quot;/&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">   &lt;!-- Modules --&gt; </span><br><span class=\"line\">   &lt;Include file = &quot;Modules\\AutoRepair\\AutoRepair.xml&quot;/&gt; </span><br><span class=\"line\">   &lt;Include file = &quot;Modules\\AutoSell\\AutoSell.xml&quot;/&gt; </span><br><span class=\"line\">&lt;/Ui&gt;</span><br></pre></td></tr></table></figure>\n<p>其中<strong>&lt;</strong> <strong>/&gt;</strong>这间的就是xml文件的标签，标签的类型会由<strong>&lt;</strong>后面的名称标识，如上<code>Script</code>这个标签用于加载lua文件，而<code>Include</code>用于加载其他的xml文件；</p>\n<h2 id=\"lua文件\"><a href=\"#lua文件\" class=\"headerlink\" title=\"lua文件\"></a>lua文件</h2><p>Lua是wow插件逻辑的主要语言，做插件前需要先熟悉一下lua的语法，感兴趣的不防去知乎下搜索一些学习的建议，找一些入门的资料，在我的公众号给我留言，我们可以一起学习探讨下；这里我们给一些简短的片断，目的是了解一下它的作用；</p>\n<p>假设我们现在做一个插件，名为DHAddon（想想DH是不是恶魔猎手的缩写呀？Devil Hunter?），插件里有两个Lua文件devil.lua hunter.lua;</p>\n<p>wow加载它们的方式，类似下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Load DHAddon </span><br><span class=\"line\">local DHAddon = &#123;&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">f = loadfile(&quot;devil.lua&quot;) </span><br><span class=\"line\">f( &quot;DHAddon&quot;, DHAddon ) </span><br><span class=\"line\"></span><br><span class=\"line\">f = loadfile(&quot;hunter.lua&quot;) </span><br><span class=\"line\">f( &quot;DHAddon&quot;, DHAddon )</span><br></pre></td></tr></table></figure>\n<p>loadfile就是加载文件，文件名称用字符串表示（lua语法“”表示字符串）；加载的结果保存在f中；</p>\n<p>devil.lua:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local addonName, addon = ... </span><br><span class=\"line\"></span><br><span class=\"line\">print(addonName .. &quot; is loaded.&quot;) </span><br><span class=\"line\"></span><br><span class=\"line\">addon.DHAddon = 123</span><br></pre></td></tr></table></figure>\n<p>hunter.lua:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local addonName, addon = ... </span><br><span class=\"line\"></span><br><span class=\"line\">print( &quot;DHAddon is &quot; .. addon.DHAddon )</span><br></pre></td></tr></table></figure>\n<p>不出意外的话，运行结果会是：</p>\n<p>DHAddon is loaded.<br>DHAddon is 123</p>\n<p>另外上面的两个lua文件也可以下面这么写，其中有好多lua的内容，暂不解释原因，贴在这里之后了解到了再来回顾：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 插件第一个Lua文件使用，这行代码确保以下的代码以addon为环境，而不是以_G为环境， </span><br><span class=\"line\">-- 并且在addon环境中可以访问_G的任意变量，访问的变量值也将存储到addon中，便于下次直接访问 </span><br><span class=\"line\">-- 下面的代码定义的全局变量都将保存在addon表中，而非_G </span><br><span class=\"line\">setfenv(1, setmetatable(select(2, ...), &#123; __index = function(self,  key) local v = _G[key]; rawset(self, key, v); return v end &#125;)) </span><br><span class=\"line\"></span><br><span class=\"line\">function testA() </span><br><span class=\"line\">    print(&quot;devil case A&quot;) </span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 插件的其他lua文件仅需要设置运行环境 </span><br><span class=\"line\">setfenv(1, select(2, ...)) </span><br><span class=\"line\"></span><br><span class=\"line\">-- devil.lua 中定义的函数可以被直接调用 </span><br><span class=\"line\">testA()</span><br></pre></td></tr></table></figure>\n<p>插件的构成就说这么多，好多东西不是很懂，慢慢深入了解就好了；本篇就到这了，有兴趣的可以关注公众号“艾泽拉斯日常”，我们一同来探讨…</p>"},{"title":"人类是如何产生的？魔兽告诉你","date":"2016-08-18T00:46:00.000Z","_content":"\n![](http://upload-images.jianshu.io/upload_images/1429775-bc7aca2399e81c44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n图为古时维京人，可能与魔兽早期人类的原型有关，此篇不讨论。\n\n<!-- more -->\n\n\n今天我们要说的是，人类的崛起。\n\n前面我们说到奥丁被洛肯封印在了英灵殿中，而追随他的泰坦造物也被洛肯流放到了卡利姆多的北方。这些泰坦造物里主要有两个分支，一个是维库人，一个是土灵。他们各自分裂成一些小的派系，在北方的土地上过着严酷的游牧生活。同时他们也受到了尤格隆萨的“血肉诅咒”使得他们不再拥有泰坦造物原有的特征：钢铁皮肤与长生不老。\n\n接下来爆发了“冬履之战”，战斗主要涉及了洛肯嫡系部队火巨人沃坎及伊格尼斯，这两人在魔兽游戏里没有注意到，总之在魔兽编年史中的戏份不多，这里只是挑起了维库的冬履氏族和土灵人的战争，他们创造了熔火魔像和钢铁构造体，之后还奴役了元龙，冬履大战结束后却不知去向何处；接下来涉及到的是维库的冬履氏族和土灵，冬履氏族主动攻击了众多土灵，而土灵则请求守护者提尔的帮助；提尔后期又请求了五色元龙的援助，五色元龙参战。\n\n战争结果是，冬履氏族被全数催眠封印在地底，土灵只有一小部分存活，后也被封印在了奥达曼中，元龙依旧履行起了守护世界的职责。\n\n这样一来，在卡利姆多北方的土地上，只留下了部分的维库人氏族，其中最为强大的就是掠龙人氏族，而这个氏族，便是人类的祖先。\n\n维库人无法抵御血肉诅咒，新生儿瘦小而畸形，不再拥有以前青铜皮肤。国王伊米隆为保护血脉的正统，下令将所有畸形的新生儿杀掉，以保持血脉的纯正。少数掠龙人并没有听从国王的指挥，而是选择了流亡，带着他们的子嗣开始了向南方漫长的迁徙。这些迁徙后的维库人而后会在南方建立起早期的人类国度，人类诞生。\n\n总结一下，大致是一个不能称作为人类的种族在暴发了一系列战争之后逐渐可以被称作人类的漫长过程。\n\n同样受到血肉诅咒的泰坦造物们也有着相同的命运，侏儒，托维尔，魔古族，巨人，矮人相继出现。这些受血肉诅咒的泰坦造物们组成了我们如今的魔兽世界。\n\n从现在开始，泰坦与守护者将与我们远去，艾泽拉斯进入早期社会。","source":"_posts/人类是如何产生的？魔兽告诉你.md","raw":"title: 人类是如何产生的？魔兽告诉你\ndate: 2016-08-18 08:46:00\ncategories: Azeroth\n-----------\n\n![](http://upload-images.jianshu.io/upload_images/1429775-bc7aca2399e81c44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n图为古时维京人，可能与魔兽早期人类的原型有关，此篇不讨论。\n\n<!-- more -->\n\n\n今天我们要说的是，人类的崛起。\n\n前面我们说到奥丁被洛肯封印在了英灵殿中，而追随他的泰坦造物也被洛肯流放到了卡利姆多的北方。这些泰坦造物里主要有两个分支，一个是维库人，一个是土灵。他们各自分裂成一些小的派系，在北方的土地上过着严酷的游牧生活。同时他们也受到了尤格隆萨的“血肉诅咒”使得他们不再拥有泰坦造物原有的特征：钢铁皮肤与长生不老。\n\n接下来爆发了“冬履之战”，战斗主要涉及了洛肯嫡系部队火巨人沃坎及伊格尼斯，这两人在魔兽游戏里没有注意到，总之在魔兽编年史中的戏份不多，这里只是挑起了维库的冬履氏族和土灵人的战争，他们创造了熔火魔像和钢铁构造体，之后还奴役了元龙，冬履大战结束后却不知去向何处；接下来涉及到的是维库的冬履氏族和土灵，冬履氏族主动攻击了众多土灵，而土灵则请求守护者提尔的帮助；提尔后期又请求了五色元龙的援助，五色元龙参战。\n\n战争结果是，冬履氏族被全数催眠封印在地底，土灵只有一小部分存活，后也被封印在了奥达曼中，元龙依旧履行起了守护世界的职责。\n\n这样一来，在卡利姆多北方的土地上，只留下了部分的维库人氏族，其中最为强大的就是掠龙人氏族，而这个氏族，便是人类的祖先。\n\n维库人无法抵御血肉诅咒，新生儿瘦小而畸形，不再拥有以前青铜皮肤。国王伊米隆为保护血脉的正统，下令将所有畸形的新生儿杀掉，以保持血脉的纯正。少数掠龙人并没有听从国王的指挥，而是选择了流亡，带着他们的子嗣开始了向南方漫长的迁徙。这些迁徙后的维库人而后会在南方建立起早期的人类国度，人类诞生。\n\n总结一下，大致是一个不能称作为人类的种族在暴发了一系列战争之后逐渐可以被称作人类的漫长过程。\n\n同样受到血肉诅咒的泰坦造物们也有着相同的命运，侏儒，托维尔，魔古族，巨人，矮人相继出现。这些受血肉诅咒的泰坦造物们组成了我们如今的魔兽世界。\n\n从现在开始，泰坦与守护者将与我们远去，艾泽拉斯进入早期社会。","slug":"人类是如何产生的？魔兽告诉你","published":1,"updated":"2018-05-04T10:24:07.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucioi001j1v600ei2e27n","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-bc7aca2399e81c44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>图为古时维京人，可能与魔兽早期人类的原型有关，此篇不讨论。</p>\n<a id=\"more\"></a>\n<p>今天我们要说的是，人类的崛起。</p>\n<p>前面我们说到奥丁被洛肯封印在了英灵殿中，而追随他的泰坦造物也被洛肯流放到了卡利姆多的北方。这些泰坦造物里主要有两个分支，一个是维库人，一个是土灵。他们各自分裂成一些小的派系，在北方的土地上过着严酷的游牧生活。同时他们也受到了尤格隆萨的“血肉诅咒”使得他们不再拥有泰坦造物原有的特征：钢铁皮肤与长生不老。</p>\n<p>接下来爆发了“冬履之战”，战斗主要涉及了洛肯嫡系部队火巨人沃坎及伊格尼斯，这两人在魔兽游戏里没有注意到，总之在魔兽编年史中的戏份不多，这里只是挑起了维库的冬履氏族和土灵人的战争，他们创造了熔火魔像和钢铁构造体，之后还奴役了元龙，冬履大战结束后却不知去向何处；接下来涉及到的是维库的冬履氏族和土灵，冬履氏族主动攻击了众多土灵，而土灵则请求守护者提尔的帮助；提尔后期又请求了五色元龙的援助，五色元龙参战。</p>\n<p>战争结果是，冬履氏族被全数催眠封印在地底，土灵只有一小部分存活，后也被封印在了奥达曼中，元龙依旧履行起了守护世界的职责。</p>\n<p>这样一来，在卡利姆多北方的土地上，只留下了部分的维库人氏族，其中最为强大的就是掠龙人氏族，而这个氏族，便是人类的祖先。</p>\n<p>维库人无法抵御血肉诅咒，新生儿瘦小而畸形，不再拥有以前青铜皮肤。国王伊米隆为保护血脉的正统，下令将所有畸形的新生儿杀掉，以保持血脉的纯正。少数掠龙人并没有听从国王的指挥，而是选择了流亡，带着他们的子嗣开始了向南方漫长的迁徙。这些迁徙后的维库人而后会在南方建立起早期的人类国度，人类诞生。</p>\n<p>总结一下，大致是一个不能称作为人类的种族在暴发了一系列战争之后逐渐可以被称作人类的漫长过程。</p>\n<p>同样受到血肉诅咒的泰坦造物们也有着相同的命运，侏儒，托维尔，魔古族，巨人，矮人相继出现。这些受血肉诅咒的泰坦造物们组成了我们如今的魔兽世界。</p>\n<p>从现在开始，泰坦与守护者将与我们远去，艾泽拉斯进入早期社会。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-bc7aca2399e81c44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>图为古时维京人，可能与魔兽早期人类的原型有关，此篇不讨论。</p>","more":"<p>今天我们要说的是，人类的崛起。</p>\n<p>前面我们说到奥丁被洛肯封印在了英灵殿中，而追随他的泰坦造物也被洛肯流放到了卡利姆多的北方。这些泰坦造物里主要有两个分支，一个是维库人，一个是土灵。他们各自分裂成一些小的派系，在北方的土地上过着严酷的游牧生活。同时他们也受到了尤格隆萨的“血肉诅咒”使得他们不再拥有泰坦造物原有的特征：钢铁皮肤与长生不老。</p>\n<p>接下来爆发了“冬履之战”，战斗主要涉及了洛肯嫡系部队火巨人沃坎及伊格尼斯，这两人在魔兽游戏里没有注意到，总之在魔兽编年史中的戏份不多，这里只是挑起了维库的冬履氏族和土灵人的战争，他们创造了熔火魔像和钢铁构造体，之后还奴役了元龙，冬履大战结束后却不知去向何处；接下来涉及到的是维库的冬履氏族和土灵，冬履氏族主动攻击了众多土灵，而土灵则请求守护者提尔的帮助；提尔后期又请求了五色元龙的援助，五色元龙参战。</p>\n<p>战争结果是，冬履氏族被全数催眠封印在地底，土灵只有一小部分存活，后也被封印在了奥达曼中，元龙依旧履行起了守护世界的职责。</p>\n<p>这样一来，在卡利姆多北方的土地上，只留下了部分的维库人氏族，其中最为强大的就是掠龙人氏族，而这个氏族，便是人类的祖先。</p>\n<p>维库人无法抵御血肉诅咒，新生儿瘦小而畸形，不再拥有以前青铜皮肤。国王伊米隆为保护血脉的正统，下令将所有畸形的新生儿杀掉，以保持血脉的纯正。少数掠龙人并没有听从国王的指挥，而是选择了流亡，带着他们的子嗣开始了向南方漫长的迁徙。这些迁徙后的维库人而后会在南方建立起早期的人类国度，人类诞生。</p>\n<p>总结一下，大致是一个不能称作为人类的种族在暴发了一系列战争之后逐渐可以被称作人类的漫长过程。</p>\n<p>同样受到血肉诅咒的泰坦造物们也有着相同的命运，侏儒，托维尔，魔古族，巨人，矮人相继出现。这些受血肉诅咒的泰坦造物们组成了我们如今的魔兽世界。</p>\n<p>从现在开始，泰坦与守护者将与我们远去，艾泽拉斯进入早期社会。</p>"},{"title":"你一定不知道Swift源码怎么看？","date":"2018-05-03T15:19:00.000Z","_content":"我想你一定是在开玩笑。\n源码怎么看，打开看呗！说这话的时候请收下我的轻蔑，哈哈。不过就这个问题我今天在知乎搜索了一通。不要问我为什么在知乎搜索，鬼知道知乎什么都有。\n那么，请收下我的提问：\n<!-- more -->\n\n> [如何阅读Swift源码](https://www.zhihu.com/question/38215419)\n\n知乎果然没有让我失望，结果教程如下；\n> [# [如何阅读 Swift 标准库中的源码](http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/ \"如何阅读 Swift 标准库中的源码\")\n](http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/)\n\n顺便提一下，这次搜索还让我发现了一个比较不错的swift网站，有心的同学请收下：[swift.gg](http://swift.gg)\n\n于是今天搞了下源码的编译，并了解到一个叫做 *GYB* 的东西，这个东西今天先放一下。源碼編譯的過程無非就是用 *brew* 下了一些命令行軟件，然後使用 *build* 腳本跑一下過程，在此也不多說。但是今天的重點當然是我們要從源碼出發搞一些事情。\n续：今天又build，发现也并没有得出什么重要的东西，只是把gyb文件生成为swift文件，其他过程不知道它经历了什么，对我想看源码没有任何作用，还跑了整整一个下午；对于只是想看代码的同学，还是用官网给出的gyb.py脚本做处理吧；\n\n1. hashable\n\n前两天写Dictionary时发现想用枚举做key，自定义一个Dictionary，value是#selector，但是在写的过程中发现说key值需要遵循hashable协议。可以看源码来理解一下。\n首先要找到Hashable文件，发现swift的标准核心库被放在 **stdlib/public/core** 下，有一个 **Hashable.swift** 文件，打开文件先是一大段的描述，大体内容就是hashable协议作用的场景，以及给出了一个小例子；\n\n一个Hash类型，提供了一个 hashValue 的属性，它是一个整型常量， 如果有两个相同类型的a，b，如果 a == b，那么 a.hashValue == b.hashValue；但是反过来，如果两个hash值相同，并不表示a 就一定等于 b；\n还有一点非常重要，就是在两次不同的程序执行中hash值并不保证相等，所以不要把hash值用在你的程序中；\nHashable协议可用于struct, enum, class，它继承于 Equatable，所以遵循Hashable协议需要同时实现Hashable协议方法，以及 Equatable 协议方法；\n\n```\n/// A point in an x-y coordinate system.\n    struct GridPoint {\n        var x: Int\n        var y: Int\n    }\n\n     extension GridPoint: Hashable {\n         var hashValue: Int {\n            return x.hashValue ^ y.hashValue &* 16777619\n        }\n\n        static func == (lhs: GridPoint, rhs: GridPoint) -> Bool {\n            return lhs.x == rhs.x && lhs.y == rhs.y\n        }\n    }\n\n       var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]\n       let nextTap = GridPoint(x: 0, y: 1)\n       if tappedPoints.contains(nextTap) {\n          print(\"Already tapped at (\\(nextTap.x), \\(nextTap.y)).\")\n       } else {\n          tappedPoints.insert(nextTap)\n          print(\"New tap detected at (\\(nextTap.x), \\(nextTap.y)).\")\n       }\n      // Prints \"New tap detected at (0, 1).\")\n```\n在实现的代码里有一些奇怪的符号，暂时还有点摸不清头脑，有些是一些编译符号，大体能看懂点意思，但有些像`@_silgen_name(\"_swift_stdlib_Hashable_isEqual_indirect\")`就完全看不懂，回头找人再请教；\n这里还要说的一个就是一个`UnsafePointer<T>`:\n>在 Swift 中，指针都使用一个特殊的类型来表示，那就是 UnsafePointer<T>。遵循了 Cocoa 的一贯不可变原则，UnsafePointer<T> 也是不可变的。当然对应地，它还有一个可变变体，UnsafeMutablePointer<T>。绝大部分时间里，C 中的指针都会被以这两种类型引入到 Swift 中：C 中 const 修饰的指针对应 UnsafePointer (最常见的应该就是 C 字符串的 const char * 了)，而其他可变的指针则对应 UnsafeMutablePointer。除此之外，Swift 中存在表示一组连续数据指针的 UnsafeBufferPointer<T>，表示非完整结构的不透明指针 COpaquePointer 等等。另外你可能已经注意到了，能够确定指向内容的指针类型都是泛型的 struct，我们可以通过这个泛型来对指针指向的类型进行约束以提供一定安全性。\n\n需要具体了解的看这篇：[UnsafePointe<T>](https://onevcat.com/2015/01/swift-pointer/)\n\n顺便吐槽句哈，apple的代码也还有这种东西，也不知道是修改过的没有；\n![FIXME](https://upload-images.jianshu.io/upload_images/1429775-225ee3ef5a38e747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. Equatable\n\n* 它是一种可用于值比较的类型；\n* 在序列和集合操作中，可以将一个遵循了`Equatable`协议的对象传递给`contaions(_:)`方法，来确定是否包含，用法如下：\n\n```swift\nlet students = [\"Nora\", \"Fern\", \"Ryan\", \"Rainer\"]\n\nlet nameToCheck = \"Ryan\"\nif students.contains(nameToCheck) {\n    print(\"\\(nameToCheck) is signed up!\")\n} else {\n    print(\"No record of \\(nameToCheck).\")\n}\n   // Prints \"Ryan is signed up!\"\n\n/// Conforming to the Equatable Protocol\n```\n\n* 本地类型继承自`Equatable`协议需要注意：\n  1. 对于一个`struct`类型，它的所有存储属性都需要遵循`Equatable`协议；\n  2. 对于一个`enum`类型，它的所有关联值都需要遵循`Equatable`协议；\n  3. 如果上述标准不符合，需要在扩展中实现`==`静态方法；\n例如：\n\n```\nclass StreetAddress {\n    let number: String\n    let street: String\n    let unit: String?\n    init(_ number: String, _ street: String, unit: String? = nil) {\n        self.number = number\n        self.street = street\n        self.unit = unit\n    }\n}\n\nextension StreetAddress: Equatable {\n    static func == (lhs: StreetAddress, rhs: StreetAddress) -> Bool {\n        return\n            lhs.number == rhs.number &&\n            lhs.street == rhs.street &&\n            lhs.unit == rhs.unit\n    }\n}\n\nlet addresses = [StreetAddress(\"1490\", \"Grove Street\"),\n                 StreetAddress(\"2119\", \"Maple Avenue\"),\n                 StreetAddress(\"1400\", \"16th Street\")]\nlet home = StreetAddress(\"1400\", \"16th Street\")\nprint(addresses[0] == home)\n// Prints \"false\"\nprint(addresses.contains(home))\n// Prints \"true\"\n```\n\n* 另外我在这个实现里面看到了以前数学课知识的身影：\n- `a == a` is always `true` (Reflexivity)   # 自反性\n- `a == b` implies `b == a` (Symmetry)  # 对称性\n- `a == b` and `b == c` implies `a == c` (Transitivity)  # 传递性\n所以我们定义的`==`(两对象相等)完全取决于我们自己实现的静态方法：\n\n```\nclass IntegerRef: Equatable {\n    let value: Int\n    init(_ value: Int) {\n        self.value = value\n    }\n    static func == (lhs: IntegerRef, rhs: IntegerRef) -> Bool {\n        return lhs.value == rhs.value\n    }\n}\nlet a = IntegerRef(100)\nlet b = IntegerRef(100)\nprint(a == a, a == b, separator: \", \")\n// Prints \"true, true\"\n```\n\n而不相等的定义则完全是，自实现的相等操作取反：\n\n```\nextension Equatable {\n  /// Returns a Boolean value indicating whether two values are not equal.\n  ///\n  /// Inequality is the inverse of equality. For any values `a` and `b`, `a != b`\n  /// implies that `a == b` is `false`.\n  ///\n  /// This is the default implementation of the not-equal-to operator (`!=`)\n  /// for any type that conforms to `Equatable`.\n  ///\n  /// - Parameters:\n  ///   - lhs: A value to compare.\n  ///   - rhs: Another value to compare.\n  @inlinable // FIXME(sil-serialize-all)\n  @_transparent\n  public static func != (lhs: Self, rhs: Self) -> Bool {\n    return !(lhs == rhs)\n  }\n}\n```\n这个实现是已经定义好的！！!\n\n* `==`与`===`的区别\n看一下这两者的区别：\n\n```\npublic protocol Equatable {\n  /// Returns a Boolean value indicating whether two values are equal.\n  ///\n  /// Equality is the inverse of inequality. For any values `a` and `b`,\n  /// `a == b` implies that `a != b` is `false`.\n  ///\n  /// - Parameters:\n  ///   - lhs: A value to compare.\n  ///   - rhs: Another value to compare.\n  static func == (lhs: Self, rhs: Self) -> Bool\n}\n```\n```\n@inlinable // FIXME(sil-serialize-all)\npublic func === (lhs: AnyObject?, rhs: AnyObject?) -> Bool {\n  switch (lhs, rhs) {\n  case let (l?, r?):\n    return ObjectIdentifier(l) == ObjectIdentifier(r)\n  case (nil, nil):\n    return true\n  default:\n    return false\n  }\n}\n```\n从以上可以看出，`==`只是由实现好的静态函数决定，而`===`则是可以判断两个对象是否完全相等，这有点像判断两个指针相等一样，同样，我们要注意，如果两个可选对象都是nil，则也是`===`的；\n\n3. 搞清楚两个问题\n\n* UTC 与 GMT\nUTC(Coordinated Universal Time)标准时间参照，协调时间时，世界标准时间;\nGMT(Greenwich Mean Time)时区，即格林尼治时间，位于本初子午线的标界处时间，世界计算时间和经度的起点，GMT是个时区，等同于世界时，所以GMT = UTC + 0，我们国家所在时间均以北京时间计算，北京位于东八区，所以时区为GMT + 8；\n\n* Locale\n 网上找了一圈，最后还是swift源码文档里给出的解释最靠谱：`Locale`封装了有关语言，文化和技术规范和标准的信息。由语言环境封装的信息示例包括，用于数字中小数点分隔符的符号以及格式化日期的方式。区域设置通常用于根据用户的习俗和偏好提供，格式化和解释信息。它们经常与格式化程序一起使用。虽然可以使用很多语言环境，但通常使用与当前用户关联的语言环境。\n语言环境跟系统的环境设置有关，会涉及到操作系统语言环境设置，个人理解就是一个国际化的东西。\n区域设置中的概念 LANGID & LCID：\n![LANGID & LCID](https://upload-images.jianshu.io/upload_images/1429775-04ff650284a51b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n","source":"_posts/你一定不知道Swift源码怎么看？.md","raw":"title: 你一定不知道Swift源码怎么看？\ndate: 2018-05-03 23:19:00\ncategories: coder\ntags: [swift, UTC]\n-----------\n我想你一定是在开玩笑。\n源码怎么看，打开看呗！说这话的时候请收下我的轻蔑，哈哈。不过就这个问题我今天在知乎搜索了一通。不要问我为什么在知乎搜索，鬼知道知乎什么都有。\n那么，请收下我的提问：\n<!-- more -->\n\n> [如何阅读Swift源码](https://www.zhihu.com/question/38215419)\n\n知乎果然没有让我失望，结果教程如下；\n> [# [如何阅读 Swift 标准库中的源码](http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/ \"如何阅读 Swift 标准库中的源码\")\n](http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/)\n\n顺便提一下，这次搜索还让我发现了一个比较不错的swift网站，有心的同学请收下：[swift.gg](http://swift.gg)\n\n于是今天搞了下源码的编译，并了解到一个叫做 *GYB* 的东西，这个东西今天先放一下。源碼編譯的過程無非就是用 *brew* 下了一些命令行軟件，然後使用 *build* 腳本跑一下過程，在此也不多說。但是今天的重點當然是我們要從源碼出發搞一些事情。\n续：今天又build，发现也并没有得出什么重要的东西，只是把gyb文件生成为swift文件，其他过程不知道它经历了什么，对我想看源码没有任何作用，还跑了整整一个下午；对于只是想看代码的同学，还是用官网给出的gyb.py脚本做处理吧；\n\n1. hashable\n\n前两天写Dictionary时发现想用枚举做key，自定义一个Dictionary，value是#selector，但是在写的过程中发现说key值需要遵循hashable协议。可以看源码来理解一下。\n首先要找到Hashable文件，发现swift的标准核心库被放在 **stdlib/public/core** 下，有一个 **Hashable.swift** 文件，打开文件先是一大段的描述，大体内容就是hashable协议作用的场景，以及给出了一个小例子；\n\n一个Hash类型，提供了一个 hashValue 的属性，它是一个整型常量， 如果有两个相同类型的a，b，如果 a == b，那么 a.hashValue == b.hashValue；但是反过来，如果两个hash值相同，并不表示a 就一定等于 b；\n还有一点非常重要，就是在两次不同的程序执行中hash值并不保证相等，所以不要把hash值用在你的程序中；\nHashable协议可用于struct, enum, class，它继承于 Equatable，所以遵循Hashable协议需要同时实现Hashable协议方法，以及 Equatable 协议方法；\n\n```\n/// A point in an x-y coordinate system.\n    struct GridPoint {\n        var x: Int\n        var y: Int\n    }\n\n     extension GridPoint: Hashable {\n         var hashValue: Int {\n            return x.hashValue ^ y.hashValue &* 16777619\n        }\n\n        static func == (lhs: GridPoint, rhs: GridPoint) -> Bool {\n            return lhs.x == rhs.x && lhs.y == rhs.y\n        }\n    }\n\n       var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]\n       let nextTap = GridPoint(x: 0, y: 1)\n       if tappedPoints.contains(nextTap) {\n          print(\"Already tapped at (\\(nextTap.x), \\(nextTap.y)).\")\n       } else {\n          tappedPoints.insert(nextTap)\n          print(\"New tap detected at (\\(nextTap.x), \\(nextTap.y)).\")\n       }\n      // Prints \"New tap detected at (0, 1).\")\n```\n在实现的代码里有一些奇怪的符号，暂时还有点摸不清头脑，有些是一些编译符号，大体能看懂点意思，但有些像`@_silgen_name(\"_swift_stdlib_Hashable_isEqual_indirect\")`就完全看不懂，回头找人再请教；\n这里还要说的一个就是一个`UnsafePointer<T>`:\n>在 Swift 中，指针都使用一个特殊的类型来表示，那就是 UnsafePointer<T>。遵循了 Cocoa 的一贯不可变原则，UnsafePointer<T> 也是不可变的。当然对应地，它还有一个可变变体，UnsafeMutablePointer<T>。绝大部分时间里，C 中的指针都会被以这两种类型引入到 Swift 中：C 中 const 修饰的指针对应 UnsafePointer (最常见的应该就是 C 字符串的 const char * 了)，而其他可变的指针则对应 UnsafeMutablePointer。除此之外，Swift 中存在表示一组连续数据指针的 UnsafeBufferPointer<T>，表示非完整结构的不透明指针 COpaquePointer 等等。另外你可能已经注意到了，能够确定指向内容的指针类型都是泛型的 struct，我们可以通过这个泛型来对指针指向的类型进行约束以提供一定安全性。\n\n需要具体了解的看这篇：[UnsafePointe<T>](https://onevcat.com/2015/01/swift-pointer/)\n\n顺便吐槽句哈，apple的代码也还有这种东西，也不知道是修改过的没有；\n![FIXME](https://upload-images.jianshu.io/upload_images/1429775-225ee3ef5a38e747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. Equatable\n\n* 它是一种可用于值比较的类型；\n* 在序列和集合操作中，可以将一个遵循了`Equatable`协议的对象传递给`contaions(_:)`方法，来确定是否包含，用法如下：\n\n```swift\nlet students = [\"Nora\", \"Fern\", \"Ryan\", \"Rainer\"]\n\nlet nameToCheck = \"Ryan\"\nif students.contains(nameToCheck) {\n    print(\"\\(nameToCheck) is signed up!\")\n} else {\n    print(\"No record of \\(nameToCheck).\")\n}\n   // Prints \"Ryan is signed up!\"\n\n/// Conforming to the Equatable Protocol\n```\n\n* 本地类型继承自`Equatable`协议需要注意：\n  1. 对于一个`struct`类型，它的所有存储属性都需要遵循`Equatable`协议；\n  2. 对于一个`enum`类型，它的所有关联值都需要遵循`Equatable`协议；\n  3. 如果上述标准不符合，需要在扩展中实现`==`静态方法；\n例如：\n\n```\nclass StreetAddress {\n    let number: String\n    let street: String\n    let unit: String?\n    init(_ number: String, _ street: String, unit: String? = nil) {\n        self.number = number\n        self.street = street\n        self.unit = unit\n    }\n}\n\nextension StreetAddress: Equatable {\n    static func == (lhs: StreetAddress, rhs: StreetAddress) -> Bool {\n        return\n            lhs.number == rhs.number &&\n            lhs.street == rhs.street &&\n            lhs.unit == rhs.unit\n    }\n}\n\nlet addresses = [StreetAddress(\"1490\", \"Grove Street\"),\n                 StreetAddress(\"2119\", \"Maple Avenue\"),\n                 StreetAddress(\"1400\", \"16th Street\")]\nlet home = StreetAddress(\"1400\", \"16th Street\")\nprint(addresses[0] == home)\n// Prints \"false\"\nprint(addresses.contains(home))\n// Prints \"true\"\n```\n\n* 另外我在这个实现里面看到了以前数学课知识的身影：\n- `a == a` is always `true` (Reflexivity)   # 自反性\n- `a == b` implies `b == a` (Symmetry)  # 对称性\n- `a == b` and `b == c` implies `a == c` (Transitivity)  # 传递性\n所以我们定义的`==`(两对象相等)完全取决于我们自己实现的静态方法：\n\n```\nclass IntegerRef: Equatable {\n    let value: Int\n    init(_ value: Int) {\n        self.value = value\n    }\n    static func == (lhs: IntegerRef, rhs: IntegerRef) -> Bool {\n        return lhs.value == rhs.value\n    }\n}\nlet a = IntegerRef(100)\nlet b = IntegerRef(100)\nprint(a == a, a == b, separator: \", \")\n// Prints \"true, true\"\n```\n\n而不相等的定义则完全是，自实现的相等操作取反：\n\n```\nextension Equatable {\n  /// Returns a Boolean value indicating whether two values are not equal.\n  ///\n  /// Inequality is the inverse of equality. For any values `a` and `b`, `a != b`\n  /// implies that `a == b` is `false`.\n  ///\n  /// This is the default implementation of the not-equal-to operator (`!=`)\n  /// for any type that conforms to `Equatable`.\n  ///\n  /// - Parameters:\n  ///   - lhs: A value to compare.\n  ///   - rhs: Another value to compare.\n  @inlinable // FIXME(sil-serialize-all)\n  @_transparent\n  public static func != (lhs: Self, rhs: Self) -> Bool {\n    return !(lhs == rhs)\n  }\n}\n```\n这个实现是已经定义好的！！!\n\n* `==`与`===`的区别\n看一下这两者的区别：\n\n```\npublic protocol Equatable {\n  /// Returns a Boolean value indicating whether two values are equal.\n  ///\n  /// Equality is the inverse of inequality. For any values `a` and `b`,\n  /// `a == b` implies that `a != b` is `false`.\n  ///\n  /// - Parameters:\n  ///   - lhs: A value to compare.\n  ///   - rhs: Another value to compare.\n  static func == (lhs: Self, rhs: Self) -> Bool\n}\n```\n```\n@inlinable // FIXME(sil-serialize-all)\npublic func === (lhs: AnyObject?, rhs: AnyObject?) -> Bool {\n  switch (lhs, rhs) {\n  case let (l?, r?):\n    return ObjectIdentifier(l) == ObjectIdentifier(r)\n  case (nil, nil):\n    return true\n  default:\n    return false\n  }\n}\n```\n从以上可以看出，`==`只是由实现好的静态函数决定，而`===`则是可以判断两个对象是否完全相等，这有点像判断两个指针相等一样，同样，我们要注意，如果两个可选对象都是nil，则也是`===`的；\n\n3. 搞清楚两个问题\n\n* UTC 与 GMT\nUTC(Coordinated Universal Time)标准时间参照，协调时间时，世界标准时间;\nGMT(Greenwich Mean Time)时区，即格林尼治时间，位于本初子午线的标界处时间，世界计算时间和经度的起点，GMT是个时区，等同于世界时，所以GMT = UTC + 0，我们国家所在时间均以北京时间计算，北京位于东八区，所以时区为GMT + 8；\n\n* Locale\n 网上找了一圈，最后还是swift源码文档里给出的解释最靠谱：`Locale`封装了有关语言，文化和技术规范和标准的信息。由语言环境封装的信息示例包括，用于数字中小数点分隔符的符号以及格式化日期的方式。区域设置通常用于根据用户的习俗和偏好提供，格式化和解释信息。它们经常与格式化程序一起使用。虽然可以使用很多语言环境，但通常使用与当前用户关联的语言环境。\n语言环境跟系统的环境设置有关，会涉及到操作系统语言环境设置，个人理解就是一个国际化的东西。\n区域设置中的概念 LANGID & LCID：\n![LANGID & LCID](https://upload-images.jianshu.io/upload_images/1429775-04ff650284a51b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n","slug":"你一定不知道Swift源码怎么看？","published":1,"updated":"2018-05-04T10:24:04.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciok001n1v60l3au0yqd","content":"<p>我想你一定是在开玩笑。<br>源码怎么看，打开看呗！说这话的时候请收下我的轻蔑，哈哈。不过就这个问题我今天在知乎搜索了一通。不要问我为什么在知乎搜索，鬼知道知乎什么都有。<br>那么，请收下我的提问：<br><a id=\"more\"></a></p>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/38215419\" target=\"_blank\" rel=\"noopener\">如何阅读Swift源码</a></p>\n</blockquote>\n<p>知乎果然没有让我失望，结果教程如下；</p>\n<blockquote>\n<p><a href=\"http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/\" target=\"_blank\" rel=\"noopener\"># <a href=\"http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/\" title=\"如何阅读 Swift 标准库中的源码\" target=\"_blank\" rel=\"noopener\">如何阅读 Swift 标准库中的源码</a>\n</a></p>\n</blockquote>\n<p>顺便提一下，这次搜索还让我发现了一个比较不错的swift网站，有心的同学请收下：<a href=\"http://swift.gg\" target=\"_blank\" rel=\"noopener\">swift.gg</a></p>\n<p>于是今天搞了下源码的编译，并了解到一个叫做 <em>GYB</em> 的东西，这个东西今天先放一下。源碼編譯的過程無非就是用 <em>brew</em> 下了一些命令行軟件，然後使用 <em>build</em> 腳本跑一下過程，在此也不多說。但是今天的重點當然是我們要從源碼出發搞一些事情。<br>续：今天又build，发现也并没有得出什么重要的东西，只是把gyb文件生成为swift文件，其他过程不知道它经历了什么，对我想看源码没有任何作用，还跑了整整一个下午；对于只是想看代码的同学，还是用官网给出的gyb.py脚本做处理吧；</p>\n<ol>\n<li>hashable</li>\n</ol>\n<p>前两天写Dictionary时发现想用枚举做key，自定义一个Dictionary，value是#selector，但是在写的过程中发现说key值需要遵循hashable协议。可以看源码来理解一下。<br>首先要找到Hashable文件，发现swift的标准核心库被放在 <strong>stdlib/public/core</strong> 下，有一个 <strong>Hashable.swift</strong> 文件，打开文件先是一大段的描述，大体内容就是hashable协议作用的场景，以及给出了一个小例子；</p>\n<p>一个Hash类型，提供了一个 hashValue 的属性，它是一个整型常量， 如果有两个相同类型的a，b，如果 a == b，那么 a.hashValue == b.hashValue；但是反过来，如果两个hash值相同，并不表示a 就一定等于 b；<br>还有一点非常重要，就是在两次不同的程序执行中hash值并不保证相等，所以不要把hash值用在你的程序中；<br>Hashable协议可用于struct, enum, class，它继承于 Equatable，所以遵循Hashable协议需要同时实现Hashable协议方法，以及 Equatable 协议方法；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// A point in an x-y coordinate system.</span><br><span class=\"line\">    struct GridPoint &#123;</span><br><span class=\"line\">        var x: Int</span><br><span class=\"line\">        var y: Int</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     extension GridPoint: Hashable &#123;</span><br><span class=\"line\">         var hashValue: Int &#123;</span><br><span class=\"line\">            return x.hashValue ^ y.hashValue &amp;* 16777619</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        static func == (lhs: GridPoint, rhs: GridPoint) -&gt; Bool &#123;</span><br><span class=\"line\">            return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]</span><br><span class=\"line\">       let nextTap = GridPoint(x: 0, y: 1)</span><br><span class=\"line\">       if tappedPoints.contains(nextTap) &#123;</span><br><span class=\"line\">          print(&quot;Already tapped at (\\(nextTap.x), \\(nextTap.y)).&quot;)</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">          tappedPoints.insert(nextTap)</span><br><span class=\"line\">          print(&quot;New tap detected at (\\(nextTap.x), \\(nextTap.y)).&quot;)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">      // Prints &quot;New tap detected at (0, 1).&quot;)</span><br></pre></td></tr></table></figure>\n<p>在实现的代码里有一些奇怪的符号，暂时还有点摸不清头脑，有些是一些编译符号，大体能看懂点意思，但有些像<code>@_silgen_name(&quot;_swift_stdlib_Hashable_isEqual_indirect&quot;)</code>就完全看不懂，回头找人再请教；<br>这里还要说的一个就是一个<code>UnsafePointer&lt;T&gt;</code>:</p>\n<blockquote>\n<p>在 Swift 中，指针都使用一个特殊的类型来表示，那就是 UnsafePointer<t>。遵循了 Cocoa 的一贯不可变原则，UnsafePointer<t> 也是不可变的。当然对应地，它还有一个可变变体，UnsafeMutablePointer<t>。绝大部分时间里，C 中的指针都会被以这两种类型引入到 Swift 中：C 中 const 修饰的指针对应 UnsafePointer (最常见的应该就是 C 字符串的 const char * 了)，而其他可变的指针则对应 UnsafeMutablePointer。除此之外，Swift 中存在表示一组连续数据指针的 UnsafeBufferPointer<t>，表示非完整结构的不透明指针 COpaquePointer 等等。另外你可能已经注意到了，能够确定指向内容的指针类型都是泛型的 struct，我们可以通过这个泛型来对指针指向的类型进行约束以提供一定安全性。</t></t></t></t></p>\n</blockquote>\n<p>需要具体了解的看这篇：<a href=\"https://onevcat.com/2015/01/swift-pointer/\" target=\"_blank\" rel=\"noopener\">UnsafePointe<t></t></a></p>\n<p>顺便吐槽句哈，apple的代码也还有这种东西，也不知道是修改过的没有；<br><img src=\"https://upload-images.jianshu.io/upload_images/1429775-225ee3ef5a38e747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FIXME\"></p>\n<ol start=\"2\">\n<li>Equatable</li>\n</ol>\n<ul>\n<li>它是一种可用于值比较的类型；</li>\n<li>在序列和集合操作中，可以将一个遵循了<code>Equatable</code>协议的对象传递给<code>contaions(_:)</code>方法，来确定是否包含，用法如下：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> students = [<span class=\"string\">\"Nora\"</span>, <span class=\"string\">\"Fern\"</span>, <span class=\"string\">\"Ryan\"</span>, <span class=\"string\">\"Rainer\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nameToCheck = <span class=\"string\">\"Ryan\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> students.<span class=\"built_in\">contains</span>(nameToCheck) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(nameToCheck)</span> is signed up!\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"No record of <span class=\"subst\">\\(nameToCheck)</span>.\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   <span class=\"comment\">// Prints \"Ryan is signed up!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Conforming to the Equatable Protocol</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>本地类型继承自<code>Equatable</code>协议需要注意：<ol>\n<li>对于一个<code>struct</code>类型，它的所有存储属性都需要遵循<code>Equatable</code>协议；</li>\n<li>对于一个<code>enum</code>类型，它的所有关联值都需要遵循<code>Equatable</code>协议；</li>\n<li>如果上述标准不符合，需要在扩展中实现<code>==</code>静态方法；<br>例如：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StreetAddress &#123;</span><br><span class=\"line\">    let number: String</span><br><span class=\"line\">    let street: String</span><br><span class=\"line\">    let unit: String?</span><br><span class=\"line\">    init(_ number: String, _ street: String, unit: String? = nil) &#123;</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\">        self.street = street</span><br><span class=\"line\">        self.unit = unit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">extension StreetAddress: Equatable &#123;</span><br><span class=\"line\">    static func == (lhs: StreetAddress, rhs: StreetAddress) -&gt; Bool &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">            lhs.number == rhs.number &amp;&amp;</span><br><span class=\"line\">            lhs.street == rhs.street &amp;&amp;</span><br><span class=\"line\">            lhs.unit == rhs.unit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let addresses = [StreetAddress(&quot;1490&quot;, &quot;Grove Street&quot;),</span><br><span class=\"line\">                 StreetAddress(&quot;2119&quot;, &quot;Maple Avenue&quot;),</span><br><span class=\"line\">                 StreetAddress(&quot;1400&quot;, &quot;16th Street&quot;)]</span><br><span class=\"line\">let home = StreetAddress(&quot;1400&quot;, &quot;16th Street&quot;)</span><br><span class=\"line\">print(addresses[0] == home)</span><br><span class=\"line\">// Prints &quot;false&quot;</span><br><span class=\"line\">print(addresses.contains(home))</span><br><span class=\"line\">// Prints &quot;true&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>另外我在这个实现里面看到了以前数学课知识的身影：</li>\n</ul>\n<ul>\n<li><code>a == a</code> is always <code>true</code> (Reflexivity)   # 自反性</li>\n<li><code>a == b</code> implies <code>b == a</code> (Symmetry)  # 对称性</li>\n<li><code>a == b</code> and <code>b == c</code> implies <code>a == c</code> (Transitivity)  # 传递性<br>所以我们定义的<code>==</code>(两对象相等)完全取决于我们自己实现的静态方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class IntegerRef: Equatable &#123;</span><br><span class=\"line\">    let value: Int</span><br><span class=\"line\">    init(_ value: Int) &#123;</span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static func == (lhs: IntegerRef, rhs: IntegerRef) -&gt; Bool &#123;</span><br><span class=\"line\">        return lhs.value == rhs.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let a = IntegerRef(100)</span><br><span class=\"line\">let b = IntegerRef(100)</span><br><span class=\"line\">print(a == a, a == b, separator: &quot;, &quot;)</span><br><span class=\"line\">// Prints &quot;true, true&quot;</span><br></pre></td></tr></table></figure>\n<p>而不相等的定义则完全是，自实现的相等操作取反：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Equatable &#123;</span><br><span class=\"line\">  /// Returns a Boolean value indicating whether two values are not equal.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// Inequality is the inverse of equality. For any values `a` and `b`, `a != b`</span><br><span class=\"line\">  /// implies that `a == b` is `false`.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// This is the default implementation of the not-equal-to operator (`!=`)</span><br><span class=\"line\">  /// for any type that conforms to `Equatable`.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// - Parameters:</span><br><span class=\"line\">  ///   - lhs: A value to compare.</span><br><span class=\"line\">  ///   - rhs: Another value to compare.</span><br><span class=\"line\">  @inlinable // FIXME(sil-serialize-all)</span><br><span class=\"line\">  @_transparent</span><br><span class=\"line\">  public static func != (lhs: Self, rhs: Self) -&gt; Bool &#123;</span><br><span class=\"line\">    return !(lhs == rhs)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个实现是已经定义好的！！!</p>\n<ul>\n<li><code>==</code>与<code>===</code>的区别<br>看一下这两者的区别：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Equatable &#123;</span><br><span class=\"line\">  /// Returns a Boolean value indicating whether two values are equal.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// Equality is the inverse of inequality. For any values `a` and `b`,</span><br><span class=\"line\">  /// `a == b` implies that `a != b` is `false`.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// - Parameters:</span><br><span class=\"line\">  ///   - lhs: A value to compare.</span><br><span class=\"line\">  ///   - rhs: Another value to compare.</span><br><span class=\"line\">  static func == (lhs: Self, rhs: Self) -&gt; Bool</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@inlinable // FIXME(sil-serialize-all)</span><br><span class=\"line\">public func === (lhs: AnyObject?, rhs: AnyObject?) -&gt; Bool &#123;</span><br><span class=\"line\">  switch (lhs, rhs) &#123;</span><br><span class=\"line\">  case let (l?, r?):</span><br><span class=\"line\">    return ObjectIdentifier(l) == ObjectIdentifier(r)</span><br><span class=\"line\">  case (nil, nil):</span><br><span class=\"line\">    return true</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    return false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从以上可以看出，<code>==</code>只是由实现好的静态函数决定，而<code>===</code>则是可以判断两个对象是否完全相等，这有点像判断两个指针相等一样，同样，我们要注意，如果两个可选对象都是nil，则也是<code>===</code>的；</p>\n<ol start=\"3\">\n<li>搞清楚两个问题</li>\n</ol>\n<ul>\n<li><p>UTC 与 GMT<br>UTC(Coordinated Universal Time)标准时间参照，协调时间时，世界标准时间;<br>GMT(Greenwich Mean Time)时区，即格林尼治时间，位于本初子午线的标界处时间，世界计算时间和经度的起点，GMT是个时区，等同于世界时，所以GMT = UTC + 0，我们国家所在时间均以北京时间计算，北京位于东八区，所以时区为GMT + 8；</p>\n</li>\n<li><p>Locale<br>网上找了一圈，最后还是swift源码文档里给出的解释最靠谱：<code>Locale</code>封装了有关语言，文化和技术规范和标准的信息。由语言环境封装的信息示例包括，用于数字中小数点分隔符的符号以及格式化日期的方式。区域设置通常用于根据用户的习俗和偏好提供，格式化和解释信息。它们经常与格式化程序一起使用。虽然可以使用很多语言环境，但通常使用与当前用户关联的语言环境。<br>语言环境跟系统的环境设置有关，会涉及到操作系统语言环境设置，个人理解就是一个国际化的东西。<br>区域设置中的概念 LANGID &amp; LCID：<br><img src=\"https://upload-images.jianshu.io/upload_images/1429775-04ff650284a51b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LANGID &amp; LCID\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>我想你一定是在开玩笑。<br>源码怎么看，打开看呗！说这话的时候请收下我的轻蔑，哈哈。不过就这个问题我今天在知乎搜索了一通。不要问我为什么在知乎搜索，鬼知道知乎什么都有。<br>那么，请收下我的提问：<br>","more":"</p>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/38215419\" target=\"_blank\" rel=\"noopener\">如何阅读Swift源码</a></p>\n</blockquote>\n<p>知乎果然没有让我失望，结果教程如下；</p>\n<blockquote>\n<p><a href=\"http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/\" target=\"_blank\" rel=\"noopener\"># <a href=\"http://swift.gg/2016/12/30/how-to-read-the-swift-standard-libray-source/\" title=\"如何阅读 Swift 标准库中的源码\" target=\"_blank\" rel=\"noopener\">如何阅读 Swift 标准库中的源码</a>\n</a></p>\n</blockquote>\n<p>顺便提一下，这次搜索还让我发现了一个比较不错的swift网站，有心的同学请收下：<a href=\"http://swift.gg\" target=\"_blank\" rel=\"noopener\">swift.gg</a></p>\n<p>于是今天搞了下源码的编译，并了解到一个叫做 <em>GYB</em> 的东西，这个东西今天先放一下。源碼編譯的過程無非就是用 <em>brew</em> 下了一些命令行軟件，然後使用 <em>build</em> 腳本跑一下過程，在此也不多說。但是今天的重點當然是我們要從源碼出發搞一些事情。<br>续：今天又build，发现也并没有得出什么重要的东西，只是把gyb文件生成为swift文件，其他过程不知道它经历了什么，对我想看源码没有任何作用，还跑了整整一个下午；对于只是想看代码的同学，还是用官网给出的gyb.py脚本做处理吧；</p>\n<ol>\n<li>hashable</li>\n</ol>\n<p>前两天写Dictionary时发现想用枚举做key，自定义一个Dictionary，value是#selector，但是在写的过程中发现说key值需要遵循hashable协议。可以看源码来理解一下。<br>首先要找到Hashable文件，发现swift的标准核心库被放在 <strong>stdlib/public/core</strong> 下，有一个 <strong>Hashable.swift</strong> 文件，打开文件先是一大段的描述，大体内容就是hashable协议作用的场景，以及给出了一个小例子；</p>\n<p>一个Hash类型，提供了一个 hashValue 的属性，它是一个整型常量， 如果有两个相同类型的a，b，如果 a == b，那么 a.hashValue == b.hashValue；但是反过来，如果两个hash值相同，并不表示a 就一定等于 b；<br>还有一点非常重要，就是在两次不同的程序执行中hash值并不保证相等，所以不要把hash值用在你的程序中；<br>Hashable协议可用于struct, enum, class，它继承于 Equatable，所以遵循Hashable协议需要同时实现Hashable协议方法，以及 Equatable 协议方法；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// A point in an x-y coordinate system.</span><br><span class=\"line\">    struct GridPoint &#123;</span><br><span class=\"line\">        var x: Int</span><br><span class=\"line\">        var y: Int</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     extension GridPoint: Hashable &#123;</span><br><span class=\"line\">         var hashValue: Int &#123;</span><br><span class=\"line\">            return x.hashValue ^ y.hashValue &amp;* 16777619</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        static func == (lhs: GridPoint, rhs: GridPoint) -&gt; Bool &#123;</span><br><span class=\"line\">            return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]</span><br><span class=\"line\">       let nextTap = GridPoint(x: 0, y: 1)</span><br><span class=\"line\">       if tappedPoints.contains(nextTap) &#123;</span><br><span class=\"line\">          print(&quot;Already tapped at (\\(nextTap.x), \\(nextTap.y)).&quot;)</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">          tappedPoints.insert(nextTap)</span><br><span class=\"line\">          print(&quot;New tap detected at (\\(nextTap.x), \\(nextTap.y)).&quot;)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">      // Prints &quot;New tap detected at (0, 1).&quot;)</span><br></pre></td></tr></table></figure>\n<p>在实现的代码里有一些奇怪的符号，暂时还有点摸不清头脑，有些是一些编译符号，大体能看懂点意思，但有些像<code>@_silgen_name(&quot;_swift_stdlib_Hashable_isEqual_indirect&quot;)</code>就完全看不懂，回头找人再请教；<br>这里还要说的一个就是一个<code>UnsafePointer&lt;T&gt;</code>:</p>\n<blockquote>\n<p>在 Swift 中，指针都使用一个特殊的类型来表示，那就是 UnsafePointer<t>。遵循了 Cocoa 的一贯不可变原则，UnsafePointer<t> 也是不可变的。当然对应地，它还有一个可变变体，UnsafeMutablePointer<t>。绝大部分时间里，C 中的指针都会被以这两种类型引入到 Swift 中：C 中 const 修饰的指针对应 UnsafePointer (最常见的应该就是 C 字符串的 const char * 了)，而其他可变的指针则对应 UnsafeMutablePointer。除此之外，Swift 中存在表示一组连续数据指针的 UnsafeBufferPointer<t>，表示非完整结构的不透明指针 COpaquePointer 等等。另外你可能已经注意到了，能够确定指向内容的指针类型都是泛型的 struct，我们可以通过这个泛型来对指针指向的类型进行约束以提供一定安全性。</t></t></t></t></p>\n</blockquote>\n<p>需要具体了解的看这篇：<a href=\"https://onevcat.com/2015/01/swift-pointer/\" target=\"_blank\" rel=\"noopener\">UnsafePointe<t></t></a></p>\n<p>顺便吐槽句哈，apple的代码也还有这种东西，也不知道是修改过的没有；<br><img src=\"https://upload-images.jianshu.io/upload_images/1429775-225ee3ef5a38e747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FIXME\"></p>\n<ol start=\"2\">\n<li>Equatable</li>\n</ol>\n<ul>\n<li>它是一种可用于值比较的类型；</li>\n<li>在序列和集合操作中，可以将一个遵循了<code>Equatable</code>协议的对象传递给<code>contaions(_:)</code>方法，来确定是否包含，用法如下：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> students = [<span class=\"string\">\"Nora\"</span>, <span class=\"string\">\"Fern\"</span>, <span class=\"string\">\"Ryan\"</span>, <span class=\"string\">\"Rainer\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nameToCheck = <span class=\"string\">\"Ryan\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> students.<span class=\"built_in\">contains</span>(nameToCheck) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(nameToCheck)</span> is signed up!\"</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"No record of <span class=\"subst\">\\(nameToCheck)</span>.\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   <span class=\"comment\">// Prints \"Ryan is signed up!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Conforming to the Equatable Protocol</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>本地类型继承自<code>Equatable</code>协议需要注意：<ol>\n<li>对于一个<code>struct</code>类型，它的所有存储属性都需要遵循<code>Equatable</code>协议；</li>\n<li>对于一个<code>enum</code>类型，它的所有关联值都需要遵循<code>Equatable</code>协议；</li>\n<li>如果上述标准不符合，需要在扩展中实现<code>==</code>静态方法；<br>例如：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StreetAddress &#123;</span><br><span class=\"line\">    let number: String</span><br><span class=\"line\">    let street: String</span><br><span class=\"line\">    let unit: String?</span><br><span class=\"line\">    init(_ number: String, _ street: String, unit: String? = nil) &#123;</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\">        self.street = street</span><br><span class=\"line\">        self.unit = unit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">extension StreetAddress: Equatable &#123;</span><br><span class=\"line\">    static func == (lhs: StreetAddress, rhs: StreetAddress) -&gt; Bool &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">            lhs.number == rhs.number &amp;&amp;</span><br><span class=\"line\">            lhs.street == rhs.street &amp;&amp;</span><br><span class=\"line\">            lhs.unit == rhs.unit</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let addresses = [StreetAddress(&quot;1490&quot;, &quot;Grove Street&quot;),</span><br><span class=\"line\">                 StreetAddress(&quot;2119&quot;, &quot;Maple Avenue&quot;),</span><br><span class=\"line\">                 StreetAddress(&quot;1400&quot;, &quot;16th Street&quot;)]</span><br><span class=\"line\">let home = StreetAddress(&quot;1400&quot;, &quot;16th Street&quot;)</span><br><span class=\"line\">print(addresses[0] == home)</span><br><span class=\"line\">// Prints &quot;false&quot;</span><br><span class=\"line\">print(addresses.contains(home))</span><br><span class=\"line\">// Prints &quot;true&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>另外我在这个实现里面看到了以前数学课知识的身影：</li>\n</ul>\n<ul>\n<li><code>a == a</code> is always <code>true</code> (Reflexivity)   # 自反性</li>\n<li><code>a == b</code> implies <code>b == a</code> (Symmetry)  # 对称性</li>\n<li><code>a == b</code> and <code>b == c</code> implies <code>a == c</code> (Transitivity)  # 传递性<br>所以我们定义的<code>==</code>(两对象相等)完全取决于我们自己实现的静态方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class IntegerRef: Equatable &#123;</span><br><span class=\"line\">    let value: Int</span><br><span class=\"line\">    init(_ value: Int) &#123;</span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static func == (lhs: IntegerRef, rhs: IntegerRef) -&gt; Bool &#123;</span><br><span class=\"line\">        return lhs.value == rhs.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let a = IntegerRef(100)</span><br><span class=\"line\">let b = IntegerRef(100)</span><br><span class=\"line\">print(a == a, a == b, separator: &quot;, &quot;)</span><br><span class=\"line\">// Prints &quot;true, true&quot;</span><br></pre></td></tr></table></figure>\n<p>而不相等的定义则完全是，自实现的相等操作取反：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Equatable &#123;</span><br><span class=\"line\">  /// Returns a Boolean value indicating whether two values are not equal.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// Inequality is the inverse of equality. For any values `a` and `b`, `a != b`</span><br><span class=\"line\">  /// implies that `a == b` is `false`.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// This is the default implementation of the not-equal-to operator (`!=`)</span><br><span class=\"line\">  /// for any type that conforms to `Equatable`.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// - Parameters:</span><br><span class=\"line\">  ///   - lhs: A value to compare.</span><br><span class=\"line\">  ///   - rhs: Another value to compare.</span><br><span class=\"line\">  @inlinable // FIXME(sil-serialize-all)</span><br><span class=\"line\">  @_transparent</span><br><span class=\"line\">  public static func != (lhs: Self, rhs: Self) -&gt; Bool &#123;</span><br><span class=\"line\">    return !(lhs == rhs)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个实现是已经定义好的！！!</p>\n<ul>\n<li><code>==</code>与<code>===</code>的区别<br>看一下这两者的区别：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Equatable &#123;</span><br><span class=\"line\">  /// Returns a Boolean value indicating whether two values are equal.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// Equality is the inverse of inequality. For any values `a` and `b`,</span><br><span class=\"line\">  /// `a == b` implies that `a != b` is `false`.</span><br><span class=\"line\">  ///</span><br><span class=\"line\">  /// - Parameters:</span><br><span class=\"line\">  ///   - lhs: A value to compare.</span><br><span class=\"line\">  ///   - rhs: Another value to compare.</span><br><span class=\"line\">  static func == (lhs: Self, rhs: Self) -&gt; Bool</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@inlinable // FIXME(sil-serialize-all)</span><br><span class=\"line\">public func === (lhs: AnyObject?, rhs: AnyObject?) -&gt; Bool &#123;</span><br><span class=\"line\">  switch (lhs, rhs) &#123;</span><br><span class=\"line\">  case let (l?, r?):</span><br><span class=\"line\">    return ObjectIdentifier(l) == ObjectIdentifier(r)</span><br><span class=\"line\">  case (nil, nil):</span><br><span class=\"line\">    return true</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    return false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从以上可以看出，<code>==</code>只是由实现好的静态函数决定，而<code>===</code>则是可以判断两个对象是否完全相等，这有点像判断两个指针相等一样，同样，我们要注意，如果两个可选对象都是nil，则也是<code>===</code>的；</p>\n<ol start=\"3\">\n<li>搞清楚两个问题</li>\n</ol>\n<ul>\n<li><p>UTC 与 GMT<br>UTC(Coordinated Universal Time)标准时间参照，协调时间时，世界标准时间;<br>GMT(Greenwich Mean Time)时区，即格林尼治时间，位于本初子午线的标界处时间，世界计算时间和经度的起点，GMT是个时区，等同于世界时，所以GMT = UTC + 0，我们国家所在时间均以北京时间计算，北京位于东八区，所以时区为GMT + 8；</p>\n</li>\n<li><p>Locale<br>网上找了一圈，最后还是swift源码文档里给出的解释最靠谱：<code>Locale</code>封装了有关语言，文化和技术规范和标准的信息。由语言环境封装的信息示例包括，用于数字中小数点分隔符的符号以及格式化日期的方式。区域设置通常用于根据用户的习俗和偏好提供，格式化和解释信息。它们经常与格式化程序一起使用。虽然可以使用很多语言环境，但通常使用与当前用户关联的语言环境。<br>语言环境跟系统的环境设置有关，会涉及到操作系统语言环境设置，个人理解就是一个国际化的东西。<br>区域设置中的概念 LANGID &amp; LCID：<br><img src=\"https://upload-images.jianshu.io/upload_images/1429775-04ff650284a51b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LANGID &amp; LCID\"></p>\n</li>\n</ul>"},{"title":"关于wow游戏插件制作之前的几件事","date":"2016-08-08T07:29:00.000Z","_content":"\n如果你是一个游戏迷，或者说魔兽世界迷，那么你一定不会对插件这个东西感觉到陌生；如果你是一个用代码写人生的家伙，那么你一定要接触一下Lua这门语言；如果你只是对魔兽插件表示好奇，那么请保持这种好奇的态度。我们今天要说的，就是魔兽世界游戏插件的事情。\n<!-- more -->\n\n那么在做插件之前，你得要了解几件事情。\n\n## 下载游戏\n\n魔兽世界从2004年在中国登录已经有十多年的历史，迭代过N个版本，客户端也由最初的不到10个G发展到现在的40多个G。然而下载游戏时，你除了要考虑到你硬盘是否够用，下载的问题可以交给战网客户端，暴雪自己的线路绝对可以保证你在一个晚上就下载下来整个客户端。这里我要提醒下各位，你最好将你的游戏下载到一个移动硬盘里，毕竟客户端体积较大，下载到硬盘里那么你就可以带着硬盘随时调试或者玩魔兽啦，而且USB3.0完全可以满足你硬盘的读写速度。\n\n那么我们要提到的就是战网客户端了。战网是暴雪为方便玩家对其游戏的管理制作的一个游戏管理客户端，在战网上你可以获取到所有暴雪官方游戏客户端。在战网下载页面，我们可以下载到各种语言的战网。同时要提一下，国服的战网是一个封闭的环境，如果我们下载国服的客户端，只能够登录国服的帐号，也就是在中国大陆申请的帐号，不包括台湾香港的帐号。而美国战网的客户端则是一个开放的环境，可以登录任何地区的帐号。\n\n我们在进行插件调试的过程中，会遇到插件本地化的问题，也就是如果你用中文进行插件制作，中途会遇到时不知明的问题，所以，我们强烈建议下载美服的客户端，下载纯正的美国魔兽世界客户端，之后再进行汉化，这样一来，我们省去了插件制作中中文编码导致插件错误的问题。后期我们会单独进行插件的汉化。\n\n接下来就是下载美国战网客户端，[下载地址](http://us.battle.net/en/)，你可能会需要用到vpn翻墙下载，可能。下载下来我们安装到电脑上。这个过程可能遇到的问题是，如果你第一次没有安装成功，那么你在接下来的安装过程中可能会遇到进度条卡在中间一直不动的情况，而且等了很久之后仍然是一动也不动。这个时候我们就不要再等它出现奇迹了，你要做的是关掉它，找到你的用户目录，找到你用户目录下关于*Battle.net*以及*Blizzard*的缓存，这些目录有可能是隐藏掉的，上网找一下如何让它们显现出来的方法，如果你找不到这些目录，那你仍然可以上网找一下，这里就不再贴目录了，windows和mac下的目录不一样，但是大致都差不多；找到这些文件，不要犹豫全部删掉它，一点不剩。然后重装你的战网。\n\n接下来安装完战网客户端之后就要安装游戏了，不过我们先不要安装游戏，首先去注册一个美服的战网让我们可以登录美服，注册的时候我们选台湾地区，因为是实名的，会让我们输入身份证号。\n\n帐号有了之后，我们并不马上打开客户端，打开你的战网客户端配置文件目录，过程如下：\n\nwindows下，打开C盘(系统盘)，用户，你的机器名字，找到AppData；AppData这个文件默认是隐藏的，所以你需要在文件夹选项里点击查看，勾选显示 隐藏文件、文件夹，这样就可以看到AppData了！点击Roaming，找到Battle.net，如果很多可以按快捷键B，在用记事本打开Battle.net；\n\n在mac下，打开finder，command+shift+g打开，复制`~/Library/Application Support/Battle.net`，粘贴到输入框，用文本软件打开*Battle.net.config*文件；\n\n接下来修改修改Client语法下的AllowedRegions区域，将AllowedRegions区域加入CN;US;EU;KR ，Regions就是你的登录可以选择的区域，CN就是国服;US美服;EU欧服;KR韩/台服。(根据自己的喜好选择对应的区域)\n\nLocales是你的登录器语言，加入zhCN就是简体中文版登录器;\n\n```\n\"Client\":\n\n{\n\n　　\"AllowedRegions\": \"CN;US;EU;KR\",\n　　\"AllowedLocales\": \n　　\"zhCN;deDE;enGB;enUS;esMX;esES;frFR;itIT;plPL;ptBR;ruRU;koKR;zhTW\"\n\n}\n\n```\n\n客户端测试及语言设置,Config.wtf文件修改为：(此项也可以不用修改)\n\n```\nSET portal \"US-test\"\n\nSET textLocale \"zhCN\"\n\nSET audioLocale \"enUS\"\n\nSET installLocale \"enUS\"\n```\n\n修改完成后进入客户端，选择北美地区，登入战网，之后点安装，战网就会下载美服客户端。下载完成后如果要登入国服帐号，选择中国地区，客户端会自动下载汉化更新，这样你的战网就可以既登录美服，也可登录国服了。\n\n## 游戏语言\n\n毫无疑问，接下来要说的就是插件的语言了。魔兽世界使用Lua配合xml对插件进行开发，游戏逻辑使用Lua，界面使用xml。做过Cocos2dx的朋友应该使用过Lua进行过快速开发，做为一个小巧的脚本语言，它在游戏开发中还是很有市场的。接下来我们要做的就是在电脑上安装Lua；\n\nlua官方网站上有详细的安装过程，英文好的同学可以自行看原文进行操作。[lua.org](https://www.lua.org/)\n\n下载lua，[download](https://www.lua.org/ftp/)，页面显示了lua的各个版本，建议下载最新版本。下载后解压缩会生成一个目录。\n\n用终端进入到目录里，具体操作就是在终端里输入cd,中间加个空格，然后把你目录的路径复制到那里（把文件往终端里一拉就有了）。你不知道widows的终端怎么进？win+R，输入cmd，就出来了。\n\n接下来，终端输入`make xxx install`，这里的xxx，在下面选：\n\n```\naix bsd c89 freebsd generic linux macosx mingw posix solaris\n```\n\n\nwindows下建议下载一个Lua for windows的软件，不认为windows下用终端要方便好多。\n\n安装完成后在终端直接敲lua，看看安装是否成功。\n\n安装完成后我们就可以在终端进行lua的学习了，语法学习是一个枯燥的过程，建议找本书照着例子多敲，这里我们推荐书《Programming in Lua》，网上有中文的翻译，想快速上手写的话可以看这篇帖子，先大致了解下lua的语法，[Lua学习](http://bbs.ngacn.cc/read.php?tid=6621402)。\n\n## 插件库\n\n我们魔兽的所有插件都会以文件夹的形式保存在*World of Warcraft/Interface/AddOns*下，我们以后做的插件放在这里才会被系统识别。不过本篇我们不说插件制作的事情，这里只是告诉读者，这里是我们进入魔兽插件开发的入口。\n\n我们要用到的插件库叫做wowace,ACE3库以及其他的函数库是目前大多数插件必备的内置库，ACE3库集成了魔兽世界插件中经常用到功能的和函数，极大方便了插件作者提高开发效率。wowace现在更新到了3版本，且各个版本之间不向下向下兼容，所以你最好选择一个稳定的版本做开发。\n\n这里我们给出库的下载地址，[Ace3](http://www.wowace.com/addons/ace3/files/)以及API文档，[API](http://wow.gamepedia.com/WelcomeHome_-_Your_first_Ace3_Addon)。\n\n\n## 与你的朋友合作\n\n[https://www.wowace.com](https://www.wowace.com)上有wowace版本控制系统，注册一个帐号，你可以在svn或者git上与你的朋友一起写插件。\n\n## 发布相关\n\n[https://mods.curse.com](https://mods.curse.com)这个网站可以把你的插件发布到平台上，另外你也可以在这里下载别人的插件进行学习。\n\n\n大致能想到的现在就是这么多，我也是刚刚开始做，如果遇到问题，我们可以交流。我还会将我做插件的过程记录下来，同大家一同学习。","source":"_posts/关于wow游戏插件制作之前的几件事.md","raw":"title: 关于wow游戏插件制作之前的几件事\ndate: 2016-08-08 15:29:00\ncategories: wower\ntags: [wow, lua, addons]\n-----------\n\n如果你是一个游戏迷，或者说魔兽世界迷，那么你一定不会对插件这个东西感觉到陌生；如果你是一个用代码写人生的家伙，那么你一定要接触一下Lua这门语言；如果你只是对魔兽插件表示好奇，那么请保持这种好奇的态度。我们今天要说的，就是魔兽世界游戏插件的事情。\n<!-- more -->\n\n那么在做插件之前，你得要了解几件事情。\n\n## 下载游戏\n\n魔兽世界从2004年在中国登录已经有十多年的历史，迭代过N个版本，客户端也由最初的不到10个G发展到现在的40多个G。然而下载游戏时，你除了要考虑到你硬盘是否够用，下载的问题可以交给战网客户端，暴雪自己的线路绝对可以保证你在一个晚上就下载下来整个客户端。这里我要提醒下各位，你最好将你的游戏下载到一个移动硬盘里，毕竟客户端体积较大，下载到硬盘里那么你就可以带着硬盘随时调试或者玩魔兽啦，而且USB3.0完全可以满足你硬盘的读写速度。\n\n那么我们要提到的就是战网客户端了。战网是暴雪为方便玩家对其游戏的管理制作的一个游戏管理客户端，在战网上你可以获取到所有暴雪官方游戏客户端。在战网下载页面，我们可以下载到各种语言的战网。同时要提一下，国服的战网是一个封闭的环境，如果我们下载国服的客户端，只能够登录国服的帐号，也就是在中国大陆申请的帐号，不包括台湾香港的帐号。而美国战网的客户端则是一个开放的环境，可以登录任何地区的帐号。\n\n我们在进行插件调试的过程中，会遇到插件本地化的问题，也就是如果你用中文进行插件制作，中途会遇到时不知明的问题，所以，我们强烈建议下载美服的客户端，下载纯正的美国魔兽世界客户端，之后再进行汉化，这样一来，我们省去了插件制作中中文编码导致插件错误的问题。后期我们会单独进行插件的汉化。\n\n接下来就是下载美国战网客户端，[下载地址](http://us.battle.net/en/)，你可能会需要用到vpn翻墙下载，可能。下载下来我们安装到电脑上。这个过程可能遇到的问题是，如果你第一次没有安装成功，那么你在接下来的安装过程中可能会遇到进度条卡在中间一直不动的情况，而且等了很久之后仍然是一动也不动。这个时候我们就不要再等它出现奇迹了，你要做的是关掉它，找到你的用户目录，找到你用户目录下关于*Battle.net*以及*Blizzard*的缓存，这些目录有可能是隐藏掉的，上网找一下如何让它们显现出来的方法，如果你找不到这些目录，那你仍然可以上网找一下，这里就不再贴目录了，windows和mac下的目录不一样，但是大致都差不多；找到这些文件，不要犹豫全部删掉它，一点不剩。然后重装你的战网。\n\n接下来安装完战网客户端之后就要安装游戏了，不过我们先不要安装游戏，首先去注册一个美服的战网让我们可以登录美服，注册的时候我们选台湾地区，因为是实名的，会让我们输入身份证号。\n\n帐号有了之后，我们并不马上打开客户端，打开你的战网客户端配置文件目录，过程如下：\n\nwindows下，打开C盘(系统盘)，用户，你的机器名字，找到AppData；AppData这个文件默认是隐藏的，所以你需要在文件夹选项里点击查看，勾选显示 隐藏文件、文件夹，这样就可以看到AppData了！点击Roaming，找到Battle.net，如果很多可以按快捷键B，在用记事本打开Battle.net；\n\n在mac下，打开finder，command+shift+g打开，复制`~/Library/Application Support/Battle.net`，粘贴到输入框，用文本软件打开*Battle.net.config*文件；\n\n接下来修改修改Client语法下的AllowedRegions区域，将AllowedRegions区域加入CN;US;EU;KR ，Regions就是你的登录可以选择的区域，CN就是国服;US美服;EU欧服;KR韩/台服。(根据自己的喜好选择对应的区域)\n\nLocales是你的登录器语言，加入zhCN就是简体中文版登录器;\n\n```\n\"Client\":\n\n{\n\n　　\"AllowedRegions\": \"CN;US;EU;KR\",\n　　\"AllowedLocales\": \n　　\"zhCN;deDE;enGB;enUS;esMX;esES;frFR;itIT;plPL;ptBR;ruRU;koKR;zhTW\"\n\n}\n\n```\n\n客户端测试及语言设置,Config.wtf文件修改为：(此项也可以不用修改)\n\n```\nSET portal \"US-test\"\n\nSET textLocale \"zhCN\"\n\nSET audioLocale \"enUS\"\n\nSET installLocale \"enUS\"\n```\n\n修改完成后进入客户端，选择北美地区，登入战网，之后点安装，战网就会下载美服客户端。下载完成后如果要登入国服帐号，选择中国地区，客户端会自动下载汉化更新，这样你的战网就可以既登录美服，也可登录国服了。\n\n## 游戏语言\n\n毫无疑问，接下来要说的就是插件的语言了。魔兽世界使用Lua配合xml对插件进行开发，游戏逻辑使用Lua，界面使用xml。做过Cocos2dx的朋友应该使用过Lua进行过快速开发，做为一个小巧的脚本语言，它在游戏开发中还是很有市场的。接下来我们要做的就是在电脑上安装Lua；\n\nlua官方网站上有详细的安装过程，英文好的同学可以自行看原文进行操作。[lua.org](https://www.lua.org/)\n\n下载lua，[download](https://www.lua.org/ftp/)，页面显示了lua的各个版本，建议下载最新版本。下载后解压缩会生成一个目录。\n\n用终端进入到目录里，具体操作就是在终端里输入cd,中间加个空格，然后把你目录的路径复制到那里（把文件往终端里一拉就有了）。你不知道widows的终端怎么进？win+R，输入cmd，就出来了。\n\n接下来，终端输入`make xxx install`，这里的xxx，在下面选：\n\n```\naix bsd c89 freebsd generic linux macosx mingw posix solaris\n```\n\n\nwindows下建议下载一个Lua for windows的软件，不认为windows下用终端要方便好多。\n\n安装完成后在终端直接敲lua，看看安装是否成功。\n\n安装完成后我们就可以在终端进行lua的学习了，语法学习是一个枯燥的过程，建议找本书照着例子多敲，这里我们推荐书《Programming in Lua》，网上有中文的翻译，想快速上手写的话可以看这篇帖子，先大致了解下lua的语法，[Lua学习](http://bbs.ngacn.cc/read.php?tid=6621402)。\n\n## 插件库\n\n我们魔兽的所有插件都会以文件夹的形式保存在*World of Warcraft/Interface/AddOns*下，我们以后做的插件放在这里才会被系统识别。不过本篇我们不说插件制作的事情，这里只是告诉读者，这里是我们进入魔兽插件开发的入口。\n\n我们要用到的插件库叫做wowace,ACE3库以及其他的函数库是目前大多数插件必备的内置库，ACE3库集成了魔兽世界插件中经常用到功能的和函数，极大方便了插件作者提高开发效率。wowace现在更新到了3版本，且各个版本之间不向下向下兼容，所以你最好选择一个稳定的版本做开发。\n\n这里我们给出库的下载地址，[Ace3](http://www.wowace.com/addons/ace3/files/)以及API文档，[API](http://wow.gamepedia.com/WelcomeHome_-_Your_first_Ace3_Addon)。\n\n\n## 与你的朋友合作\n\n[https://www.wowace.com](https://www.wowace.com)上有wowace版本控制系统，注册一个帐号，你可以在svn或者git上与你的朋友一起写插件。\n\n## 发布相关\n\n[https://mods.curse.com](https://mods.curse.com)这个网站可以把你的插件发布到平台上，另外你也可以在这里下载别人的插件进行学习。\n\n\n大致能想到的现在就是这么多，我也是刚刚开始做，如果遇到问题，我们可以交流。我还会将我做插件的过程记录下来，同大家一同学习。","slug":"关于wow游戏插件制作之前的几件事","published":1,"updated":"2018-05-04T10:24:00.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciol001r1v60yncbrfqd","content":"<p>如果你是一个游戏迷，或者说魔兽世界迷，那么你一定不会对插件这个东西感觉到陌生；如果你是一个用代码写人生的家伙，那么你一定要接触一下Lua这门语言；如果你只是对魔兽插件表示好奇，那么请保持这种好奇的态度。我们今天要说的，就是魔兽世界游戏插件的事情。<br><a id=\"more\"></a></p>\n<p>那么在做插件之前，你得要了解几件事情。</p>\n<h2 id=\"下载游戏\"><a href=\"#下载游戏\" class=\"headerlink\" title=\"下载游戏\"></a>下载游戏</h2><p>魔兽世界从2004年在中国登录已经有十多年的历史，迭代过N个版本，客户端也由最初的不到10个G发展到现在的40多个G。然而下载游戏时，你除了要考虑到你硬盘是否够用，下载的问题可以交给战网客户端，暴雪自己的线路绝对可以保证你在一个晚上就下载下来整个客户端。这里我要提醒下各位，你最好将你的游戏下载到一个移动硬盘里，毕竟客户端体积较大，下载到硬盘里那么你就可以带着硬盘随时调试或者玩魔兽啦，而且USB3.0完全可以满足你硬盘的读写速度。</p>\n<p>那么我们要提到的就是战网客户端了。战网是暴雪为方便玩家对其游戏的管理制作的一个游戏管理客户端，在战网上你可以获取到所有暴雪官方游戏客户端。在战网下载页面，我们可以下载到各种语言的战网。同时要提一下，国服的战网是一个封闭的环境，如果我们下载国服的客户端，只能够登录国服的帐号，也就是在中国大陆申请的帐号，不包括台湾香港的帐号。而美国战网的客户端则是一个开放的环境，可以登录任何地区的帐号。</p>\n<p>我们在进行插件调试的过程中，会遇到插件本地化的问题，也就是如果你用中文进行插件制作，中途会遇到时不知明的问题，所以，我们强烈建议下载美服的客户端，下载纯正的美国魔兽世界客户端，之后再进行汉化，这样一来，我们省去了插件制作中中文编码导致插件错误的问题。后期我们会单独进行插件的汉化。</p>\n<p>接下来就是下载美国战网客户端，<a href=\"http://us.battle.net/en/\" target=\"_blank\" rel=\"noopener\">下载地址</a>，你可能会需要用到vpn翻墙下载，可能。下载下来我们安装到电脑上。这个过程可能遇到的问题是，如果你第一次没有安装成功，那么你在接下来的安装过程中可能会遇到进度条卡在中间一直不动的情况，而且等了很久之后仍然是一动也不动。这个时候我们就不要再等它出现奇迹了，你要做的是关掉它，找到你的用户目录，找到你用户目录下关于<em>Battle.net</em>以及<em>Blizzard</em>的缓存，这些目录有可能是隐藏掉的，上网找一下如何让它们显现出来的方法，如果你找不到这些目录，那你仍然可以上网找一下，这里就不再贴目录了，windows和mac下的目录不一样，但是大致都差不多；找到这些文件，不要犹豫全部删掉它，一点不剩。然后重装你的战网。</p>\n<p>接下来安装完战网客户端之后就要安装游戏了，不过我们先不要安装游戏，首先去注册一个美服的战网让我们可以登录美服，注册的时候我们选台湾地区，因为是实名的，会让我们输入身份证号。</p>\n<p>帐号有了之后，我们并不马上打开客户端，打开你的战网客户端配置文件目录，过程如下：</p>\n<p>windows下，打开C盘(系统盘)，用户，你的机器名字，找到AppData；AppData这个文件默认是隐藏的，所以你需要在文件夹选项里点击查看，勾选显示 隐藏文件、文件夹，这样就可以看到AppData了！点击Roaming，找到Battle.net，如果很多可以按快捷键B，在用记事本打开Battle.net；</p>\n<p>在mac下，打开finder，command+shift+g打开，复制<code>~/Library/Application Support/Battle.net</code>，粘贴到输入框，用文本软件打开<em>Battle.net.config</em>文件；</p>\n<p>接下来修改修改Client语法下的AllowedRegions区域，将AllowedRegions区域加入CN;US;EU;KR ，Regions就是你的登录可以选择的区域，CN就是国服;US美服;EU欧服;KR韩/台服。(根据自己的喜好选择对应的区域)</p>\n<p>Locales是你的登录器语言，加入zhCN就是简体中文版登录器;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;Client&quot;:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&quot;AllowedRegions&quot;: &quot;CN;US;EU;KR&quot;,</span><br><span class=\"line\">　　&quot;AllowedLocales&quot;: </span><br><span class=\"line\">　　&quot;zhCN;deDE;enGB;enUS;esMX;esES;frFR;itIT;plPL;ptBR;ruRU;koKR;zhTW&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端测试及语言设置,Config.wtf文件修改为：(此项也可以不用修改)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET portal &quot;US-test&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SET textLocale &quot;zhCN&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SET audioLocale &quot;enUS&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SET installLocale &quot;enUS&quot;</span><br></pre></td></tr></table></figure>\n<p>修改完成后进入客户端，选择北美地区，登入战网，之后点安装，战网就会下载美服客户端。下载完成后如果要登入国服帐号，选择中国地区，客户端会自动下载汉化更新，这样你的战网就可以既登录美服，也可登录国服了。</p>\n<h2 id=\"游戏语言\"><a href=\"#游戏语言\" class=\"headerlink\" title=\"游戏语言\"></a>游戏语言</h2><p>毫无疑问，接下来要说的就是插件的语言了。魔兽世界使用Lua配合xml对插件进行开发，游戏逻辑使用Lua，界面使用xml。做过Cocos2dx的朋友应该使用过Lua进行过快速开发，做为一个小巧的脚本语言，它在游戏开发中还是很有市场的。接下来我们要做的就是在电脑上安装Lua；</p>\n<p>lua官方网站上有详细的安装过程，英文好的同学可以自行看原文进行操作。<a href=\"https://www.lua.org/\" target=\"_blank\" rel=\"noopener\">lua.org</a></p>\n<p>下载lua，<a href=\"https://www.lua.org/ftp/\" target=\"_blank\" rel=\"noopener\">download</a>，页面显示了lua的各个版本，建议下载最新版本。下载后解压缩会生成一个目录。</p>\n<p>用终端进入到目录里，具体操作就是在终端里输入cd,中间加个空格，然后把你目录的路径复制到那里（把文件往终端里一拉就有了）。你不知道widows的终端怎么进？win+R，输入cmd，就出来了。</p>\n<p>接下来，终端输入<code>make xxx install</code>，这里的xxx，在下面选：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aix bsd c89 freebsd generic linux macosx mingw posix solaris</span><br></pre></td></tr></table></figure>\n<p>windows下建议下载一个Lua for windows的软件，不认为windows下用终端要方便好多。</p>\n<p>安装完成后在终端直接敲lua，看看安装是否成功。</p>\n<p>安装完成后我们就可以在终端进行lua的学习了，语法学习是一个枯燥的过程，建议找本书照着例子多敲，这里我们推荐书《Programming in Lua》，网上有中文的翻译，想快速上手写的话可以看这篇帖子，先大致了解下lua的语法，<a href=\"http://bbs.ngacn.cc/read.php?tid=6621402\" target=\"_blank\" rel=\"noopener\">Lua学习</a>。</p>\n<h2 id=\"插件库\"><a href=\"#插件库\" class=\"headerlink\" title=\"插件库\"></a>插件库</h2><p>我们魔兽的所有插件都会以文件夹的形式保存在<em>World of Warcraft/Interface/AddOns</em>下，我们以后做的插件放在这里才会被系统识别。不过本篇我们不说插件制作的事情，这里只是告诉读者，这里是我们进入魔兽插件开发的入口。</p>\n<p>我们要用到的插件库叫做wowace,ACE3库以及其他的函数库是目前大多数插件必备的内置库，ACE3库集成了魔兽世界插件中经常用到功能的和函数，极大方便了插件作者提高开发效率。wowace现在更新到了3版本，且各个版本之间不向下向下兼容，所以你最好选择一个稳定的版本做开发。</p>\n<p>这里我们给出库的下载地址，<a href=\"http://www.wowace.com/addons/ace3/files/\" target=\"_blank\" rel=\"noopener\">Ace3</a>以及API文档，<a href=\"http://wow.gamepedia.com/WelcomeHome_-_Your_first_Ace3_Addon\" target=\"_blank\" rel=\"noopener\">API</a>。</p>\n<h2 id=\"与你的朋友合作\"><a href=\"#与你的朋友合作\" class=\"headerlink\" title=\"与你的朋友合作\"></a>与你的朋友合作</h2><p><a href=\"https://www.wowace.com\" target=\"_blank\" rel=\"noopener\">https://www.wowace.com</a>上有wowace版本控制系统，注册一个帐号，你可以在svn或者git上与你的朋友一起写插件。</p>\n<h2 id=\"发布相关\"><a href=\"#发布相关\" class=\"headerlink\" title=\"发布相关\"></a>发布相关</h2><p><a href=\"https://mods.curse.com\" target=\"_blank\" rel=\"noopener\">https://mods.curse.com</a>这个网站可以把你的插件发布到平台上，另外你也可以在这里下载别人的插件进行学习。</p>\n<p>大致能想到的现在就是这么多，我也是刚刚开始做，如果遇到问题，我们可以交流。我还会将我做插件的过程记录下来，同大家一同学习。</p>\n","site":{"data":{}},"excerpt":"<p>如果你是一个游戏迷，或者说魔兽世界迷，那么你一定不会对插件这个东西感觉到陌生；如果你是一个用代码写人生的家伙，那么你一定要接触一下Lua这门语言；如果你只是对魔兽插件表示好奇，那么请保持这种好奇的态度。我们今天要说的，就是魔兽世界游戏插件的事情。<br>","more":"</p>\n<p>那么在做插件之前，你得要了解几件事情。</p>\n<h2 id=\"下载游戏\"><a href=\"#下载游戏\" class=\"headerlink\" title=\"下载游戏\"></a>下载游戏</h2><p>魔兽世界从2004年在中国登录已经有十多年的历史，迭代过N个版本，客户端也由最初的不到10个G发展到现在的40多个G。然而下载游戏时，你除了要考虑到你硬盘是否够用，下载的问题可以交给战网客户端，暴雪自己的线路绝对可以保证你在一个晚上就下载下来整个客户端。这里我要提醒下各位，你最好将你的游戏下载到一个移动硬盘里，毕竟客户端体积较大，下载到硬盘里那么你就可以带着硬盘随时调试或者玩魔兽啦，而且USB3.0完全可以满足你硬盘的读写速度。</p>\n<p>那么我们要提到的就是战网客户端了。战网是暴雪为方便玩家对其游戏的管理制作的一个游戏管理客户端，在战网上你可以获取到所有暴雪官方游戏客户端。在战网下载页面，我们可以下载到各种语言的战网。同时要提一下，国服的战网是一个封闭的环境，如果我们下载国服的客户端，只能够登录国服的帐号，也就是在中国大陆申请的帐号，不包括台湾香港的帐号。而美国战网的客户端则是一个开放的环境，可以登录任何地区的帐号。</p>\n<p>我们在进行插件调试的过程中，会遇到插件本地化的问题，也就是如果你用中文进行插件制作，中途会遇到时不知明的问题，所以，我们强烈建议下载美服的客户端，下载纯正的美国魔兽世界客户端，之后再进行汉化，这样一来，我们省去了插件制作中中文编码导致插件错误的问题。后期我们会单独进行插件的汉化。</p>\n<p>接下来就是下载美国战网客户端，<a href=\"http://us.battle.net/en/\" target=\"_blank\" rel=\"noopener\">下载地址</a>，你可能会需要用到vpn翻墙下载，可能。下载下来我们安装到电脑上。这个过程可能遇到的问题是，如果你第一次没有安装成功，那么你在接下来的安装过程中可能会遇到进度条卡在中间一直不动的情况，而且等了很久之后仍然是一动也不动。这个时候我们就不要再等它出现奇迹了，你要做的是关掉它，找到你的用户目录，找到你用户目录下关于<em>Battle.net</em>以及<em>Blizzard</em>的缓存，这些目录有可能是隐藏掉的，上网找一下如何让它们显现出来的方法，如果你找不到这些目录，那你仍然可以上网找一下，这里就不再贴目录了，windows和mac下的目录不一样，但是大致都差不多；找到这些文件，不要犹豫全部删掉它，一点不剩。然后重装你的战网。</p>\n<p>接下来安装完战网客户端之后就要安装游戏了，不过我们先不要安装游戏，首先去注册一个美服的战网让我们可以登录美服，注册的时候我们选台湾地区，因为是实名的，会让我们输入身份证号。</p>\n<p>帐号有了之后，我们并不马上打开客户端，打开你的战网客户端配置文件目录，过程如下：</p>\n<p>windows下，打开C盘(系统盘)，用户，你的机器名字，找到AppData；AppData这个文件默认是隐藏的，所以你需要在文件夹选项里点击查看，勾选显示 隐藏文件、文件夹，这样就可以看到AppData了！点击Roaming，找到Battle.net，如果很多可以按快捷键B，在用记事本打开Battle.net；</p>\n<p>在mac下，打开finder，command+shift+g打开，复制<code>~/Library/Application Support/Battle.net</code>，粘贴到输入框，用文本软件打开<em>Battle.net.config</em>文件；</p>\n<p>接下来修改修改Client语法下的AllowedRegions区域，将AllowedRegions区域加入CN;US;EU;KR ，Regions就是你的登录可以选择的区域，CN就是国服;US美服;EU欧服;KR韩/台服。(根据自己的喜好选择对应的区域)</p>\n<p>Locales是你的登录器语言，加入zhCN就是简体中文版登录器;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;Client&quot;:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&quot;AllowedRegions&quot;: &quot;CN;US;EU;KR&quot;,</span><br><span class=\"line\">　　&quot;AllowedLocales&quot;: </span><br><span class=\"line\">　　&quot;zhCN;deDE;enGB;enUS;esMX;esES;frFR;itIT;plPL;ptBR;ruRU;koKR;zhTW&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端测试及语言设置,Config.wtf文件修改为：(此项也可以不用修改)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET portal &quot;US-test&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SET textLocale &quot;zhCN&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SET audioLocale &quot;enUS&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SET installLocale &quot;enUS&quot;</span><br></pre></td></tr></table></figure>\n<p>修改完成后进入客户端，选择北美地区，登入战网，之后点安装，战网就会下载美服客户端。下载完成后如果要登入国服帐号，选择中国地区，客户端会自动下载汉化更新，这样你的战网就可以既登录美服，也可登录国服了。</p>\n<h2 id=\"游戏语言\"><a href=\"#游戏语言\" class=\"headerlink\" title=\"游戏语言\"></a>游戏语言</h2><p>毫无疑问，接下来要说的就是插件的语言了。魔兽世界使用Lua配合xml对插件进行开发，游戏逻辑使用Lua，界面使用xml。做过Cocos2dx的朋友应该使用过Lua进行过快速开发，做为一个小巧的脚本语言，它在游戏开发中还是很有市场的。接下来我们要做的就是在电脑上安装Lua；</p>\n<p>lua官方网站上有详细的安装过程，英文好的同学可以自行看原文进行操作。<a href=\"https://www.lua.org/\" target=\"_blank\" rel=\"noopener\">lua.org</a></p>\n<p>下载lua，<a href=\"https://www.lua.org/ftp/\" target=\"_blank\" rel=\"noopener\">download</a>，页面显示了lua的各个版本，建议下载最新版本。下载后解压缩会生成一个目录。</p>\n<p>用终端进入到目录里，具体操作就是在终端里输入cd,中间加个空格，然后把你目录的路径复制到那里（把文件往终端里一拉就有了）。你不知道widows的终端怎么进？win+R，输入cmd，就出来了。</p>\n<p>接下来，终端输入<code>make xxx install</code>，这里的xxx，在下面选：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aix bsd c89 freebsd generic linux macosx mingw posix solaris</span><br></pre></td></tr></table></figure>\n<p>windows下建议下载一个Lua for windows的软件，不认为windows下用终端要方便好多。</p>\n<p>安装完成后在终端直接敲lua，看看安装是否成功。</p>\n<p>安装完成后我们就可以在终端进行lua的学习了，语法学习是一个枯燥的过程，建议找本书照着例子多敲，这里我们推荐书《Programming in Lua》，网上有中文的翻译，想快速上手写的话可以看这篇帖子，先大致了解下lua的语法，<a href=\"http://bbs.ngacn.cc/read.php?tid=6621402\" target=\"_blank\" rel=\"noopener\">Lua学习</a>。</p>\n<h2 id=\"插件库\"><a href=\"#插件库\" class=\"headerlink\" title=\"插件库\"></a>插件库</h2><p>我们魔兽的所有插件都会以文件夹的形式保存在<em>World of Warcraft/Interface/AddOns</em>下，我们以后做的插件放在这里才会被系统识别。不过本篇我们不说插件制作的事情，这里只是告诉读者，这里是我们进入魔兽插件开发的入口。</p>\n<p>我们要用到的插件库叫做wowace,ACE3库以及其他的函数库是目前大多数插件必备的内置库，ACE3库集成了魔兽世界插件中经常用到功能的和函数，极大方便了插件作者提高开发效率。wowace现在更新到了3版本，且各个版本之间不向下向下兼容，所以你最好选择一个稳定的版本做开发。</p>\n<p>这里我们给出库的下载地址，<a href=\"http://www.wowace.com/addons/ace3/files/\" target=\"_blank\" rel=\"noopener\">Ace3</a>以及API文档，<a href=\"http://wow.gamepedia.com/WelcomeHome_-_Your_first_Ace3_Addon\" target=\"_blank\" rel=\"noopener\">API</a>。</p>\n<h2 id=\"与你的朋友合作\"><a href=\"#与你的朋友合作\" class=\"headerlink\" title=\"与你的朋友合作\"></a>与你的朋友合作</h2><p><a href=\"https://www.wowace.com\" target=\"_blank\" rel=\"noopener\">https://www.wowace.com</a>上有wowace版本控制系统，注册一个帐号，你可以在svn或者git上与你的朋友一起写插件。</p>\n<h2 id=\"发布相关\"><a href=\"#发布相关\" class=\"headerlink\" title=\"发布相关\"></a>发布相关</h2><p><a href=\"https://mods.curse.com\" target=\"_blank\" rel=\"noopener\">https://mods.curse.com</a>这个网站可以把你的插件发布到平台上，另外你也可以在这里下载别人的插件进行学习。</p>\n<p>大致能想到的现在就是这么多，我也是刚刚开始做，如果遇到问题，我们可以交流。我还会将我做插件的过程记录下来，同大家一同学习。</p>"},{"title":"你的pod不工作了吗？","date":"2017-10-17T03:03:00.000Z","_content":"\n最近公司的项目需要添加几个依赖库，用pod更新的时候发现一直卡在了\n```\nSetting up CocoaPods master repo\n```\n<!-- more -->\n\n\n继而是漫长的等待，在这个期间我不知道它发生了什么。\n\n在这种等待中，程序员一般会选择做一些别的事情。于是我上网验证了一下我的行为，结论告诉我：\n\n1.我要开个VPN；\n\n2.我需要重新安装一下pod，因为它已经不工作了；\n\n首先要先检查一下ruby源：\n\n```\ngem sources -l\n```\n\n返回的结果是https://rubygems.org/，如果你在网上找到过其他源并且修改过它，并且你不确定你的源是否可以使用的话，那么请修改回来，买个VPN，这会让你节省很多不必要的劳动，你可以用以下代码修改源：\n\n```\n#移除旧源\ngem sources --remove 旧源址\n#添加新源\ngem sources -a https://rubygems.org/\n```\n\nPS:请确保你的源可用！！！\n\n接着如果你没有安装pod，请执行：\n\n\n```\nsudo gem install cocoapods\n```\n\n如果你已经安装pod，请执行：\n\n```\npod setup\n```\n\n这个操作结束之后，又重现了一个漫长的等待过程，那么我们要清楚它是否在认真工作，请打开另外一个终端，我们要检查一下进度：\n\n```\n#进入到pod目录\ncd ~/.cocoapods\n\n#检查当前文件下所有文件的大小，此后如果你不放心，可以分时段检查一下\ndu -sh *\n```\n\n这个过程会很漫长，取决于你VPN的速度，最后我这边出结果会反馈绿色的文字，Setup completed!文件总大小是1.2G，所以还是耐心的等待吧。。。\n\n另外还有一点，如果上述`pod setup`出现红色的错误信息，也有可能是gem没有到最新版本，那么你还需要用你的VPN更新一下gem到最新；\n```\nsudo gem update --system\n```\nPS:顺便记一下寻找库代码\n```\npod search AFNetworking\n```\n这个时候会遇到这样的提示：\n```\n[!] Unable to find a pod with name, author, summary, or descriptionmatching `AFNetworking`\n```\n你需要做如下操作，再进行搜索：\n```\nrm ~/Library/Caches/CocoaPods/search_index.json\n```\n最后你将如愿以偿，感谢亲人：\n```\nCreating search index for spec repo 'master'.. Done!\n```","source":"_posts/你的pod不工作了吗？.md","raw":"title: 你的pod不工作了吗？\ndate: 2017-10-17 11:03:00\ncategories: coder\ntags: [CocaoPods]\n-----------\n\n最近公司的项目需要添加几个依赖库，用pod更新的时候发现一直卡在了\n```\nSetting up CocoaPods master repo\n```\n<!-- more -->\n\n\n继而是漫长的等待，在这个期间我不知道它发生了什么。\n\n在这种等待中，程序员一般会选择做一些别的事情。于是我上网验证了一下我的行为，结论告诉我：\n\n1.我要开个VPN；\n\n2.我需要重新安装一下pod，因为它已经不工作了；\n\n首先要先检查一下ruby源：\n\n```\ngem sources -l\n```\n\n返回的结果是https://rubygems.org/，如果你在网上找到过其他源并且修改过它，并且你不确定你的源是否可以使用的话，那么请修改回来，买个VPN，这会让你节省很多不必要的劳动，你可以用以下代码修改源：\n\n```\n#移除旧源\ngem sources --remove 旧源址\n#添加新源\ngem sources -a https://rubygems.org/\n```\n\nPS:请确保你的源可用！！！\n\n接着如果你没有安装pod，请执行：\n\n\n```\nsudo gem install cocoapods\n```\n\n如果你已经安装pod，请执行：\n\n```\npod setup\n```\n\n这个操作结束之后，又重现了一个漫长的等待过程，那么我们要清楚它是否在认真工作，请打开另外一个终端，我们要检查一下进度：\n\n```\n#进入到pod目录\ncd ~/.cocoapods\n\n#检查当前文件下所有文件的大小，此后如果你不放心，可以分时段检查一下\ndu -sh *\n```\n\n这个过程会很漫长，取决于你VPN的速度，最后我这边出结果会反馈绿色的文字，Setup completed!文件总大小是1.2G，所以还是耐心的等待吧。。。\n\n另外还有一点，如果上述`pod setup`出现红色的错误信息，也有可能是gem没有到最新版本，那么你还需要用你的VPN更新一下gem到最新；\n```\nsudo gem update --system\n```\nPS:顺便记一下寻找库代码\n```\npod search AFNetworking\n```\n这个时候会遇到这样的提示：\n```\n[!] Unable to find a pod with name, author, summary, or descriptionmatching `AFNetworking`\n```\n你需要做如下操作，再进行搜索：\n```\nrm ~/Library/Caches/CocoaPods/search_index.json\n```\n最后你将如愿以偿，感谢亲人：\n```\nCreating search index for spec repo 'master'.. Done!\n```","slug":"你的pod不工作了吗？","published":1,"updated":"2018-05-04T10:24:03.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciom001t1v60t2cl8zxe","content":"<p>最近公司的项目需要添加几个依赖库，用pod更新的时候发现一直卡在了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Setting up CocoaPods master repo</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>继而是漫长的等待，在这个期间我不知道它发生了什么。</p>\n<p>在这种等待中，程序员一般会选择做一些别的事情。于是我上网验证了一下我的行为，结论告诉我：</p>\n<p>1.我要开个VPN；</p>\n<p>2.我需要重新安装一下pod，因为它已经不工作了；</p>\n<p>首先要先检查一下ruby源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources -l</span><br></pre></td></tr></table></figure>\n<p>返回的结果是<a href=\"https://rubygems.org/，如果你在网上找到过其他源并且修改过它，并且你不确定你的源是否可以使用的话，那么请修改回来，买个VPN，这会让你节省很多不必要的劳动，你可以用以下代码修改源：\" target=\"_blank\" rel=\"noopener\">https://rubygems.org/，如果你在网上找到过其他源并且修改过它，并且你不确定你的源是否可以使用的话，那么请修改回来，买个VPN，这会让你节省很多不必要的劳动，你可以用以下代码修改源：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#移除旧源</span><br><span class=\"line\">gem sources --remove 旧源址</span><br><span class=\"line\">#添加新源</span><br><span class=\"line\">gem sources -a https://rubygems.org/</span><br></pre></td></tr></table></figure>\n<p>PS:请确保你的源可用！！！</p>\n<p>接着如果你没有安装pod，请执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>\n<p>如果你已经安装pod，请执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod setup</span><br></pre></td></tr></table></figure>\n<p>这个操作结束之后，又重现了一个漫长的等待过程，那么我们要清楚它是否在认真工作，请打开另外一个终端，我们要检查一下进度：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#进入到pod目录</span><br><span class=\"line\">cd ~/.cocoapods</span><br><span class=\"line\"></span><br><span class=\"line\">#检查当前文件下所有文件的大小，此后如果你不放心，可以分时段检查一下</span><br><span class=\"line\">du -sh *</span><br></pre></td></tr></table></figure>\n<p>这个过程会很漫长，取决于你VPN的速度，最后我这边出结果会反馈绿色的文字，Setup completed!文件总大小是1.2G，所以还是耐心的等待吧。。。</p>\n<p>另外还有一点，如果上述<code>pod setup</code>出现红色的错误信息，也有可能是gem没有到最新版本，那么你还需要用你的VPN更新一下gem到最新；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem update --system</span><br></pre></td></tr></table></figure></p>\n<p>PS:顺便记一下寻找库代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod search AFNetworking</span><br></pre></td></tr></table></figure></p>\n<p>这个时候会遇到这样的提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[!] Unable to find a pod with name, author, summary, or descriptionmatching `AFNetworking`</span><br></pre></td></tr></table></figure></p>\n<p>你需要做如下操作，再进行搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure></p>\n<p>最后你将如愿以偿，感谢亲人：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating search index for spec repo &apos;master&apos;.. Done!</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>最近公司的项目需要添加几个依赖库，用pod更新的时候发现一直卡在了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Setting up CocoaPods master repo</span><br></pre></td></tr></table></figure></p>","more":"<p>继而是漫长的等待，在这个期间我不知道它发生了什么。</p>\n<p>在这种等待中，程序员一般会选择做一些别的事情。于是我上网验证了一下我的行为，结论告诉我：</p>\n<p>1.我要开个VPN；</p>\n<p>2.我需要重新安装一下pod，因为它已经不工作了；</p>\n<p>首先要先检查一下ruby源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources -l</span><br></pre></td></tr></table></figure>\n<p>返回的结果是<a href=\"https://rubygems.org/，如果你在网上找到过其他源并且修改过它，并且你不确定你的源是否可以使用的话，那么请修改回来，买个VPN，这会让你节省很多不必要的劳动，你可以用以下代码修改源：\" target=\"_blank\" rel=\"noopener\">https://rubygems.org/，如果你在网上找到过其他源并且修改过它，并且你不确定你的源是否可以使用的话，那么请修改回来，买个VPN，这会让你节省很多不必要的劳动，你可以用以下代码修改源：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#移除旧源</span><br><span class=\"line\">gem sources --remove 旧源址</span><br><span class=\"line\">#添加新源</span><br><span class=\"line\">gem sources -a https://rubygems.org/</span><br></pre></td></tr></table></figure>\n<p>PS:请确保你的源可用！！！</p>\n<p>接着如果你没有安装pod，请执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>\n<p>如果你已经安装pod，请执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod setup</span><br></pre></td></tr></table></figure>\n<p>这个操作结束之后，又重现了一个漫长的等待过程，那么我们要清楚它是否在认真工作，请打开另外一个终端，我们要检查一下进度：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#进入到pod目录</span><br><span class=\"line\">cd ~/.cocoapods</span><br><span class=\"line\"></span><br><span class=\"line\">#检查当前文件下所有文件的大小，此后如果你不放心，可以分时段检查一下</span><br><span class=\"line\">du -sh *</span><br></pre></td></tr></table></figure>\n<p>这个过程会很漫长，取决于你VPN的速度，最后我这边出结果会反馈绿色的文字，Setup completed!文件总大小是1.2G，所以还是耐心的等待吧。。。</p>\n<p>另外还有一点，如果上述<code>pod setup</code>出现红色的错误信息，也有可能是gem没有到最新版本，那么你还需要用你的VPN更新一下gem到最新；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem update --system</span><br></pre></td></tr></table></figure></p>\n<p>PS:顺便记一下寻找库代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod search AFNetworking</span><br></pre></td></tr></table></figure></p>\n<p>这个时候会遇到这样的提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[!] Unable to find a pod with name, author, summary, or descriptionmatching `AFNetworking`</span><br></pre></td></tr></table></figure></p>\n<p>你需要做如下操作，再进行搜索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure></p>\n<p>最后你将如愿以偿，感谢亲人：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Creating search index for spec repo &apos;master&apos;.. Done!</span><br></pre></td></tr></table></figure></p>"},{"title":"关于GLKit的推断","date":"2016-05-09T14:00:00.000Z","_content":"\nSummary:本篇是对OpenGLES_Ch2_1中的缓存管理代码的简单重用和重构，用以加深对GLKView的理解。苹果的GLKit框架封装了gl的具体实现，以便使用gl的用户减少编写gl的代码量以及避免不必要的错误。\n\n<!-- more -->\n\n本文介绍两个封装类，`AGLKContext`和`AGLKVertexAttribArrayBuffer`，前者是内建的`EAGLContext`的简单子类，后者封装了使用OpenGLES2.0顶点属性数组缓存的7个步骤；\n\n\n## `AGLKContext.m`\n\n```\n// This method sets the clear (background) RGBA color.\n// The clear color is undefined until this method is called.\n- (void)setClearColor:(GLKVector4)clearColorRGBA\n{\n   clearColor = clearColorRGBA;\n    \n   NSAssert(self == [[self class] currentContext],\n      @\"Receiving context required to be current context\");\n      \n   glClearColor(\n      clearColorRGBA.r, \n      clearColorRGBA.g, \n      clearColorRGBA.b, \n      clearColorRGBA.a);\n}\n```\n\n```\n/////////////////////////////////////////////////////////////////\n// This method instructs OpenGL ES to set all data in the\n// current Context's Render Buffer(s) identified by mask to\n// colors (values) specified via -setClearColor: and/or\n// OpenGL ES functions for each Render Buffer type.\n- (void)clear:(GLbitfield)mask\n{\n   NSAssert(self == [[self class] currentContext],\n      @\"Receiving context required to be current context\");\n      \n   glClear(mask);\n}\n```\n\n>\n>函数原型: `void glClear(GLbitfield mask);`    \n>参数说明：    \n>GLbitfield：可以使用 | 运算符组合不同的缓冲标志位，表明需要清除的缓冲，例如glClear（GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）表示要清除颜色缓冲以及深度缓冲，可以使用以下标志位    \n>\n      GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲\n      GL_DEPTH_BUFFER_BIT:    深度缓冲\n      GL_ACCUM_BUFFER_BIT:    累积缓冲    \n      GL_STENCIL_BUFFER_BIT:  模板缓冲\n函数说明：    \nglClear()函数的作用是用当前缓冲区清除值，也就是glClearColor或者glClearDepth、glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区，也可以使用glDrawBuffer一次清除多个颜色缓存。\n\n以上两个函数的封装为渲染提供背景，并且利用glClearColor()将上下文帧缓存中的每个像素颜色设置为该颜色值；该类中的其他函数是OpenGL的相关函数，留着以后再研究；\n\n## `AGLKVertexAttribArrayBuffer.m`\n\n接下来我们说一下在开篇中谈到的7个步骤；\n\n* NSParameterAssert\n有的方法的条件可以满足可以不满足，都不影响执行。但如果你希望程序在某些条件不满足的时候产生错误告诉你，就用nsparameterassert让程序崩溃。\n \n* glGenBuffers  \n\n```\n// This method creates a vertex attribute array buffer in\n// the current OpenGL ES context for the thread upon which this \n// method is called.\n- (id)initWithAttribStride:(GLsizei)aStride\n   numberOfVertices:(GLsizei)count\n   bytes:(const GLvoid *)dataPtr\n   usage:(GLenum)usage;\n{\n   NSParameterAssert(0 < aStride);\n   NSAssert((0 < count && NULL != dataPtr) ||\n      (0 == count && NULL == dataPtr),\n      @\"data must not be NULL or count > 0\");\n      \n   if(nil != (self = [super init]))\n   {\n      stride = aStride;\n      bufferSizeBytes = stride * count;\n      \n      glGenBuffers(1,                // STEP 1\n         &name);\n      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2\n         self.name); \n      glBufferData(                  // STEP 3\n         GL_ARRAY_BUFFER,  // Initialize buffer contents\n         bufferSizeBytes,  // Number of bytes to copy\n         dataPtr,          // Address of bytes to copy\n         usage);           // Hint: cache in GPU memory\n         \n      NSAssert(0 != name, @\"Failed to generate name\");\n   }\n   return self;\n}   \n```\n\nglGenBuffers()创建缓存对象并且返回缓存对象的标示符。它需要2个参数：第一个为需要创建的缓存数量，第二个为用于存储单一ID或多个ID的GLuint变量或数组的地址。\n\t\n```\nvoid glGenBuffers(GLsizei n, GLuint *buffers);\n//在buffers数组中返回当前n个未使用的名称，表示缓冲区对象\nGLboolean glIsBuffer(GLuint buffer);\n//判断是否是缓冲区对象\n```\n\n* glBindBuffer  \n  \n当缓存对象创建之后，在使用缓存对象之前，我们需要将缓存对象连接到相应的缓存上。\nglBindBuffer()有2个参数：target与buffer。    \n   \n```\nvoid glBindBuffer(GLenum target, GLuint buffer)\n```\ntarget告诉顶点缓存对象(VBO)该缓存对象将保存顶点数组数据还是索引数组数据：GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。任何顶点属性，如顶点坐标、纹理坐标、法线与颜色分量数组都使用GL_ARRAY_BUFFER。用于glDraw[Range]Elements()的索引数据需要使用GL_ELEMENT_ARRAY绑定。注意，target标志帮助VBO确定缓存对象最有效的位置，如有些系统将索引保存AGP或系统内存中，将顶点保存在显卡内存中。\n当第一次调用glBindBuffer()，VBO用0大小的内存缓存初始化该缓存，并且设置VBO的初始状态，如用途与访问属性。\n\n* glBufferData   \n\n \n当缓存初始化之后，你可以使用glBufferData()将数据拷贝到缓存对象。    \n\n```\nvoid glBufferData(GLenum target，GLsizeiptr size, const GLvoid* data, GLenum usage);\n```\n\n第一个参数target可以为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。size为待传递数据字节数量。第三个参数为源数据数组指针，如data为NULL，则VBO仅仅预留给定数据大小的内存空间。最后一个参数usage标志位VBO的另一个性能提示，它提供缓存对象将如何使用：static、dynamic或stream、与read、copy或draw。\nVBO为usage标志指定9个枚举值：\nGL_STATIC_DRAW\nGL_STATIC_READ\nGL_STATIC_COPY\nGL_DYNAMIC_DRAW\nGL_DYNAMIC_READ\nGL_DYNAMIC_COPY\nGL_STREAM_DRAW\nGL_STREAM_READ\nGL_STREAM_COPY\n”static“表示VBO中的数据将不会被改动（一次指定多次使用），”dynamic“表示数据将会被频繁改动（反复指定与使用），”stream“表示每帧数据都要改变（一次指定一次使用）。”draw“表示数据将被发送到GPU以待绘制（应用程序到GL），”read“表示数据将被客户端程序读取（GL到应用程序），”copy“表示数据可用于绘制与读取（GL到GL）。\n\n\n\n```\n// A vertex attribute array buffer must be prepared when your \n// application wants to use the buffer to render any geometry. \n// When your application prepares an buffer, some OpenGL ES state\n// is altered to allow bind the buffer and configure pointers.\n- (void)prepareToDrawWithAttrib:(GLuint)index\n   numberOfCoordinates:(GLint)count\n   attribOffset:(GLsizeiptr)offset\n   shouldEnable:(BOOL)shouldEnable\n{\n   NSParameterAssert((0 < count) && (count < 4));\n   NSParameterAssert(offset < self.stride);\n   NSAssert(0 != name, @\"Invalid name\");\n\t\n   glBindBuffer(GL_ARRAY_BUFFER,     // STEP 2\n      self.name);\n\t\n   if(shouldEnable)\n   {\n      glEnableVertexAttribArray(     // Step 4\n         index); \n   }\n\t\n   glVertexAttribPointer(            // Step 5\n      index,               // Identifies the attribute to use\n      count,               // number of coordinates for attribute\n      GL_FLOAT,            // data is floating point\n      GL_FALSE,            // no fixed point scaling\n      (self.stride),       // total num bytes stored per vertex\n      NULL + offset);      // offset from start of each vertex to \n                           // first coord for attribute\n\t#ifdef DEBUG\n\t   {  // Report any errors \n\t      GLenum error = glGetError();\n\t      if(GL_NO_ERROR != error)\n\t      {\n\t         NSLog(@\"GL Error: 0x%x\", error);\n\t      }\n\t   }\n\t#endif\n}\n```\n\n* glEnableVertexAttribArray    \n\n\n第4步和第5步理解起来有点困难，暂时放下，之后研究OpenGL的时候细研究，这里给出原书中的摘录；\n\n>在第4步中，通过调用glEnableVertexAttribArray()来启动顶点缓存渲染操作；OpenGLES所支持的每一个渲染操作都可以单独地使用保存在当前OpenGLES上下文中的设置来开启或关闭。\n在第5步中，glVertexAttribPointer()告诉OpenGLES顶点数据在哪里，以及怎么解释为每个顶点保存的数据。第一个参数指示当前绑定的缓存包含每个顶点的位置信息；第二个参数指示每个位置有3个部分；第三个参数告诉OpenGLES每个部分都保存为一个浮点类型的值；第四个参数告诉OpenGLES小数点固定数据是否可以被改变；第五个参数叫做“步幅”，它指定了每个顶点的保存需要多少个字节，换句话说，步幅指定了GPU从一个顶点的内存开始位置转到下一个顶点的内存开始位置需要跳过多少字节,sizeof(GLKVector3)指示在缓存中没有额外的字节，即顶点位置数据是密封的，在一个顶点缓存中保存除了每个顶点位置的X Y Z坐标之外的其他数据也是可能的；\n\n\n* glVertexAttribPointer \n \n``` \nvoid glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer);\n```\n\n参数：\n*index*\n指定要修改的顶点属性的索引值\n*size*\n指定每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a））\n*type*\n指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。\n*normalized*\n指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）。\n*stride*\n指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0。\n*pointer*\n指定第一个组件在数组的第一个顶点属性中的偏移量。该数组与GL_ARRAY_BUFFER绑定，储存于缓冲区中。初始值为0；\n\n```\n// Submits the drawing command identified by mode and instructs\n// OpenGL ES to use count vertices from the buffer starting from\n// the vertex at index first. Vertex indices start at 0.\n- (void)drawArrayWithMode:(GLenum)mode\n   startVertexIndex:(GLint)first\n   numberOfVertices:(GLsizei)count\n{\n   NSAssert(self.bufferSizeBytes >= \n      ((first + count) * self.stride),\n      @\"Attempt to draw more vertex data than available.\");\n      \n   glDrawArrays(mode, first, count); // Step 6\n}\n```\n\n* glDrawArrays\n\n\nglDrawArrays()第一个参数会告诉GPU怎么处理在绑定的顶点缓存内的顶点数据；第二个参数和第三个参数分别指定缓存内的需要渲染的第一个顶点的位置和需要渲染的顶点的数量；\n\n```\n// This method deletes the receiver's buffer from the current\n// Context when the receiver is deallocated.\n- (void)dealloc\n{\n    // Delete buffer from current context\n    if (0 != name)\n    {\n        glDeleteBuffers(1, &name); // Step 7 \n        name = 0;\n    }\n}\n```\n* glDeleteBuffers\n\n\n删除不需再需要的顶点缓存和上下文，该方法保证Cocoa Touch收回上下文使用的内存和其他资源。\n\n[本例的代码下载链接](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_2_GL/OpenGLES_Ch2_3)\n\n\n","source":"_posts/关于GLKit的推断.md","raw":"title: 关于GLKit的推断\ndate: 2016-05-09 22:00:00\ncategories: coder\ntags: [opengles, GLKit]\n-----------\n\nSummary:本篇是对OpenGLES_Ch2_1中的缓存管理代码的简单重用和重构，用以加深对GLKView的理解。苹果的GLKit框架封装了gl的具体实现，以便使用gl的用户减少编写gl的代码量以及避免不必要的错误。\n\n<!-- more -->\n\n本文介绍两个封装类，`AGLKContext`和`AGLKVertexAttribArrayBuffer`，前者是内建的`EAGLContext`的简单子类，后者封装了使用OpenGLES2.0顶点属性数组缓存的7个步骤；\n\n\n## `AGLKContext.m`\n\n```\n// This method sets the clear (background) RGBA color.\n// The clear color is undefined until this method is called.\n- (void)setClearColor:(GLKVector4)clearColorRGBA\n{\n   clearColor = clearColorRGBA;\n    \n   NSAssert(self == [[self class] currentContext],\n      @\"Receiving context required to be current context\");\n      \n   glClearColor(\n      clearColorRGBA.r, \n      clearColorRGBA.g, \n      clearColorRGBA.b, \n      clearColorRGBA.a);\n}\n```\n\n```\n/////////////////////////////////////////////////////////////////\n// This method instructs OpenGL ES to set all data in the\n// current Context's Render Buffer(s) identified by mask to\n// colors (values) specified via -setClearColor: and/or\n// OpenGL ES functions for each Render Buffer type.\n- (void)clear:(GLbitfield)mask\n{\n   NSAssert(self == [[self class] currentContext],\n      @\"Receiving context required to be current context\");\n      \n   glClear(mask);\n}\n```\n\n>\n>函数原型: `void glClear(GLbitfield mask);`    \n>参数说明：    \n>GLbitfield：可以使用 | 运算符组合不同的缓冲标志位，表明需要清除的缓冲，例如glClear（GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）表示要清除颜色缓冲以及深度缓冲，可以使用以下标志位    \n>\n      GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲\n      GL_DEPTH_BUFFER_BIT:    深度缓冲\n      GL_ACCUM_BUFFER_BIT:    累积缓冲    \n      GL_STENCIL_BUFFER_BIT:  模板缓冲\n函数说明：    \nglClear()函数的作用是用当前缓冲区清除值，也就是glClearColor或者glClearDepth、glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区，也可以使用glDrawBuffer一次清除多个颜色缓存。\n\n以上两个函数的封装为渲染提供背景，并且利用glClearColor()将上下文帧缓存中的每个像素颜色设置为该颜色值；该类中的其他函数是OpenGL的相关函数，留着以后再研究；\n\n## `AGLKVertexAttribArrayBuffer.m`\n\n接下来我们说一下在开篇中谈到的7个步骤；\n\n* NSParameterAssert\n有的方法的条件可以满足可以不满足，都不影响执行。但如果你希望程序在某些条件不满足的时候产生错误告诉你，就用nsparameterassert让程序崩溃。\n \n* glGenBuffers  \n\n```\n// This method creates a vertex attribute array buffer in\n// the current OpenGL ES context for the thread upon which this \n// method is called.\n- (id)initWithAttribStride:(GLsizei)aStride\n   numberOfVertices:(GLsizei)count\n   bytes:(const GLvoid *)dataPtr\n   usage:(GLenum)usage;\n{\n   NSParameterAssert(0 < aStride);\n   NSAssert((0 < count && NULL != dataPtr) ||\n      (0 == count && NULL == dataPtr),\n      @\"data must not be NULL or count > 0\");\n      \n   if(nil != (self = [super init]))\n   {\n      stride = aStride;\n      bufferSizeBytes = stride * count;\n      \n      glGenBuffers(1,                // STEP 1\n         &name);\n      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2\n         self.name); \n      glBufferData(                  // STEP 3\n         GL_ARRAY_BUFFER,  // Initialize buffer contents\n         bufferSizeBytes,  // Number of bytes to copy\n         dataPtr,          // Address of bytes to copy\n         usage);           // Hint: cache in GPU memory\n         \n      NSAssert(0 != name, @\"Failed to generate name\");\n   }\n   return self;\n}   \n```\n\nglGenBuffers()创建缓存对象并且返回缓存对象的标示符。它需要2个参数：第一个为需要创建的缓存数量，第二个为用于存储单一ID或多个ID的GLuint变量或数组的地址。\n\t\n```\nvoid glGenBuffers(GLsizei n, GLuint *buffers);\n//在buffers数组中返回当前n个未使用的名称，表示缓冲区对象\nGLboolean glIsBuffer(GLuint buffer);\n//判断是否是缓冲区对象\n```\n\n* glBindBuffer  \n  \n当缓存对象创建之后，在使用缓存对象之前，我们需要将缓存对象连接到相应的缓存上。\nglBindBuffer()有2个参数：target与buffer。    \n   \n```\nvoid glBindBuffer(GLenum target, GLuint buffer)\n```\ntarget告诉顶点缓存对象(VBO)该缓存对象将保存顶点数组数据还是索引数组数据：GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。任何顶点属性，如顶点坐标、纹理坐标、法线与颜色分量数组都使用GL_ARRAY_BUFFER。用于glDraw[Range]Elements()的索引数据需要使用GL_ELEMENT_ARRAY绑定。注意，target标志帮助VBO确定缓存对象最有效的位置，如有些系统将索引保存AGP或系统内存中，将顶点保存在显卡内存中。\n当第一次调用glBindBuffer()，VBO用0大小的内存缓存初始化该缓存，并且设置VBO的初始状态，如用途与访问属性。\n\n* glBufferData   \n\n \n当缓存初始化之后，你可以使用glBufferData()将数据拷贝到缓存对象。    \n\n```\nvoid glBufferData(GLenum target，GLsizeiptr size, const GLvoid* data, GLenum usage);\n```\n\n第一个参数target可以为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。size为待传递数据字节数量。第三个参数为源数据数组指针，如data为NULL，则VBO仅仅预留给定数据大小的内存空间。最后一个参数usage标志位VBO的另一个性能提示，它提供缓存对象将如何使用：static、dynamic或stream、与read、copy或draw。\nVBO为usage标志指定9个枚举值：\nGL_STATIC_DRAW\nGL_STATIC_READ\nGL_STATIC_COPY\nGL_DYNAMIC_DRAW\nGL_DYNAMIC_READ\nGL_DYNAMIC_COPY\nGL_STREAM_DRAW\nGL_STREAM_READ\nGL_STREAM_COPY\n”static“表示VBO中的数据将不会被改动（一次指定多次使用），”dynamic“表示数据将会被频繁改动（反复指定与使用），”stream“表示每帧数据都要改变（一次指定一次使用）。”draw“表示数据将被发送到GPU以待绘制（应用程序到GL），”read“表示数据将被客户端程序读取（GL到应用程序），”copy“表示数据可用于绘制与读取（GL到GL）。\n\n\n\n```\n// A vertex attribute array buffer must be prepared when your \n// application wants to use the buffer to render any geometry. \n// When your application prepares an buffer, some OpenGL ES state\n// is altered to allow bind the buffer and configure pointers.\n- (void)prepareToDrawWithAttrib:(GLuint)index\n   numberOfCoordinates:(GLint)count\n   attribOffset:(GLsizeiptr)offset\n   shouldEnable:(BOOL)shouldEnable\n{\n   NSParameterAssert((0 < count) && (count < 4));\n   NSParameterAssert(offset < self.stride);\n   NSAssert(0 != name, @\"Invalid name\");\n\t\n   glBindBuffer(GL_ARRAY_BUFFER,     // STEP 2\n      self.name);\n\t\n   if(shouldEnable)\n   {\n      glEnableVertexAttribArray(     // Step 4\n         index); \n   }\n\t\n   glVertexAttribPointer(            // Step 5\n      index,               // Identifies the attribute to use\n      count,               // number of coordinates for attribute\n      GL_FLOAT,            // data is floating point\n      GL_FALSE,            // no fixed point scaling\n      (self.stride),       // total num bytes stored per vertex\n      NULL + offset);      // offset from start of each vertex to \n                           // first coord for attribute\n\t#ifdef DEBUG\n\t   {  // Report any errors \n\t      GLenum error = glGetError();\n\t      if(GL_NO_ERROR != error)\n\t      {\n\t         NSLog(@\"GL Error: 0x%x\", error);\n\t      }\n\t   }\n\t#endif\n}\n```\n\n* glEnableVertexAttribArray    \n\n\n第4步和第5步理解起来有点困难，暂时放下，之后研究OpenGL的时候细研究，这里给出原书中的摘录；\n\n>在第4步中，通过调用glEnableVertexAttribArray()来启动顶点缓存渲染操作；OpenGLES所支持的每一个渲染操作都可以单独地使用保存在当前OpenGLES上下文中的设置来开启或关闭。\n在第5步中，glVertexAttribPointer()告诉OpenGLES顶点数据在哪里，以及怎么解释为每个顶点保存的数据。第一个参数指示当前绑定的缓存包含每个顶点的位置信息；第二个参数指示每个位置有3个部分；第三个参数告诉OpenGLES每个部分都保存为一个浮点类型的值；第四个参数告诉OpenGLES小数点固定数据是否可以被改变；第五个参数叫做“步幅”，它指定了每个顶点的保存需要多少个字节，换句话说，步幅指定了GPU从一个顶点的内存开始位置转到下一个顶点的内存开始位置需要跳过多少字节,sizeof(GLKVector3)指示在缓存中没有额外的字节，即顶点位置数据是密封的，在一个顶点缓存中保存除了每个顶点位置的X Y Z坐标之外的其他数据也是可能的；\n\n\n* glVertexAttribPointer \n \n``` \nvoid glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer);\n```\n\n参数：\n*index*\n指定要修改的顶点属性的索引值\n*size*\n指定每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a））\n*type*\n指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。\n*normalized*\n指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）。\n*stride*\n指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0。\n*pointer*\n指定第一个组件在数组的第一个顶点属性中的偏移量。该数组与GL_ARRAY_BUFFER绑定，储存于缓冲区中。初始值为0；\n\n```\n// Submits the drawing command identified by mode and instructs\n// OpenGL ES to use count vertices from the buffer starting from\n// the vertex at index first. Vertex indices start at 0.\n- (void)drawArrayWithMode:(GLenum)mode\n   startVertexIndex:(GLint)first\n   numberOfVertices:(GLsizei)count\n{\n   NSAssert(self.bufferSizeBytes >= \n      ((first + count) * self.stride),\n      @\"Attempt to draw more vertex data than available.\");\n      \n   glDrawArrays(mode, first, count); // Step 6\n}\n```\n\n* glDrawArrays\n\n\nglDrawArrays()第一个参数会告诉GPU怎么处理在绑定的顶点缓存内的顶点数据；第二个参数和第三个参数分别指定缓存内的需要渲染的第一个顶点的位置和需要渲染的顶点的数量；\n\n```\n// This method deletes the receiver's buffer from the current\n// Context when the receiver is deallocated.\n- (void)dealloc\n{\n    // Delete buffer from current context\n    if (0 != name)\n    {\n        glDeleteBuffers(1, &name); // Step 7 \n        name = 0;\n    }\n}\n```\n* glDeleteBuffers\n\n\n删除不需再需要的顶点缓存和上下文，该方法保证Cocoa Touch收回上下文使用的内存和其他资源。\n\n[本例的代码下载链接](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_2_GL/OpenGLES_Ch2_3)\n\n\n","slug":"关于GLKit的推断","published":1,"updated":"2018-05-04T10:24:02.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucion001x1v601rrdx5tx","content":"<p>Summary:本篇是对OpenGLES_Ch2_1中的缓存管理代码的简单重用和重构，用以加深对GLKView的理解。苹果的GLKit框架封装了gl的具体实现，以便使用gl的用户减少编写gl的代码量以及避免不必要的错误。</p>\n<a id=\"more\"></a>\n<p>本文介绍两个封装类，<code>AGLKContext</code>和<code>AGLKVertexAttribArrayBuffer</code>，前者是内建的<code>EAGLContext</code>的简单子类，后者封装了使用OpenGLES2.0顶点属性数组缓存的7个步骤；</p>\n<h2 id=\"AGLKContext-m\"><a href=\"#AGLKContext-m\" class=\"headerlink\" title=\"AGLKContext.m\"></a><code>AGLKContext.m</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method sets the clear (background) RGBA color.</span><br><span class=\"line\">// The clear color is undefined until this method is called.</span><br><span class=\"line\">- (void)setClearColor:(GLKVector4)clearColorRGBA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   clearColor = clearColorRGBA;</span><br><span class=\"line\">    </span><br><span class=\"line\">   NSAssert(self == [[self class] currentContext],</span><br><span class=\"line\">      @&quot;Receiving context required to be current context&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   glClearColor(</span><br><span class=\"line\">      clearColorRGBA.r, </span><br><span class=\"line\">      clearColorRGBA.g, </span><br><span class=\"line\">      clearColorRGBA.b, </span><br><span class=\"line\">      clearColorRGBA.a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/////////////////////////////////////////////////////////////////</span><br><span class=\"line\">// This method instructs OpenGL ES to set all data in the</span><br><span class=\"line\">// current Context&apos;s Render Buffer(s) identified by mask to</span><br><span class=\"line\">// colors (values) specified via -setClearColor: and/or</span><br><span class=\"line\">// OpenGL ES functions for each Render Buffer type.</span><br><span class=\"line\">- (void)clear:(GLbitfield)mask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSAssert(self == [[self class] currentContext],</span><br><span class=\"line\">      @&quot;Receiving context required to be current context&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   glClear(mask);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>函数原型: <code>void glClear(GLbitfield mask);</code><br>参数说明：<br>GLbitfield：可以使用 | 运算符组合不同的缓冲标志位，表明需要清除的缓冲，例如glClear（GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）表示要清除颜色缓冲以及深度缓冲，可以使用以下标志位    </p>\n</blockquote>\n<pre><code>GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲\nGL_DEPTH_BUFFER_BIT:    深度缓冲\nGL_ACCUM_BUFFER_BIT:    累积缓冲    \nGL_STENCIL_BUFFER_BIT:  模板缓冲\n</code></pre><p>函数说明：<br>glClear()函数的作用是用当前缓冲区清除值，也就是glClearColor或者glClearDepth、glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区，也可以使用glDrawBuffer一次清除多个颜色缓存。</p>\n<p>以上两个函数的封装为渲染提供背景，并且利用glClearColor()将上下文帧缓存中的每个像素颜色设置为该颜色值；该类中的其他函数是OpenGL的相关函数，留着以后再研究；</p>\n<h2 id=\"AGLKVertexAttribArrayBuffer-m\"><a href=\"#AGLKVertexAttribArrayBuffer-m\" class=\"headerlink\" title=\"AGLKVertexAttribArrayBuffer.m\"></a><code>AGLKVertexAttribArrayBuffer.m</code></h2><p>接下来我们说一下在开篇中谈到的7个步骤；</p>\n<ul>\n<li><p>NSParameterAssert<br>有的方法的条件可以满足可以不满足，都不影响执行。但如果你希望程序在某些条件不满足的时候产生错误告诉你，就用nsparameterassert让程序崩溃。</p>\n</li>\n<li><p>glGenBuffers  </p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method creates a vertex attribute array buffer in</span><br><span class=\"line\">// the current OpenGL ES context for the thread upon which this </span><br><span class=\"line\">// method is called.</span><br><span class=\"line\">- (id)initWithAttribStride:(GLsizei)aStride</span><br><span class=\"line\">   numberOfVertices:(GLsizei)count</span><br><span class=\"line\">   bytes:(const GLvoid *)dataPtr</span><br><span class=\"line\">   usage:(GLenum)usage;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSParameterAssert(0 &lt; aStride);</span><br><span class=\"line\">   NSAssert((0 &lt; count &amp;&amp; NULL != dataPtr) ||</span><br><span class=\"line\">      (0 == count &amp;&amp; NULL == dataPtr),</span><br><span class=\"line\">      @&quot;data must not be NULL or count &gt; 0&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   if(nil != (self = [super init]))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      stride = aStride;</span><br><span class=\"line\">      bufferSizeBytes = stride * count;</span><br><span class=\"line\">      </span><br><span class=\"line\">      glGenBuffers(1,                // STEP 1</span><br><span class=\"line\">         &amp;name);</span><br><span class=\"line\">      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class=\"line\">         self.name); </span><br><span class=\"line\">      glBufferData(                  // STEP 3</span><br><span class=\"line\">         GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class=\"line\">         bufferSizeBytes,  // Number of bytes to copy</span><br><span class=\"line\">         dataPtr,          // Address of bytes to copy</span><br><span class=\"line\">         usage);           // Hint: cache in GPU memory</span><br><span class=\"line\">         </span><br><span class=\"line\">      NSAssert(0 != name, @&quot;Failed to generate name&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>glGenBuffers()创建缓存对象并且返回缓存对象的标示符。它需要2个参数：第一个为需要创建的缓存数量，第二个为用于存储单一ID或多个ID的GLuint变量或数组的地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glGenBuffers(GLsizei n, GLuint *buffers);</span><br><span class=\"line\">//在buffers数组中返回当前n个未使用的名称，表示缓冲区对象</span><br><span class=\"line\">GLboolean glIsBuffer(GLuint buffer);</span><br><span class=\"line\">//判断是否是缓冲区对象</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glBindBuffer  </li>\n</ul>\n<p>当缓存对象创建之后，在使用缓存对象之前，我们需要将缓存对象连接到相应的缓存上。<br>glBindBuffer()有2个参数：target与buffer。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glBindBuffer(GLenum target, GLuint buffer)</span><br></pre></td></tr></table></figure>\n<p>target告诉顶点缓存对象(VBO)该缓存对象将保存顶点数组数据还是索引数组数据：GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。任何顶点属性，如顶点坐标、纹理坐标、法线与颜色分量数组都使用GL_ARRAY_BUFFER。用于glDraw[Range]Elements()的索引数据需要使用GL_ELEMENT_ARRAY绑定。注意，target标志帮助VBO确定缓存对象最有效的位置，如有些系统将索引保存AGP或系统内存中，将顶点保存在显卡内存中。<br>当第一次调用glBindBuffer()，VBO用0大小的内存缓存初始化该缓存，并且设置VBO的初始状态，如用途与访问属性。</p>\n<ul>\n<li>glBufferData   </li>\n</ul>\n<p>当缓存初始化之后，你可以使用glBufferData()将数据拷贝到缓存对象。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glBufferData(GLenum target，GLsizeiptr size, const GLvoid* data, GLenum usage);</span><br></pre></td></tr></table></figure>\n<p>第一个参数target可以为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。size为待传递数据字节数量。第三个参数为源数据数组指针，如data为NULL，则VBO仅仅预留给定数据大小的内存空间。最后一个参数usage标志位VBO的另一个性能提示，它提供缓存对象将如何使用：static、dynamic或stream、与read、copy或draw。<br>VBO为usage标志指定9个枚举值：<br>GL_STATIC_DRAW<br>GL_STATIC_READ<br>GL_STATIC_COPY<br>GL_DYNAMIC_DRAW<br>GL_DYNAMIC_READ<br>GL_DYNAMIC_COPY<br>GL_STREAM_DRAW<br>GL_STREAM_READ<br>GL_STREAM_COPY<br>”static“表示VBO中的数据将不会被改动（一次指定多次使用），”dynamic“表示数据将会被频繁改动（反复指定与使用），”stream“表示每帧数据都要改变（一次指定一次使用）。”draw“表示数据将被发送到GPU以待绘制（应用程序到GL），”read“表示数据将被客户端程序读取（GL到应用程序），”copy“表示数据可用于绘制与读取（GL到GL）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A vertex attribute array buffer must be prepared when your </span><br><span class=\"line\">// application wants to use the buffer to render any geometry. </span><br><span class=\"line\">// When your application prepares an buffer, some OpenGL ES state</span><br><span class=\"line\">// is altered to allow bind the buffer and configure pointers.</span><br><span class=\"line\">- (void)prepareToDrawWithAttrib:(GLuint)index</span><br><span class=\"line\">   numberOfCoordinates:(GLint)count</span><br><span class=\"line\">   attribOffset:(GLsizeiptr)offset</span><br><span class=\"line\">   shouldEnable:(BOOL)shouldEnable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSParameterAssert((0 &lt; count) &amp;&amp; (count &lt; 4));</span><br><span class=\"line\">   NSParameterAssert(offset &lt; self.stride);</span><br><span class=\"line\">   NSAssert(0 != name, @&quot;Invalid name&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">   glBindBuffer(GL_ARRAY_BUFFER,     // STEP 2</span><br><span class=\"line\">      self.name);</span><br><span class=\"line\">\t</span><br><span class=\"line\">   if(shouldEnable)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      glEnableVertexAttribArray(     // Step 4</span><br><span class=\"line\">         index); </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">   glVertexAttribPointer(            // Step 5</span><br><span class=\"line\">      index,               // Identifies the attribute to use</span><br><span class=\"line\">      count,               // number of coordinates for attribute</span><br><span class=\"line\">      GL_FLOAT,            // data is floating point</span><br><span class=\"line\">      GL_FALSE,            // no fixed point scaling</span><br><span class=\"line\">      (self.stride),       // total num bytes stored per vertex</span><br><span class=\"line\">      NULL + offset);      // offset from start of each vertex to </span><br><span class=\"line\">                           // first coord for attribute</span><br><span class=\"line\">\t#ifdef DEBUG</span><br><span class=\"line\">\t   &#123;  // Report any errors </span><br><span class=\"line\">\t      GLenum error = glGetError();</span><br><span class=\"line\">\t      if(GL_NO_ERROR != error)</span><br><span class=\"line\">\t      &#123;</span><br><span class=\"line\">\t         NSLog(@&quot;GL Error: 0x%x&quot;, error);</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glEnableVertexAttribArray    </li>\n</ul>\n<p>第4步和第5步理解起来有点困难，暂时放下，之后研究OpenGL的时候细研究，这里给出原书中的摘录；</p>\n<blockquote>\n<p>在第4步中，通过调用glEnableVertexAttribArray()来启动顶点缓存渲染操作；OpenGLES所支持的每一个渲染操作都可以单独地使用保存在当前OpenGLES上下文中的设置来开启或关闭。<br>在第5步中，glVertexAttribPointer()告诉OpenGLES顶点数据在哪里，以及怎么解释为每个顶点保存的数据。第一个参数指示当前绑定的缓存包含每个顶点的位置信息；第二个参数指示每个位置有3个部分；第三个参数告诉OpenGLES每个部分都保存为一个浮点类型的值；第四个参数告诉OpenGLES小数点固定数据是否可以被改变；第五个参数叫做“步幅”，它指定了每个顶点的保存需要多少个字节，换句话说，步幅指定了GPU从一个顶点的内存开始位置转到下一个顶点的内存开始位置需要跳过多少字节,sizeof(GLKVector3)指示在缓存中没有额外的字节，即顶点位置数据是密封的，在一个顶点缓存中保存除了每个顶点位置的X Y Z坐标之外的其他数据也是可能的；</p>\n</blockquote>\n<ul>\n<li>glVertexAttribPointer </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer);</span><br></pre></td></tr></table></figure>\n<p>参数：<br><em>index</em><br>指定要修改的顶点属性的索引值<br><em>size</em><br>指定每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a））<br><em>type</em><br>指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。<br><em>normalized</em><br>指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）。<br><em>stride</em><br>指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0。<br><em>pointer</em><br>指定第一个组件在数组的第一个顶点属性中的偏移量。该数组与GL_ARRAY_BUFFER绑定，储存于缓冲区中。初始值为0；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Submits the drawing command identified by mode and instructs</span><br><span class=\"line\">// OpenGL ES to use count vertices from the buffer starting from</span><br><span class=\"line\">// the vertex at index first. Vertex indices start at 0.</span><br><span class=\"line\">- (void)drawArrayWithMode:(GLenum)mode</span><br><span class=\"line\">   startVertexIndex:(GLint)first</span><br><span class=\"line\">   numberOfVertices:(GLsizei)count</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSAssert(self.bufferSizeBytes &gt;= </span><br><span class=\"line\">      ((first + count) * self.stride),</span><br><span class=\"line\">      @&quot;Attempt to draw more vertex data than available.&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   glDrawArrays(mode, first, count); // Step 6</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glDrawArrays</li>\n</ul>\n<p>glDrawArrays()第一个参数会告诉GPU怎么处理在绑定的顶点缓存内的顶点数据；第二个参数和第三个参数分别指定缓存内的需要渲染的第一个顶点的位置和需要渲染的顶点的数量；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method deletes the receiver&apos;s buffer from the current</span><br><span class=\"line\">// Context when the receiver is deallocated.</span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Delete buffer from current context</span><br><span class=\"line\">    if (0 != name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glDeleteBuffers(1, &amp;name); // Step 7 </span><br><span class=\"line\">        name = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glDeleteBuffers</li>\n</ul>\n<p>删除不需再需要的顶点缓存和上下文，该方法保证Cocoa Touch收回上下文使用的内存和其他资源。</p>\n<p><a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_2_GL/OpenGLES_Ch2_3\" target=\"_blank\" rel=\"noopener\">本例的代码下载链接</a></p>\n","site":{"data":{}},"excerpt":"<p>Summary:本篇是对OpenGLES_Ch2_1中的缓存管理代码的简单重用和重构，用以加深对GLKView的理解。苹果的GLKit框架封装了gl的具体实现，以便使用gl的用户减少编写gl的代码量以及避免不必要的错误。</p>","more":"<p>本文介绍两个封装类，<code>AGLKContext</code>和<code>AGLKVertexAttribArrayBuffer</code>，前者是内建的<code>EAGLContext</code>的简单子类，后者封装了使用OpenGLES2.0顶点属性数组缓存的7个步骤；</p>\n<h2 id=\"AGLKContext-m\"><a href=\"#AGLKContext-m\" class=\"headerlink\" title=\"AGLKContext.m\"></a><code>AGLKContext.m</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method sets the clear (background) RGBA color.</span><br><span class=\"line\">// The clear color is undefined until this method is called.</span><br><span class=\"line\">- (void)setClearColor:(GLKVector4)clearColorRGBA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   clearColor = clearColorRGBA;</span><br><span class=\"line\">    </span><br><span class=\"line\">   NSAssert(self == [[self class] currentContext],</span><br><span class=\"line\">      @&quot;Receiving context required to be current context&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   glClearColor(</span><br><span class=\"line\">      clearColorRGBA.r, </span><br><span class=\"line\">      clearColorRGBA.g, </span><br><span class=\"line\">      clearColorRGBA.b, </span><br><span class=\"line\">      clearColorRGBA.a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/////////////////////////////////////////////////////////////////</span><br><span class=\"line\">// This method instructs OpenGL ES to set all data in the</span><br><span class=\"line\">// current Context&apos;s Render Buffer(s) identified by mask to</span><br><span class=\"line\">// colors (values) specified via -setClearColor: and/or</span><br><span class=\"line\">// OpenGL ES functions for each Render Buffer type.</span><br><span class=\"line\">- (void)clear:(GLbitfield)mask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSAssert(self == [[self class] currentContext],</span><br><span class=\"line\">      @&quot;Receiving context required to be current context&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   glClear(mask);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>函数原型: <code>void glClear(GLbitfield mask);</code><br>参数说明：<br>GLbitfield：可以使用 | 运算符组合不同的缓冲标志位，表明需要清除的缓冲，例如glClear（GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）表示要清除颜色缓冲以及深度缓冲，可以使用以下标志位    </p>\n</blockquote>\n<pre><code>GL_COLOR_BUFFER_BIT:    当前可写的颜色缓冲\nGL_DEPTH_BUFFER_BIT:    深度缓冲\nGL_ACCUM_BUFFER_BIT:    累积缓冲    \nGL_STENCIL_BUFFER_BIT:  模板缓冲\n</code></pre><p>函数说明：<br>glClear()函数的作用是用当前缓冲区清除值，也就是glClearColor或者glClearDepth、glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区，也可以使用glDrawBuffer一次清除多个颜色缓存。</p>\n<p>以上两个函数的封装为渲染提供背景，并且利用glClearColor()将上下文帧缓存中的每个像素颜色设置为该颜色值；该类中的其他函数是OpenGL的相关函数，留着以后再研究；</p>\n<h2 id=\"AGLKVertexAttribArrayBuffer-m\"><a href=\"#AGLKVertexAttribArrayBuffer-m\" class=\"headerlink\" title=\"AGLKVertexAttribArrayBuffer.m\"></a><code>AGLKVertexAttribArrayBuffer.m</code></h2><p>接下来我们说一下在开篇中谈到的7个步骤；</p>\n<ul>\n<li><p>NSParameterAssert<br>有的方法的条件可以满足可以不满足，都不影响执行。但如果你希望程序在某些条件不满足的时候产生错误告诉你，就用nsparameterassert让程序崩溃。</p>\n</li>\n<li><p>glGenBuffers  </p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method creates a vertex attribute array buffer in</span><br><span class=\"line\">// the current OpenGL ES context for the thread upon which this </span><br><span class=\"line\">// method is called.</span><br><span class=\"line\">- (id)initWithAttribStride:(GLsizei)aStride</span><br><span class=\"line\">   numberOfVertices:(GLsizei)count</span><br><span class=\"line\">   bytes:(const GLvoid *)dataPtr</span><br><span class=\"line\">   usage:(GLenum)usage;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSParameterAssert(0 &lt; aStride);</span><br><span class=\"line\">   NSAssert((0 &lt; count &amp;&amp; NULL != dataPtr) ||</span><br><span class=\"line\">      (0 == count &amp;&amp; NULL == dataPtr),</span><br><span class=\"line\">      @&quot;data must not be NULL or count &gt; 0&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   if(nil != (self = [super init]))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      stride = aStride;</span><br><span class=\"line\">      bufferSizeBytes = stride * count;</span><br><span class=\"line\">      </span><br><span class=\"line\">      glGenBuffers(1,                // STEP 1</span><br><span class=\"line\">         &amp;name);</span><br><span class=\"line\">      glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class=\"line\">         self.name); </span><br><span class=\"line\">      glBufferData(                  // STEP 3</span><br><span class=\"line\">         GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class=\"line\">         bufferSizeBytes,  // Number of bytes to copy</span><br><span class=\"line\">         dataPtr,          // Address of bytes to copy</span><br><span class=\"line\">         usage);           // Hint: cache in GPU memory</span><br><span class=\"line\">         </span><br><span class=\"line\">      NSAssert(0 != name, @&quot;Failed to generate name&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>glGenBuffers()创建缓存对象并且返回缓存对象的标示符。它需要2个参数：第一个为需要创建的缓存数量，第二个为用于存储单一ID或多个ID的GLuint变量或数组的地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glGenBuffers(GLsizei n, GLuint *buffers);</span><br><span class=\"line\">//在buffers数组中返回当前n个未使用的名称，表示缓冲区对象</span><br><span class=\"line\">GLboolean glIsBuffer(GLuint buffer);</span><br><span class=\"line\">//判断是否是缓冲区对象</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glBindBuffer  </li>\n</ul>\n<p>当缓存对象创建之后，在使用缓存对象之前，我们需要将缓存对象连接到相应的缓存上。<br>glBindBuffer()有2个参数：target与buffer。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glBindBuffer(GLenum target, GLuint buffer)</span><br></pre></td></tr></table></figure>\n<p>target告诉顶点缓存对象(VBO)该缓存对象将保存顶点数组数据还是索引数组数据：GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。任何顶点属性，如顶点坐标、纹理坐标、法线与颜色分量数组都使用GL_ARRAY_BUFFER。用于glDraw[Range]Elements()的索引数据需要使用GL_ELEMENT_ARRAY绑定。注意，target标志帮助VBO确定缓存对象最有效的位置，如有些系统将索引保存AGP或系统内存中，将顶点保存在显卡内存中。<br>当第一次调用glBindBuffer()，VBO用0大小的内存缓存初始化该缓存，并且设置VBO的初始状态，如用途与访问属性。</p>\n<ul>\n<li>glBufferData   </li>\n</ul>\n<p>当缓存初始化之后，你可以使用glBufferData()将数据拷贝到缓存对象。    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glBufferData(GLenum target，GLsizeiptr size, const GLvoid* data, GLenum usage);</span><br></pre></td></tr></table></figure>\n<p>第一个参数target可以为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY。size为待传递数据字节数量。第三个参数为源数据数组指针，如data为NULL，则VBO仅仅预留给定数据大小的内存空间。最后一个参数usage标志位VBO的另一个性能提示，它提供缓存对象将如何使用：static、dynamic或stream、与read、copy或draw。<br>VBO为usage标志指定9个枚举值：<br>GL_STATIC_DRAW<br>GL_STATIC_READ<br>GL_STATIC_COPY<br>GL_DYNAMIC_DRAW<br>GL_DYNAMIC_READ<br>GL_DYNAMIC_COPY<br>GL_STREAM_DRAW<br>GL_STREAM_READ<br>GL_STREAM_COPY<br>”static“表示VBO中的数据将不会被改动（一次指定多次使用），”dynamic“表示数据将会被频繁改动（反复指定与使用），”stream“表示每帧数据都要改变（一次指定一次使用）。”draw“表示数据将被发送到GPU以待绘制（应用程序到GL），”read“表示数据将被客户端程序读取（GL到应用程序），”copy“表示数据可用于绘制与读取（GL到GL）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A vertex attribute array buffer must be prepared when your </span><br><span class=\"line\">// application wants to use the buffer to render any geometry. </span><br><span class=\"line\">// When your application prepares an buffer, some OpenGL ES state</span><br><span class=\"line\">// is altered to allow bind the buffer and configure pointers.</span><br><span class=\"line\">- (void)prepareToDrawWithAttrib:(GLuint)index</span><br><span class=\"line\">   numberOfCoordinates:(GLint)count</span><br><span class=\"line\">   attribOffset:(GLsizeiptr)offset</span><br><span class=\"line\">   shouldEnable:(BOOL)shouldEnable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSParameterAssert((0 &lt; count) &amp;&amp; (count &lt; 4));</span><br><span class=\"line\">   NSParameterAssert(offset &lt; self.stride);</span><br><span class=\"line\">   NSAssert(0 != name, @&quot;Invalid name&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">   glBindBuffer(GL_ARRAY_BUFFER,     // STEP 2</span><br><span class=\"line\">      self.name);</span><br><span class=\"line\">\t</span><br><span class=\"line\">   if(shouldEnable)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      glEnableVertexAttribArray(     // Step 4</span><br><span class=\"line\">         index); </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">   glVertexAttribPointer(            // Step 5</span><br><span class=\"line\">      index,               // Identifies the attribute to use</span><br><span class=\"line\">      count,               // number of coordinates for attribute</span><br><span class=\"line\">      GL_FLOAT,            // data is floating point</span><br><span class=\"line\">      GL_FALSE,            // no fixed point scaling</span><br><span class=\"line\">      (self.stride),       // total num bytes stored per vertex</span><br><span class=\"line\">      NULL + offset);      // offset from start of each vertex to </span><br><span class=\"line\">                           // first coord for attribute</span><br><span class=\"line\">\t#ifdef DEBUG</span><br><span class=\"line\">\t   &#123;  // Report any errors </span><br><span class=\"line\">\t      GLenum error = glGetError();</span><br><span class=\"line\">\t      if(GL_NO_ERROR != error)</span><br><span class=\"line\">\t      &#123;</span><br><span class=\"line\">\t         NSLog(@&quot;GL Error: 0x%x&quot;, error);</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t#endif</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glEnableVertexAttribArray    </li>\n</ul>\n<p>第4步和第5步理解起来有点困难，暂时放下，之后研究OpenGL的时候细研究，这里给出原书中的摘录；</p>\n<blockquote>\n<p>在第4步中，通过调用glEnableVertexAttribArray()来启动顶点缓存渲染操作；OpenGLES所支持的每一个渲染操作都可以单独地使用保存在当前OpenGLES上下文中的设置来开启或关闭。<br>在第5步中，glVertexAttribPointer()告诉OpenGLES顶点数据在哪里，以及怎么解释为每个顶点保存的数据。第一个参数指示当前绑定的缓存包含每个顶点的位置信息；第二个参数指示每个位置有3个部分；第三个参数告诉OpenGLES每个部分都保存为一个浮点类型的值；第四个参数告诉OpenGLES小数点固定数据是否可以被改变；第五个参数叫做“步幅”，它指定了每个顶点的保存需要多少个字节，换句话说，步幅指定了GPU从一个顶点的内存开始位置转到下一个顶点的内存开始位置需要跳过多少字节,sizeof(GLKVector3)指示在缓存中没有额外的字节，即顶点位置数据是密封的，在一个顶点缓存中保存除了每个顶点位置的X Y Z坐标之外的其他数据也是可能的；</p>\n</blockquote>\n<ul>\n<li>glVertexAttribPointer </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void glVertexAttribPointer( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid * pointer);</span><br></pre></td></tr></table></figure>\n<p>参数：<br><em>index</em><br>指定要修改的顶点属性的索引值<br><em>size</em><br>指定每个顶点属性的组件数量。必须为1、2、3或者4。初始值为4。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a））<br><em>type</em><br>指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。<br><em>normalized</em><br>指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）。<br><em>stride</em><br>指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0。<br><em>pointer</em><br>指定第一个组件在数组的第一个顶点属性中的偏移量。该数组与GL_ARRAY_BUFFER绑定，储存于缓冲区中。初始值为0；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Submits the drawing command identified by mode and instructs</span><br><span class=\"line\">// OpenGL ES to use count vertices from the buffer starting from</span><br><span class=\"line\">// the vertex at index first. Vertex indices start at 0.</span><br><span class=\"line\">- (void)drawArrayWithMode:(GLenum)mode</span><br><span class=\"line\">   startVertexIndex:(GLint)first</span><br><span class=\"line\">   numberOfVertices:(GLsizei)count</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   NSAssert(self.bufferSizeBytes &gt;= </span><br><span class=\"line\">      ((first + count) * self.stride),</span><br><span class=\"line\">      @&quot;Attempt to draw more vertex data than available.&quot;);</span><br><span class=\"line\">      </span><br><span class=\"line\">   glDrawArrays(mode, first, count); // Step 6</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glDrawArrays</li>\n</ul>\n<p>glDrawArrays()第一个参数会告诉GPU怎么处理在绑定的顶点缓存内的顶点数据；第二个参数和第三个参数分别指定缓存内的需要渲染的第一个顶点的位置和需要渲染的顶点的数量；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This method deletes the receiver&apos;s buffer from the current</span><br><span class=\"line\">// Context when the receiver is deallocated.</span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Delete buffer from current context</span><br><span class=\"line\">    if (0 != name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glDeleteBuffers(1, &amp;name); // Step 7 </span><br><span class=\"line\">        name = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>glDeleteBuffers</li>\n</ul>\n<p>删除不需再需要的顶点缓存和上下文，该方法保证Cocoa Touch收回上下文使用的内存和其他资源。</p>\n<p><a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch_2_GL/OpenGLES_Ch2_3\" target=\"_blank\" rel=\"noopener\">本例的代码下载链接</a></p>"},{"title":"北欧神话拾遗：“奥丁”，“英灵殿”，“提尔”，“西芙”，这些名字你知道吗？","date":"2016-08-17T00:48:00.000Z","_content":"\n![奥丁](http://upload-images.jianshu.io/upload_images/1429775-b92b97202ecd19e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n奥丁是北欧阿斯神族的至高神，被视作诸神之王，也是死者之王、战神、权力之神、魔法之神。传说中，奥丁身形高大，身披金甲，骑八足神马“斯莱普尼斯”(Sleipnir)，手持名枪“冈格尼尔”(Gungnir)，居住在“瓦尔哈拉”的神殿中。他让女武神收集死者魂魄，为终末之战“诸神的黄昏”做准备。他的英名为历代北欧维京人所景仰，维京人坚信，如果英勇战死，就可以进入“瓦尔哈拉”，所以战斗勇猛无比，其势力曾席卷大半个欧洲。\n\n>Valhalla，奥丁（Odin）在阿瑟加德有三处宫殿，其中有一个，位处格拉希尔（Glasir）树林之中，名为瓦尔哈拉（Valhalla，英灵殿），有五百四十个大门，每个门宽可容八百位战士并排进出。正门上方有一个野猪的头和一只鹰；这鹰的锐目能看见世界的各方。宫殿的四壁是由擦得极亮的矛所排成，所以光明炫耀；宫的顶是金盾铺成。宫内的座椅上皆覆以精美的铠甲，这是奥丁（Odin）给他的客人的礼物。凡是战死的勇士，所谓恩赫里亚（Einheriar），为奥丁（Odin）所器重者，皆得入此宫为上客。\n\n以上的介绍与魔兽世界中的奥丁的故事几乎是一模一样，甚至所谓的瓦尔哈拉即英灵殿用的同名。\n\n西芙是雷神托尔的妻子，土地和收获女神。特别值得称道的是她有一头金色的长发，闪耀着比金子还要美丽的光泽。西芙女神为此感到非常的自豪，经常坐在她的花园中梳理那一头金发，这就引起了洛基恶作剧的念头。洛基在西芙睡觉的时候，把她引以为傲的一头金发剪得一干二净。洛基的恶作剧使得西芙非常地悲伤。就在西芙嘤嘤地哭泣的时候，雷神托尔回到了家中。托尔马上知道这是洛基干的坏事，于是冲出家门抓住了洛基，准备把他身上的骨头拆下来。洛基疼痛彻骨，拼命求饶，发誓去找侏儒国中的能工巧匠，为西芙打造一副一模一样的能够自由生长的金子头发。托尔的雷神之锤亦是洛基此行一并让侏儒工匠打造出的神器之一。\n\n提尔是战神，巨人希米儿之子，《埃达》中将称他为“众神之父”。传说他是契约的担保人，盟誓的临护者。当其他的神为了将芬里斯怪狼捆绑起来的时候，提尔作为信用的保证人将手臂伸进狼的嘴里。狼发现搁绑它的众神实际上是设下圈套，立即咬断提尔的手臂。从此提尔成了独臂神。但他身佩宝剑，总显得威风凛凛。古代按剑盟誓的习俗即起源于北欧人对战神提尔的崇拜。许多传统的剑舞，都是为纪念战神而编导的。\n\n霍迪尔是黑暗之神，巴德尔的孪生兄弟，双目失明。他生性忧郁孤僻，坚持与光明为敌。他受火神洛基指使，亲手杀死了自己的兄弟光明之神。\n\n上面这些人便是上篇中说的一些人物的原型，他们之中有些人的故事经过扭曲，但大体上人物性格保留了下来，基本上魔兽世界对这些人物的处理还是比较善意的。总结来看，奥丁与英灵殿的故事是照搬，而且作为至高神的他是创世父阿曼苏尔的继承者也符合原型故事，后面英灵殿的放逐多半是带有魔幻色彩的，是暴雪一个比较微妙的处理；西芙的人设是作为一个中间人物来看的，由一个女人引发两个甚至更多男人之间的争斗这种桥段是很符合故事发展的，如果比较魔兽与北欧神话，也只能这样牵强的解释一下；而提尔依旧符合原神话的人设，魔兽中仍以战神来看待，同时独臂的故事更加深了这个人物的设定，魔兽中的白银之手更加深了人们对它的印象，可见北欧人对战神提尔的崇拜的确深入人心；而霍迪尔只是借用了它的名字而矣，魔兽是个庞大的世界观，要说其现实世界的灵感来源，通常我们更容易关注到的是更加便于识别的各类文化符号。\n\n至于魔兽世界之后的种族又影射了哪些历史文化，知乎上有篇文章写的很好，关注公众号“艾泽拉斯日常”获取更多。之后我们也会在后来的文章中逐个深扒，看这样的一个游戏世界，究竟是怎样混杂出来的。","source":"_posts/北欧神话拾遗：“奥丁”，“英灵殿”，“提尔”，“西芙”，这些名字你知道吗？.md","raw":"title: 北欧神话拾遗：“奥丁”，“英灵殿”，“提尔”，“西芙”，这些名字你知道吗？\ndate: 2016-08-17 08:48:00\ncategories: Azeroth\n-----------\n\n![奥丁](http://upload-images.jianshu.io/upload_images/1429775-b92b97202ecd19e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n奥丁是北欧阿斯神族的至高神，被视作诸神之王，也是死者之王、战神、权力之神、魔法之神。传说中，奥丁身形高大，身披金甲，骑八足神马“斯莱普尼斯”(Sleipnir)，手持名枪“冈格尼尔”(Gungnir)，居住在“瓦尔哈拉”的神殿中。他让女武神收集死者魂魄，为终末之战“诸神的黄昏”做准备。他的英名为历代北欧维京人所景仰，维京人坚信，如果英勇战死，就可以进入“瓦尔哈拉”，所以战斗勇猛无比，其势力曾席卷大半个欧洲。\n\n>Valhalla，奥丁（Odin）在阿瑟加德有三处宫殿，其中有一个，位处格拉希尔（Glasir）树林之中，名为瓦尔哈拉（Valhalla，英灵殿），有五百四十个大门，每个门宽可容八百位战士并排进出。正门上方有一个野猪的头和一只鹰；这鹰的锐目能看见世界的各方。宫殿的四壁是由擦得极亮的矛所排成，所以光明炫耀；宫的顶是金盾铺成。宫内的座椅上皆覆以精美的铠甲，这是奥丁（Odin）给他的客人的礼物。凡是战死的勇士，所谓恩赫里亚（Einheriar），为奥丁（Odin）所器重者，皆得入此宫为上客。\n\n以上的介绍与魔兽世界中的奥丁的故事几乎是一模一样，甚至所谓的瓦尔哈拉即英灵殿用的同名。\n\n西芙是雷神托尔的妻子，土地和收获女神。特别值得称道的是她有一头金色的长发，闪耀着比金子还要美丽的光泽。西芙女神为此感到非常的自豪，经常坐在她的花园中梳理那一头金发，这就引起了洛基恶作剧的念头。洛基在西芙睡觉的时候，把她引以为傲的一头金发剪得一干二净。洛基的恶作剧使得西芙非常地悲伤。就在西芙嘤嘤地哭泣的时候，雷神托尔回到了家中。托尔马上知道这是洛基干的坏事，于是冲出家门抓住了洛基，准备把他身上的骨头拆下来。洛基疼痛彻骨，拼命求饶，发誓去找侏儒国中的能工巧匠，为西芙打造一副一模一样的能够自由生长的金子头发。托尔的雷神之锤亦是洛基此行一并让侏儒工匠打造出的神器之一。\n\n提尔是战神，巨人希米儿之子，《埃达》中将称他为“众神之父”。传说他是契约的担保人，盟誓的临护者。当其他的神为了将芬里斯怪狼捆绑起来的时候，提尔作为信用的保证人将手臂伸进狼的嘴里。狼发现搁绑它的众神实际上是设下圈套，立即咬断提尔的手臂。从此提尔成了独臂神。但他身佩宝剑，总显得威风凛凛。古代按剑盟誓的习俗即起源于北欧人对战神提尔的崇拜。许多传统的剑舞，都是为纪念战神而编导的。\n\n霍迪尔是黑暗之神，巴德尔的孪生兄弟，双目失明。他生性忧郁孤僻，坚持与光明为敌。他受火神洛基指使，亲手杀死了自己的兄弟光明之神。\n\n上面这些人便是上篇中说的一些人物的原型，他们之中有些人的故事经过扭曲，但大体上人物性格保留了下来，基本上魔兽世界对这些人物的处理还是比较善意的。总结来看，奥丁与英灵殿的故事是照搬，而且作为至高神的他是创世父阿曼苏尔的继承者也符合原型故事，后面英灵殿的放逐多半是带有魔幻色彩的，是暴雪一个比较微妙的处理；西芙的人设是作为一个中间人物来看的，由一个女人引发两个甚至更多男人之间的争斗这种桥段是很符合故事发展的，如果比较魔兽与北欧神话，也只能这样牵强的解释一下；而提尔依旧符合原神话的人设，魔兽中仍以战神来看待，同时独臂的故事更加深了这个人物的设定，魔兽中的白银之手更加深了人们对它的印象，可见北欧人对战神提尔的崇拜的确深入人心；而霍迪尔只是借用了它的名字而矣，魔兽是个庞大的世界观，要说其现实世界的灵感来源，通常我们更容易关注到的是更加便于识别的各类文化符号。\n\n至于魔兽世界之后的种族又影射了哪些历史文化，知乎上有篇文章写的很好，关注公众号“艾泽拉斯日常”获取更多。之后我们也会在后来的文章中逐个深扒，看这样的一个游戏世界，究竟是怎样混杂出来的。","slug":"北欧神话拾遗：“奥丁”，“英灵殿”，“提尔”，“西芙”，这些名字你知道吗？","published":1,"updated":"2018-05-04T10:29:55.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciop00201v605v7y9jg5","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-b92b97202ecd19e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奥丁\"></p>\n<a id=\"more\"></a>\n<p>奥丁是北欧阿斯神族的至高神，被视作诸神之王，也是死者之王、战神、权力之神、魔法之神。传说中，奥丁身形高大，身披金甲，骑八足神马“斯莱普尼斯”(Sleipnir)，手持名枪“冈格尼尔”(Gungnir)，居住在“瓦尔哈拉”的神殿中。他让女武神收集死者魂魄，为终末之战“诸神的黄昏”做准备。他的英名为历代北欧维京人所景仰，维京人坚信，如果英勇战死，就可以进入“瓦尔哈拉”，所以战斗勇猛无比，其势力曾席卷大半个欧洲。</p>\n<blockquote>\n<p>Valhalla，奥丁（Odin）在阿瑟加德有三处宫殿，其中有一个，位处格拉希尔（Glasir）树林之中，名为瓦尔哈拉（Valhalla，英灵殿），有五百四十个大门，每个门宽可容八百位战士并排进出。正门上方有一个野猪的头和一只鹰；这鹰的锐目能看见世界的各方。宫殿的四壁是由擦得极亮的矛所排成，所以光明炫耀；宫的顶是金盾铺成。宫内的座椅上皆覆以精美的铠甲，这是奥丁（Odin）给他的客人的礼物。凡是战死的勇士，所谓恩赫里亚（Einheriar），为奥丁（Odin）所器重者，皆得入此宫为上客。</p>\n</blockquote>\n<p>以上的介绍与魔兽世界中的奥丁的故事几乎是一模一样，甚至所谓的瓦尔哈拉即英灵殿用的同名。</p>\n<p>西芙是雷神托尔的妻子，土地和收获女神。特别值得称道的是她有一头金色的长发，闪耀着比金子还要美丽的光泽。西芙女神为此感到非常的自豪，经常坐在她的花园中梳理那一头金发，这就引起了洛基恶作剧的念头。洛基在西芙睡觉的时候，把她引以为傲的一头金发剪得一干二净。洛基的恶作剧使得西芙非常地悲伤。就在西芙嘤嘤地哭泣的时候，雷神托尔回到了家中。托尔马上知道这是洛基干的坏事，于是冲出家门抓住了洛基，准备把他身上的骨头拆下来。洛基疼痛彻骨，拼命求饶，发誓去找侏儒国中的能工巧匠，为西芙打造一副一模一样的能够自由生长的金子头发。托尔的雷神之锤亦是洛基此行一并让侏儒工匠打造出的神器之一。</p>\n<p>提尔是战神，巨人希米儿之子，《埃达》中将称他为“众神之父”。传说他是契约的担保人，盟誓的临护者。当其他的神为了将芬里斯怪狼捆绑起来的时候，提尔作为信用的保证人将手臂伸进狼的嘴里。狼发现搁绑它的众神实际上是设下圈套，立即咬断提尔的手臂。从此提尔成了独臂神。但他身佩宝剑，总显得威风凛凛。古代按剑盟誓的习俗即起源于北欧人对战神提尔的崇拜。许多传统的剑舞，都是为纪念战神而编导的。</p>\n<p>霍迪尔是黑暗之神，巴德尔的孪生兄弟，双目失明。他生性忧郁孤僻，坚持与光明为敌。他受火神洛基指使，亲手杀死了自己的兄弟光明之神。</p>\n<p>上面这些人便是上篇中说的一些人物的原型，他们之中有些人的故事经过扭曲，但大体上人物性格保留了下来，基本上魔兽世界对这些人物的处理还是比较善意的。总结来看，奥丁与英灵殿的故事是照搬，而且作为至高神的他是创世父阿曼苏尔的继承者也符合原型故事，后面英灵殿的放逐多半是带有魔幻色彩的，是暴雪一个比较微妙的处理；西芙的人设是作为一个中间人物来看的，由一个女人引发两个甚至更多男人之间的争斗这种桥段是很符合故事发展的，如果比较魔兽与北欧神话，也只能这样牵强的解释一下；而提尔依旧符合原神话的人设，魔兽中仍以战神来看待，同时独臂的故事更加深了这个人物的设定，魔兽中的白银之手更加深了人们对它的印象，可见北欧人对战神提尔的崇拜的确深入人心；而霍迪尔只是借用了它的名字而矣，魔兽是个庞大的世界观，要说其现实世界的灵感来源，通常我们更容易关注到的是更加便于识别的各类文化符号。</p>\n<p>至于魔兽世界之后的种族又影射了哪些历史文化，知乎上有篇文章写的很好，关注公众号“艾泽拉斯日常”获取更多。之后我们也会在后来的文章中逐个深扒，看这样的一个游戏世界，究竟是怎样混杂出来的。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-b92b97202ecd19e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奥丁\"></p>","more":"<p>奥丁是北欧阿斯神族的至高神，被视作诸神之王，也是死者之王、战神、权力之神、魔法之神。传说中，奥丁身形高大，身披金甲，骑八足神马“斯莱普尼斯”(Sleipnir)，手持名枪“冈格尼尔”(Gungnir)，居住在“瓦尔哈拉”的神殿中。他让女武神收集死者魂魄，为终末之战“诸神的黄昏”做准备。他的英名为历代北欧维京人所景仰，维京人坚信，如果英勇战死，就可以进入“瓦尔哈拉”，所以战斗勇猛无比，其势力曾席卷大半个欧洲。</p>\n<blockquote>\n<p>Valhalla，奥丁（Odin）在阿瑟加德有三处宫殿，其中有一个，位处格拉希尔（Glasir）树林之中，名为瓦尔哈拉（Valhalla，英灵殿），有五百四十个大门，每个门宽可容八百位战士并排进出。正门上方有一个野猪的头和一只鹰；这鹰的锐目能看见世界的各方。宫殿的四壁是由擦得极亮的矛所排成，所以光明炫耀；宫的顶是金盾铺成。宫内的座椅上皆覆以精美的铠甲，这是奥丁（Odin）给他的客人的礼物。凡是战死的勇士，所谓恩赫里亚（Einheriar），为奥丁（Odin）所器重者，皆得入此宫为上客。</p>\n</blockquote>\n<p>以上的介绍与魔兽世界中的奥丁的故事几乎是一模一样，甚至所谓的瓦尔哈拉即英灵殿用的同名。</p>\n<p>西芙是雷神托尔的妻子，土地和收获女神。特别值得称道的是她有一头金色的长发，闪耀着比金子还要美丽的光泽。西芙女神为此感到非常的自豪，经常坐在她的花园中梳理那一头金发，这就引起了洛基恶作剧的念头。洛基在西芙睡觉的时候，把她引以为傲的一头金发剪得一干二净。洛基的恶作剧使得西芙非常地悲伤。就在西芙嘤嘤地哭泣的时候，雷神托尔回到了家中。托尔马上知道这是洛基干的坏事，于是冲出家门抓住了洛基，准备把他身上的骨头拆下来。洛基疼痛彻骨，拼命求饶，发誓去找侏儒国中的能工巧匠，为西芙打造一副一模一样的能够自由生长的金子头发。托尔的雷神之锤亦是洛基此行一并让侏儒工匠打造出的神器之一。</p>\n<p>提尔是战神，巨人希米儿之子，《埃达》中将称他为“众神之父”。传说他是契约的担保人，盟誓的临护者。当其他的神为了将芬里斯怪狼捆绑起来的时候，提尔作为信用的保证人将手臂伸进狼的嘴里。狼发现搁绑它的众神实际上是设下圈套，立即咬断提尔的手臂。从此提尔成了独臂神。但他身佩宝剑，总显得威风凛凛。古代按剑盟誓的习俗即起源于北欧人对战神提尔的崇拜。许多传统的剑舞，都是为纪念战神而编导的。</p>\n<p>霍迪尔是黑暗之神，巴德尔的孪生兄弟，双目失明。他生性忧郁孤僻，坚持与光明为敌。他受火神洛基指使，亲手杀死了自己的兄弟光明之神。</p>\n<p>上面这些人便是上篇中说的一些人物的原型，他们之中有些人的故事经过扭曲，但大体上人物性格保留了下来，基本上魔兽世界对这些人物的处理还是比较善意的。总结来看，奥丁与英灵殿的故事是照搬，而且作为至高神的他是创世父阿曼苏尔的继承者也符合原型故事，后面英灵殿的放逐多半是带有魔幻色彩的，是暴雪一个比较微妙的处理；西芙的人设是作为一个中间人物来看的，由一个女人引发两个甚至更多男人之间的争斗这种桥段是很符合故事发展的，如果比较魔兽与北欧神话，也只能这样牵强的解释一下；而提尔依旧符合原神话的人设，魔兽中仍以战神来看待，同时独臂的故事更加深了这个人物的设定，魔兽中的白银之手更加深了人们对它的印象，可见北欧人对战神提尔的崇拜的确深入人心；而霍迪尔只是借用了它的名字而矣，魔兽是个庞大的世界观，要说其现实世界的灵感来源，通常我们更容易关注到的是更加便于识别的各类文化符号。</p>\n<p>至于魔兽世界之后的种族又影射了哪些历史文化，知乎上有篇文章写的很好，关注公众号“艾泽拉斯日常”获取更多。之后我们也会在后来的文章中逐个深扒，看这样的一个游戏世界，究竟是怎样混杂出来的。</p>"},{"title":"宇宙恐怖组织的形成","date":"2016-08-10T03:59:00.000Z","_content":"\n上篇讲到宇宙泰坦诞生并建立起了一个有秩序的宇宙世界，这篇我们说一说两大宇宙恐怖组织的建立。\n\n纵观整个魔兽的黑暗历史，有两个庞大的组织势力最为广泛，几乎世界所有的不和谐皆出自这些家伙的手笔。世间有光明，就有黑暗，有恶才有善，大凡贤者都会这么讲。所以他们的存在也很必要。\n\n![图为IS恐怖组织，与本文无关](http://upload-images.jianshu.io/upload_images/1429775-37c7257969843a83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n这两个组织分别是：以虚空大君与上古之神为主导的黑暗恐怖组织和以黑暗泰坦萨格拉斯领导的燃烧军团恐怖组织。前者出自宇宙黑暗区，有泰坦的时候它们便也存在了，这些家伙与泰坦比起来较弱，但有一个特点，它们的腐化能力比较强，发展的形式像细胞分裂那样，创造一条感染链；后者是伟大的泰坦战士萨格拉斯堕落后的结果，拜前者所赐。\n\n![长的是够恶心的，而且这还是和谐之后的图片](http://upload-images.jianshu.io/upload_images/1429775-2ee168998896a8af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们说其实在扭曲虚空（黑暗区小弟）存在时，恶魔便已经开始诞生。这些物种都是一些没有人领导，拥有破坏性且有无尽破坏性欲望的无脑群体。在宇宙中就像是寄生虫，这小黑暗区毕竟区域局限，于是这些家伙便往外扩张。一扩张不要紧，遭殃的肯定是实体区。\n\n![萨格拉斯堕落后](http://upload-images.jianshu.io/upload_images/1429775-e5dc4717f3baa12e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n万神殿的神仙们也坐不住了，你们明目张胆地残杀我们没有出生的同胞，这怎么行？于是就派出最强大的泰坦战士萨格拉斯去消灭这些杂碎。这里我们插播点有用的知识，你们一定不知道恶魔都是什么样子的。其实恶魔的概念就是魔兽中恶魔的概念，玩过术士的人一定不会陌生，像小鬼，狗，魅魔等术士的宠物都是恶魔物种，成分呢在原书中的解释是“用物质与邪能糅合的无脑团块”，很形象，基本可以想像得到。另外我们在魔兽争覇里所用到的英雄恐惧魔王和深渊领主，是扭曲虚空的最高级产物，这两位在之后的故事中也有很足的戏份。恐惧魔王又名纳斯雷兹姆，深渊领主又名安尼希兰，而深渊领主在之后会有一次重命名的经历。\n\n![恶魔团部分成员](http://upload-images.jianshu.io/upload_images/1429775-f9be0b5cb995de0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n萨格拉斯真是万神殿不可多得的勇士，轻而易举的就把染指实体宇宙的恶魔消灭。但是萨格拉斯发现，他杀掉的恶魔越多，新生的恶魔也就越多，这个奇怪现象曾一度让萨格拉斯困惑。原来恶魔的背后是被我们的虚空大君操控的，虚空毕竟也绝非善类，也是有点能力兴风作浪的，虚空不停的将能量注入扭曲虚空，恶魔便不停的增长。终于萨格拉斯一拳难敌四手，向神届发了个信号说，我快不行啦，啊，我的仆从，听从我的召唤。于是神届给小萨派了个叫阿格拉玛的小弟，小弟虽不及萨格拉斯能打，但也是数一数二的人物。而且小玛又很谦逊，还拜小萨为恩师。在小玛的帮助下，小萨成功的阻止了恶魔，并在宇宙里生生开辟出了一个区域，叫做放逐位面：马顿。\n\n![据说军团再临有关阿格拉玛的任务线](http://upload-images.jianshu.io/upload_images/1429775-3c607e083ce60d3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n小萨把抓到的恶魔都关到了宇宙马顿空间监狱里，被关到里面的恶魔就再也出不来了。而这师徒二人则在宇宙中继续诛杀着恶魔。\n\n虚空大大们这下也慌了，这群恶魔废物看来不行，还是得靠自己。他们开始研究自己的黑魔法，开始从这些初生的泰坦婴儿下手，真是不要脸到极致。不要脸也能干成大事，虚空发现这泰坦的力量要是真被自己捕获，那就好比是吸星大法那样，泰坦的神力我虚空也能享有了，这招好。于是虚空大大们全宇宙的找泰坦，刚好跟神届的那些位神们做着同样的事情。\n\n相见不如偶遇，不巧的是，虚空大大还真跟小萨给遇上了。那个时候虚空先小萨一步，在给新生的小泰坦喂“黑奶”，把孩子给喂成了个小黑人。小萨一看，吓了一大跳，这黑家伙怎么能是我的同胞呢，但是略显厉害啊，这真要长大了恐怕连我也给干死。于是小萨一害怕，一刀把这小家伙给解决了，虚空也跟着死掉。\n\n![万神殿臆想图](http://upload-images.jianshu.io/upload_images/1429775-b41522e972c89822.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n回到神届小萨就跟众位仙人说这样的家伙不能留，得全部干掉，要不咱们一起都得完蛋。神父阿曼苏尔不同意，说怎么着这也是咱兄弟，手心手背都是坦啊，不能杀。其他众仙也跟着说不行，虎毒还不食子呢么，小萨你这干的不厚道啊。小萨说不过，一气之下说了一句将影响他后来作为的话“存在本身即有着缺陷”，没想到我们的小萨还是个哲学家，讲这么有哲理的话。\n\n小萨想你们这群蠢货不干，我萨格拉斯可是宇宙第一战士，解决几个黑小孩还不手到擒来，我他丫的自己干。于是，小萨脱离神届组织自立门户，想着自己干得有小弟么不是，在宇宙转了一圈可是什么也没找到。想着想着就转到了空间监狱马顿这里，小萨想这里面不是有好多生物么，我给他们放出来，这些家伙又打不过我，我不就成他们领导了？\n\n![撕裂](http://upload-images.jianshu.io/upload_images/1429775-5a53996868229a62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n说干就干，小萨用神力把马顿扯个稀碎，万万没想到这马顿也早已被虚空大大腐化，这一放，虚空能量嗞小萨一身，小萨就这样被感染了。感染后的小萨当然要变个身，力量也大了不少，于是他就带着这群牢房里的乌合之众成立了宇宙第二天团，还起了个响亮的名字：燃烧军团。这么一来，军队是有了，可是都是一帮没脑子的楞头青，也难成个什么气候，还得有点智商高的来领导才行，这些领导者就是阿古斯的艾瑞达人，艾瑞达其实一点也不陌生，他们就是德兰尼的前身，关于艾瑞达后面还要详细说。\n![艾瑞达三巨头](http://upload-images.jianshu.io/upload_images/1429775-0e8c5560a72bff5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n军团有了，领导层也有了，目标必须树立一个，否则这军心实难稳定。小萨就高举“捣毁一切”旗帜开始了在宇宙中无尽的远征……\n\n魔兽世界两大恐怖组织的建立大致就是这样，这两大组织在今后胡作非为，不仅自己制造邪恶还逼良为娼，为魔兽所不齿，为每一个艾泽拉斯人民所痛恨。\n\n这篇就写到这吧，欢迎关注哦。","source":"_posts/宇宙恐怖组织的形成.md","raw":"title: 宇宙恐怖组织的形成\ndate: 2016-08-10 11:59:00\ncategories: Azeroth\n-----------\n\n上篇讲到宇宙泰坦诞生并建立起了一个有秩序的宇宙世界，这篇我们说一说两大宇宙恐怖组织的建立。\n\n纵观整个魔兽的黑暗历史，有两个庞大的组织势力最为广泛，几乎世界所有的不和谐皆出自这些家伙的手笔。世间有光明，就有黑暗，有恶才有善，大凡贤者都会这么讲。所以他们的存在也很必要。\n\n![图为IS恐怖组织，与本文无关](http://upload-images.jianshu.io/upload_images/1429775-37c7257969843a83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n这两个组织分别是：以虚空大君与上古之神为主导的黑暗恐怖组织和以黑暗泰坦萨格拉斯领导的燃烧军团恐怖组织。前者出自宇宙黑暗区，有泰坦的时候它们便也存在了，这些家伙与泰坦比起来较弱，但有一个特点，它们的腐化能力比较强，发展的形式像细胞分裂那样，创造一条感染链；后者是伟大的泰坦战士萨格拉斯堕落后的结果，拜前者所赐。\n\n![长的是够恶心的，而且这还是和谐之后的图片](http://upload-images.jianshu.io/upload_images/1429775-2ee168998896a8af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们说其实在扭曲虚空（黑暗区小弟）存在时，恶魔便已经开始诞生。这些物种都是一些没有人领导，拥有破坏性且有无尽破坏性欲望的无脑群体。在宇宙中就像是寄生虫，这小黑暗区毕竟区域局限，于是这些家伙便往外扩张。一扩张不要紧，遭殃的肯定是实体区。\n\n![萨格拉斯堕落后](http://upload-images.jianshu.io/upload_images/1429775-e5dc4717f3baa12e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n万神殿的神仙们也坐不住了，你们明目张胆地残杀我们没有出生的同胞，这怎么行？于是就派出最强大的泰坦战士萨格拉斯去消灭这些杂碎。这里我们插播点有用的知识，你们一定不知道恶魔都是什么样子的。其实恶魔的概念就是魔兽中恶魔的概念，玩过术士的人一定不会陌生，像小鬼，狗，魅魔等术士的宠物都是恶魔物种，成分呢在原书中的解释是“用物质与邪能糅合的无脑团块”，很形象，基本可以想像得到。另外我们在魔兽争覇里所用到的英雄恐惧魔王和深渊领主，是扭曲虚空的最高级产物，这两位在之后的故事中也有很足的戏份。恐惧魔王又名纳斯雷兹姆，深渊领主又名安尼希兰，而深渊领主在之后会有一次重命名的经历。\n\n![恶魔团部分成员](http://upload-images.jianshu.io/upload_images/1429775-f9be0b5cb995de0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n萨格拉斯真是万神殿不可多得的勇士，轻而易举的就把染指实体宇宙的恶魔消灭。但是萨格拉斯发现，他杀掉的恶魔越多，新生的恶魔也就越多，这个奇怪现象曾一度让萨格拉斯困惑。原来恶魔的背后是被我们的虚空大君操控的，虚空毕竟也绝非善类，也是有点能力兴风作浪的，虚空不停的将能量注入扭曲虚空，恶魔便不停的增长。终于萨格拉斯一拳难敌四手，向神届发了个信号说，我快不行啦，啊，我的仆从，听从我的召唤。于是神届给小萨派了个叫阿格拉玛的小弟，小弟虽不及萨格拉斯能打，但也是数一数二的人物。而且小玛又很谦逊，还拜小萨为恩师。在小玛的帮助下，小萨成功的阻止了恶魔，并在宇宙里生生开辟出了一个区域，叫做放逐位面：马顿。\n\n![据说军团再临有关阿格拉玛的任务线](http://upload-images.jianshu.io/upload_images/1429775-3c607e083ce60d3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n小萨把抓到的恶魔都关到了宇宙马顿空间监狱里，被关到里面的恶魔就再也出不来了。而这师徒二人则在宇宙中继续诛杀着恶魔。\n\n虚空大大们这下也慌了，这群恶魔废物看来不行，还是得靠自己。他们开始研究自己的黑魔法，开始从这些初生的泰坦婴儿下手，真是不要脸到极致。不要脸也能干成大事，虚空发现这泰坦的力量要是真被自己捕获，那就好比是吸星大法那样，泰坦的神力我虚空也能享有了，这招好。于是虚空大大们全宇宙的找泰坦，刚好跟神届的那些位神们做着同样的事情。\n\n相见不如偶遇，不巧的是，虚空大大还真跟小萨给遇上了。那个时候虚空先小萨一步，在给新生的小泰坦喂“黑奶”，把孩子给喂成了个小黑人。小萨一看，吓了一大跳，这黑家伙怎么能是我的同胞呢，但是略显厉害啊，这真要长大了恐怕连我也给干死。于是小萨一害怕，一刀把这小家伙给解决了，虚空也跟着死掉。\n\n![万神殿臆想图](http://upload-images.jianshu.io/upload_images/1429775-b41522e972c89822.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n回到神届小萨就跟众位仙人说这样的家伙不能留，得全部干掉，要不咱们一起都得完蛋。神父阿曼苏尔不同意，说怎么着这也是咱兄弟，手心手背都是坦啊，不能杀。其他众仙也跟着说不行，虎毒还不食子呢么，小萨你这干的不厚道啊。小萨说不过，一气之下说了一句将影响他后来作为的话“存在本身即有着缺陷”，没想到我们的小萨还是个哲学家，讲这么有哲理的话。\n\n小萨想你们这群蠢货不干，我萨格拉斯可是宇宙第一战士，解决几个黑小孩还不手到擒来，我他丫的自己干。于是，小萨脱离神届组织自立门户，想着自己干得有小弟么不是，在宇宙转了一圈可是什么也没找到。想着想着就转到了空间监狱马顿这里，小萨想这里面不是有好多生物么，我给他们放出来，这些家伙又打不过我，我不就成他们领导了？\n\n![撕裂](http://upload-images.jianshu.io/upload_images/1429775-5a53996868229a62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n说干就干，小萨用神力把马顿扯个稀碎，万万没想到这马顿也早已被虚空大大腐化，这一放，虚空能量嗞小萨一身，小萨就这样被感染了。感染后的小萨当然要变个身，力量也大了不少，于是他就带着这群牢房里的乌合之众成立了宇宙第二天团，还起了个响亮的名字：燃烧军团。这么一来，军队是有了，可是都是一帮没脑子的楞头青，也难成个什么气候，还得有点智商高的来领导才行，这些领导者就是阿古斯的艾瑞达人，艾瑞达其实一点也不陌生，他们就是德兰尼的前身，关于艾瑞达后面还要详细说。\n![艾瑞达三巨头](http://upload-images.jianshu.io/upload_images/1429775-0e8c5560a72bff5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n军团有了，领导层也有了，目标必须树立一个，否则这军心实难稳定。小萨就高举“捣毁一切”旗帜开始了在宇宙中无尽的远征……\n\n魔兽世界两大恐怖组织的建立大致就是这样，这两大组织在今后胡作非为，不仅自己制造邪恶还逼良为娼，为魔兽所不齿，为每一个艾泽拉斯人民所痛恨。\n\n这篇就写到这吧，欢迎关注哦。","slug":"宇宙恐怖组织的形成","published":1,"updated":"2018-05-04T10:24:09.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucioq00231v60wkqup1vg","content":"<p>上篇讲到宇宙泰坦诞生并建立起了一个有秩序的宇宙世界，这篇我们说一说两大宇宙恐怖组织的建立。</p>\n<p>纵观整个魔兽的黑暗历史，有两个庞大的组织势力最为广泛，几乎世界所有的不和谐皆出自这些家伙的手笔。世间有光明，就有黑暗，有恶才有善，大凡贤者都会这么讲。所以他们的存在也很必要。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-37c7257969843a83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图为IS恐怖组织，与本文无关\"></p>\n<a id=\"more\"></a>\n<p>这两个组织分别是：以虚空大君与上古之神为主导的黑暗恐怖组织和以黑暗泰坦萨格拉斯领导的燃烧军团恐怖组织。前者出自宇宙黑暗区，有泰坦的时候它们便也存在了，这些家伙与泰坦比起来较弱，但有一个特点，它们的腐化能力比较强，发展的形式像细胞分裂那样，创造一条感染链；后者是伟大的泰坦战士萨格拉斯堕落后的结果，拜前者所赐。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-2ee168998896a8af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"长的是够恶心的，而且这还是和谐之后的图片\"></p>\n<p>我们说其实在扭曲虚空（黑暗区小弟）存在时，恶魔便已经开始诞生。这些物种都是一些没有人领导，拥有破坏性且有无尽破坏性欲望的无脑群体。在宇宙中就像是寄生虫，这小黑暗区毕竟区域局限，于是这些家伙便往外扩张。一扩张不要紧，遭殃的肯定是实体区。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-e5dc4717f3baa12e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"萨格拉斯堕落后\"></p>\n<p>万神殿的神仙们也坐不住了，你们明目张胆地残杀我们没有出生的同胞，这怎么行？于是就派出最强大的泰坦战士萨格拉斯去消灭这些杂碎。这里我们插播点有用的知识，你们一定不知道恶魔都是什么样子的。其实恶魔的概念就是魔兽中恶魔的概念，玩过术士的人一定不会陌生，像小鬼，狗，魅魔等术士的宠物都是恶魔物种，成分呢在原书中的解释是“用物质与邪能糅合的无脑团块”，很形象，基本可以想像得到。另外我们在魔兽争覇里所用到的英雄恐惧魔王和深渊领主，是扭曲虚空的最高级产物，这两位在之后的故事中也有很足的戏份。恐惧魔王又名纳斯雷兹姆，深渊领主又名安尼希兰，而深渊领主在之后会有一次重命名的经历。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-f9be0b5cb995de0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恶魔团部分成员\"></p>\n<p>萨格拉斯真是万神殿不可多得的勇士，轻而易举的就把染指实体宇宙的恶魔消灭。但是萨格拉斯发现，他杀掉的恶魔越多，新生的恶魔也就越多，这个奇怪现象曾一度让萨格拉斯困惑。原来恶魔的背后是被我们的虚空大君操控的，虚空毕竟也绝非善类，也是有点能力兴风作浪的，虚空不停的将能量注入扭曲虚空，恶魔便不停的增长。终于萨格拉斯一拳难敌四手，向神届发了个信号说，我快不行啦，啊，我的仆从，听从我的召唤。于是神届给小萨派了个叫阿格拉玛的小弟，小弟虽不及萨格拉斯能打，但也是数一数二的人物。而且小玛又很谦逊，还拜小萨为恩师。在小玛的帮助下，小萨成功的阻止了恶魔，并在宇宙里生生开辟出了一个区域，叫做放逐位面：马顿。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-3c607e083ce60d3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"据说军团再临有关阿格拉玛的任务线\"></p>\n<p>小萨把抓到的恶魔都关到了宇宙马顿空间监狱里，被关到里面的恶魔就再也出不来了。而这师徒二人则在宇宙中继续诛杀着恶魔。</p>\n<p>虚空大大们这下也慌了，这群恶魔废物看来不行，还是得靠自己。他们开始研究自己的黑魔法，开始从这些初生的泰坦婴儿下手，真是不要脸到极致。不要脸也能干成大事，虚空发现这泰坦的力量要是真被自己捕获，那就好比是吸星大法那样，泰坦的神力我虚空也能享有了，这招好。于是虚空大大们全宇宙的找泰坦，刚好跟神届的那些位神们做着同样的事情。</p>\n<p>相见不如偶遇，不巧的是，虚空大大还真跟小萨给遇上了。那个时候虚空先小萨一步，在给新生的小泰坦喂“黑奶”，把孩子给喂成了个小黑人。小萨一看，吓了一大跳，这黑家伙怎么能是我的同胞呢，但是略显厉害啊，这真要长大了恐怕连我也给干死。于是小萨一害怕，一刀把这小家伙给解决了，虚空也跟着死掉。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-b41522e972c89822.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"万神殿臆想图\"></p>\n<p>回到神届小萨就跟众位仙人说这样的家伙不能留，得全部干掉，要不咱们一起都得完蛋。神父阿曼苏尔不同意，说怎么着这也是咱兄弟，手心手背都是坦啊，不能杀。其他众仙也跟着说不行，虎毒还不食子呢么，小萨你这干的不厚道啊。小萨说不过，一气之下说了一句将影响他后来作为的话“存在本身即有着缺陷”，没想到我们的小萨还是个哲学家，讲这么有哲理的话。</p>\n<p>小萨想你们这群蠢货不干，我萨格拉斯可是宇宙第一战士，解决几个黑小孩还不手到擒来，我他丫的自己干。于是，小萨脱离神届组织自立门户，想着自己干得有小弟么不是，在宇宙转了一圈可是什么也没找到。想着想着就转到了空间监狱马顿这里，小萨想这里面不是有好多生物么，我给他们放出来，这些家伙又打不过我，我不就成他们领导了？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5a53996868229a62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"撕裂\"></p>\n<p>说干就干，小萨用神力把马顿扯个稀碎，万万没想到这马顿也早已被虚空大大腐化，这一放，虚空能量嗞小萨一身，小萨就这样被感染了。感染后的小萨当然要变个身，力量也大了不少，于是他就带着这群牢房里的乌合之众成立了宇宙第二天团，还起了个响亮的名字：燃烧军团。这么一来，军队是有了，可是都是一帮没脑子的楞头青，也难成个什么气候，还得有点智商高的来领导才行，这些领导者就是阿古斯的艾瑞达人，艾瑞达其实一点也不陌生，他们就是德兰尼的前身，关于艾瑞达后面还要详细说。<br><img src=\"http://upload-images.jianshu.io/upload_images/1429775-0e8c5560a72bff5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"艾瑞达三巨头\"></p>\n<p>军团有了，领导层也有了，目标必须树立一个，否则这军心实难稳定。小萨就高举“捣毁一切”旗帜开始了在宇宙中无尽的远征……</p>\n<p>魔兽世界两大恐怖组织的建立大致就是这样，这两大组织在今后胡作非为，不仅自己制造邪恶还逼良为娼，为魔兽所不齿，为每一个艾泽拉斯人民所痛恨。</p>\n<p>这篇就写到这吧，欢迎关注哦。</p>\n","site":{"data":{}},"excerpt":"<p>上篇讲到宇宙泰坦诞生并建立起了一个有秩序的宇宙世界，这篇我们说一说两大宇宙恐怖组织的建立。</p>\n<p>纵观整个魔兽的黑暗历史，有两个庞大的组织势力最为广泛，几乎世界所有的不和谐皆出自这些家伙的手笔。世间有光明，就有黑暗，有恶才有善，大凡贤者都会这么讲。所以他们的存在也很必要。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-37c7257969843a83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图为IS恐怖组织，与本文无关\"></p>","more":"<p>这两个组织分别是：以虚空大君与上古之神为主导的黑暗恐怖组织和以黑暗泰坦萨格拉斯领导的燃烧军团恐怖组织。前者出自宇宙黑暗区，有泰坦的时候它们便也存在了，这些家伙与泰坦比起来较弱，但有一个特点，它们的腐化能力比较强，发展的形式像细胞分裂那样，创造一条感染链；后者是伟大的泰坦战士萨格拉斯堕落后的结果，拜前者所赐。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-2ee168998896a8af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"长的是够恶心的，而且这还是和谐之后的图片\"></p>\n<p>我们说其实在扭曲虚空（黑暗区小弟）存在时，恶魔便已经开始诞生。这些物种都是一些没有人领导，拥有破坏性且有无尽破坏性欲望的无脑群体。在宇宙中就像是寄生虫，这小黑暗区毕竟区域局限，于是这些家伙便往外扩张。一扩张不要紧，遭殃的肯定是实体区。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-e5dc4717f3baa12e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"萨格拉斯堕落后\"></p>\n<p>万神殿的神仙们也坐不住了，你们明目张胆地残杀我们没有出生的同胞，这怎么行？于是就派出最强大的泰坦战士萨格拉斯去消灭这些杂碎。这里我们插播点有用的知识，你们一定不知道恶魔都是什么样子的。其实恶魔的概念就是魔兽中恶魔的概念，玩过术士的人一定不会陌生，像小鬼，狗，魅魔等术士的宠物都是恶魔物种，成分呢在原书中的解释是“用物质与邪能糅合的无脑团块”，很形象，基本可以想像得到。另外我们在魔兽争覇里所用到的英雄恐惧魔王和深渊领主，是扭曲虚空的最高级产物，这两位在之后的故事中也有很足的戏份。恐惧魔王又名纳斯雷兹姆，深渊领主又名安尼希兰，而深渊领主在之后会有一次重命名的经历。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-f9be0b5cb995de0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恶魔团部分成员\"></p>\n<p>萨格拉斯真是万神殿不可多得的勇士，轻而易举的就把染指实体宇宙的恶魔消灭。但是萨格拉斯发现，他杀掉的恶魔越多，新生的恶魔也就越多，这个奇怪现象曾一度让萨格拉斯困惑。原来恶魔的背后是被我们的虚空大君操控的，虚空毕竟也绝非善类，也是有点能力兴风作浪的，虚空不停的将能量注入扭曲虚空，恶魔便不停的增长。终于萨格拉斯一拳难敌四手，向神届发了个信号说，我快不行啦，啊，我的仆从，听从我的召唤。于是神届给小萨派了个叫阿格拉玛的小弟，小弟虽不及萨格拉斯能打，但也是数一数二的人物。而且小玛又很谦逊，还拜小萨为恩师。在小玛的帮助下，小萨成功的阻止了恶魔，并在宇宙里生生开辟出了一个区域，叫做放逐位面：马顿。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-3c607e083ce60d3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"据说军团再临有关阿格拉玛的任务线\"></p>\n<p>小萨把抓到的恶魔都关到了宇宙马顿空间监狱里，被关到里面的恶魔就再也出不来了。而这师徒二人则在宇宙中继续诛杀着恶魔。</p>\n<p>虚空大大们这下也慌了，这群恶魔废物看来不行，还是得靠自己。他们开始研究自己的黑魔法，开始从这些初生的泰坦婴儿下手，真是不要脸到极致。不要脸也能干成大事，虚空发现这泰坦的力量要是真被自己捕获，那就好比是吸星大法那样，泰坦的神力我虚空也能享有了，这招好。于是虚空大大们全宇宙的找泰坦，刚好跟神届的那些位神们做着同样的事情。</p>\n<p>相见不如偶遇，不巧的是，虚空大大还真跟小萨给遇上了。那个时候虚空先小萨一步，在给新生的小泰坦喂“黑奶”，把孩子给喂成了个小黑人。小萨一看，吓了一大跳，这黑家伙怎么能是我的同胞呢，但是略显厉害啊，这真要长大了恐怕连我也给干死。于是小萨一害怕，一刀把这小家伙给解决了，虚空也跟着死掉。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-b41522e972c89822.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"万神殿臆想图\"></p>\n<p>回到神届小萨就跟众位仙人说这样的家伙不能留，得全部干掉，要不咱们一起都得完蛋。神父阿曼苏尔不同意，说怎么着这也是咱兄弟，手心手背都是坦啊，不能杀。其他众仙也跟着说不行，虎毒还不食子呢么，小萨你这干的不厚道啊。小萨说不过，一气之下说了一句将影响他后来作为的话“存在本身即有着缺陷”，没想到我们的小萨还是个哲学家，讲这么有哲理的话。</p>\n<p>小萨想你们这群蠢货不干，我萨格拉斯可是宇宙第一战士，解决几个黑小孩还不手到擒来，我他丫的自己干。于是，小萨脱离神届组织自立门户，想着自己干得有小弟么不是，在宇宙转了一圈可是什么也没找到。想着想着就转到了空间监狱马顿这里，小萨想这里面不是有好多生物么，我给他们放出来，这些家伙又打不过我，我不就成他们领导了？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5a53996868229a62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"撕裂\"></p>\n<p>说干就干，小萨用神力把马顿扯个稀碎，万万没想到这马顿也早已被虚空大大腐化，这一放，虚空能量嗞小萨一身，小萨就这样被感染了。感染后的小萨当然要变个身，力量也大了不少，于是他就带着这群牢房里的乌合之众成立了宇宙第二天团，还起了个响亮的名字：燃烧军团。这么一来，军队是有了，可是都是一帮没脑子的楞头青，也难成个什么气候，还得有点智商高的来领导才行，这些领导者就是阿古斯的艾瑞达人，艾瑞达其实一点也不陌生，他们就是德兰尼的前身，关于艾瑞达后面还要详细说。<br><img src=\"http://upload-images.jianshu.io/upload_images/1429775-0e8c5560a72bff5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"艾瑞达三巨头\"></p>\n<p>军团有了，领导层也有了，目标必须树立一个，否则这军心实难稳定。小萨就高举“捣毁一切”旗帜开始了在宇宙中无尽的远征……</p>\n<p>魔兽世界两大恐怖组织的建立大致就是这样，这两大组织在今后胡作非为，不仅自己制造邪恶还逼良为娼，为魔兽所不齿，为每一个艾泽拉斯人民所痛恨。</p>\n<p>这篇就写到这吧，欢迎关注哦。</p>"},{"title":"开始OpenGLES的探索","date":"2016-03-01T02:20:00.000Z","_content":"\nSummary: 本系列文章是学习《OpenGL ES应用开发实践指南 iOS卷》的过程，学习过程中参照书中给出的例子运行并记录笔记，此篇是开篇，书中的例子可以从本文给出的地址下载。\n\n<!-- more -->\n\n##先介绍几个概念：\n\n>渲染：用3D数据生成一个2D图像的过程就叫做渲染；\n>\n>像素：计算机显示矩形的颜色点叫做像素；\n>\n>缓存：是指图形处理器能够控制和管理的连续RAM（原来就是内存）；\n>\n>帧缓存：内存中接收2D结果数据的缓冲区；\n>\n>上下文：是用于配置OpenGL ES的特定的软件平台的数据结构信息；\n\n##开始我们的OGE之旅：\n\n首先是添加两个框架，一个是用于调用OpenGL ES进行渲染的**OpenGLES.framework**，另外一个是用于对接iOS系统和OpenGLES的**GLKit.framework**，后者开放了一套方便OpenGLES环境设置的接口，方便iOS程序进行OpenGLES编程；\n\n```\n@interface OpenGLESViewController : GLKViewController\n{\n   GLuint vertexBufferID; //该值实际上是一个无符号整形，看名字可以看的出来\n}\n@property (strong, nonatomic) GLKBaseEffect *baseEffect;\n@end\n```\n下面这个结构体用来保存一个坐标，它是一个起始于坐标系原点的矢量（X,Y,Z）\n\n\n```\n//This data type is used to store information for each vertex\ntypedef struct {\n    GLKVector3  positionCoords;\n}SceneVertex;\n```\n\n```\n//用来定义三角形，以下空白部分是最后在屏幕上显示的结果，纯属娱乐\n/*\n *************\n **** ********\n ****  *******\n ****   ******\n ****    *****\n ****     ****\n *************\n *************\n*/\n// Define vertex data for a triangle to use in example\nstatic const SceneVertex vertices[] =\n{\n    {{-0.5f, -0.5f, 0.0}}, // lower left corner\n    {{ 0.5f, -0.5f, 0.0}}, // lower right corner\n    {{-0.5f,  0.5f, 0.0}}  // upper left corner\n};\n\n```\n\n##viewDidLoad\n\n先要将Controller的view强制转换成GLKView，GLKView提供了针对OpenGLES2.0版本的上下文，新建该类的上下文并将它设置为当前的上下文；\n\n```\n// Verify the type of view created automatically by the\n// Interface Builder storyboard\nGLKView *view = (GLKView *)self.view;\nNSAssert([view isKindOfClass:[GLKView class]],\n   \t\t   @\"View controller's view is not a GLKView\");\n```\n\nOpenGL ES的上下文不仅会保存它的状态，还会控制GPU去执行渲染运算,EAGLContext会封装一个特定于某个平台的上下文，一个应用可以使用多个上下文;\n\n```\n// Create an OpenGL ES 2.0 context and provide it to the\n// view\nview.context = [[EAGLContext alloc]\n\t\t\t\t\tinitWithAPI:kEAGLRenderingAPIOpenGLES2];\n\n//设置成当前上下文\n// Make the new context current\n[EAGLContext setCurrentContext:view.context];\n```\n\nGLKBaseEffect类提供了不依赖OGE版本的渲染方法，它会在需要的时候自动构建一个GPU程序,该实例使用恒定不变的白色来渲染像素;\n\n```\nself.baseEffect = [[GLKBaseEffect alloc] init];\nself.baseEffect.useConstantColor = GL_TRUE;\nself.baseEffect.constantColor = GLKVector4Make(\n\t\t\t\t\t\t\t\t     1.0f, // Red\n\t\t\t\t\t\t\t\t     1.0f, // Green\n\t\t\t\t\t\t\t\t     1.0f, // Blue\n\t\t\t\t\t\t\t\t     1.0f);// Alpha\n//设置当前OGE上下文为不透明黑色，该黑色由RGBA颜色元素值组成，用于在上下文帧缓存被清除时对每个像素进行初始化\nglClearColor(0.0f, 0.0f, 0.0f, 1.0f); // background color\n```\n\n以下代码用于定义三角形的数据必须要发送到GPU来进行渲染，创建三角形数据数组缓存的前三个步骤，对应以下步骤：\n\n\n1.为缓存生成一个唯一的标志符；\n\n\n2.为运算绑定缓存；\n\n\n3.复制数据到缓存；\n\n```\n// Generate, bind, and initialize contents of a buffer to be\n// stored in GPU memory\nglGenBuffers(1,                // STEP 1\n      &vertexBufferID);\nNSLog(@\"vertexBufferID = %p\",vertexBufferID);\n//该结果是一个指针，指向所生成标志符的内存保存位置；\n//缓存标志符在文档中叫做 \"names\"\n\nglBindBuffer(GL_ARRAY_BUFFER,  // STEP 2\n      vertexBufferID);\n//保存不同类型的标志符到OGE的不同位置，同一时刻只能绑定一个缓存，即使它们是相同类型的；\n//OpenGLES2.0只支持绑定两种类型，GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER；\n\nglBufferData(                  // STEP 3\n      GL_ARRAY_BUFFER,  // Initialize buffer contents\n      sizeof(vertices), // Number of bytes to copy\n      vertices,         // Address of bytes to copy\n      GL_STATIC_DRAW);  // Hint: cache in GPU memory\n//第四个参数提示缓存在未来运算中可能会被怎样使用\n//GL_STATIC_DRAW 提示缓存内容适合复制到内存中，而很少对其进行修改；\n//GL_DYNAMIC_DRAW 缓存数据会频繁改变，提示OGE上下文用不同方式处理\n```\n##glkView:drawInRect:\n\n每当一个GLKView需要重绘时，保存在视图中的上下文都会成为当前上下文；如需要，它还会保存一个来自Core Animation层的帧缓存，并调用下面的方法；\n\n此处接上面使用缓存的前三步；\n\n4.启动；\n\n5.设置指针；\n\n6.绘图；\n\n```\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n    [self.baseEffect prepareToDraw];\n\n    // Clear Frame Buffer (erase previous drawing)\n    //它的值是前面glClearColor()设置的；\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n\n    // Enable use of positions from bound vertex buffer\n    glEnableVertexAttribArray(      // STEP 4\n      GLKVertexAttribPosition);\n\n    glVertexAttribPointer(          // STEP 5\n      GLKVertexAttribPosition,\n      3,                   // three components per vertex\n      GL_FLOAT,            // data is floating point\n      GL_FALSE,            // no fixed point scaling\n      sizeof(SceneVertex), // no gaps in data\n      NULL);               // NULL tells GPU to start at\n                           // beginning of bound buffer\n\n    // Draw triangles using the first three vertices in the\n    // currently bound vertex buffer\n    glDrawArrays(GL_TRIANGLES,      // STEP 6\n     \t\t 0,  // Start with first vertex in currently bound buffer\n     \t\t 3); // Use three vertices from currently bound buffer\n}\n```\n\nglDrawArrays函数调用完成，此时所需要显示的场景已经完全显示或者GPU处理完成后会完全显示;\n\nCPU运算和GPU运算是异步的，这个例子的所有代码都是运行在CPU上的，需要进一步处理时会向GPU发送命令；GPU可能也会处理Core Animation层的命令，所以GPU总执行次数不一定；\n\n##viewDidUnload\n    \n```\n- (void)viewDidUnload\n{\n    [super viewDidUnload];\n\n    // Make the view's context current\n    GLKView *view = (GLKView *)self.view;\n    [EAGLContext setCurrentContext:view.context];\n\n    // Delete buffers that aren't needed when view is unloaded\n    if (0 != vertexBufferID)\n    {\n       glDeleteBuffers (1,          // STEP 7\n                        &vertexBufferID);\n       vertexBufferID = 0;\n    }\n\n    // Stop using the context created in -viewDidLoad\n    ((GLKView *)self.view).context = nil;\n    [EAGLContext setCurrentContext:nil];\n}\n\n```\n[点击此处下载本文例子](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch_2_1)\n\n\n","source":"_posts/开始OpenGLES的探索.md","raw":"title: 开始OpenGLES的探索\ndate: 2016-03-01 10:20:00\ncategories: coder\ntags: [opengles, GLKit]\n-----------\n\nSummary: 本系列文章是学习《OpenGL ES应用开发实践指南 iOS卷》的过程，学习过程中参照书中给出的例子运行并记录笔记，此篇是开篇，书中的例子可以从本文给出的地址下载。\n\n<!-- more -->\n\n##先介绍几个概念：\n\n>渲染：用3D数据生成一个2D图像的过程就叫做渲染；\n>\n>像素：计算机显示矩形的颜色点叫做像素；\n>\n>缓存：是指图形处理器能够控制和管理的连续RAM（原来就是内存）；\n>\n>帧缓存：内存中接收2D结果数据的缓冲区；\n>\n>上下文：是用于配置OpenGL ES的特定的软件平台的数据结构信息；\n\n##开始我们的OGE之旅：\n\n首先是添加两个框架，一个是用于调用OpenGL ES进行渲染的**OpenGLES.framework**，另外一个是用于对接iOS系统和OpenGLES的**GLKit.framework**，后者开放了一套方便OpenGLES环境设置的接口，方便iOS程序进行OpenGLES编程；\n\n```\n@interface OpenGLESViewController : GLKViewController\n{\n   GLuint vertexBufferID; //该值实际上是一个无符号整形，看名字可以看的出来\n}\n@property (strong, nonatomic) GLKBaseEffect *baseEffect;\n@end\n```\n下面这个结构体用来保存一个坐标，它是一个起始于坐标系原点的矢量（X,Y,Z）\n\n\n```\n//This data type is used to store information for each vertex\ntypedef struct {\n    GLKVector3  positionCoords;\n}SceneVertex;\n```\n\n```\n//用来定义三角形，以下空白部分是最后在屏幕上显示的结果，纯属娱乐\n/*\n *************\n **** ********\n ****  *******\n ****   ******\n ****    *****\n ****     ****\n *************\n *************\n*/\n// Define vertex data for a triangle to use in example\nstatic const SceneVertex vertices[] =\n{\n    {{-0.5f, -0.5f, 0.0}}, // lower left corner\n    {{ 0.5f, -0.5f, 0.0}}, // lower right corner\n    {{-0.5f,  0.5f, 0.0}}  // upper left corner\n};\n\n```\n\n##viewDidLoad\n\n先要将Controller的view强制转换成GLKView，GLKView提供了针对OpenGLES2.0版本的上下文，新建该类的上下文并将它设置为当前的上下文；\n\n```\n// Verify the type of view created automatically by the\n// Interface Builder storyboard\nGLKView *view = (GLKView *)self.view;\nNSAssert([view isKindOfClass:[GLKView class]],\n   \t\t   @\"View controller's view is not a GLKView\");\n```\n\nOpenGL ES的上下文不仅会保存它的状态，还会控制GPU去执行渲染运算,EAGLContext会封装一个特定于某个平台的上下文，一个应用可以使用多个上下文;\n\n```\n// Create an OpenGL ES 2.0 context and provide it to the\n// view\nview.context = [[EAGLContext alloc]\n\t\t\t\t\tinitWithAPI:kEAGLRenderingAPIOpenGLES2];\n\n//设置成当前上下文\n// Make the new context current\n[EAGLContext setCurrentContext:view.context];\n```\n\nGLKBaseEffect类提供了不依赖OGE版本的渲染方法，它会在需要的时候自动构建一个GPU程序,该实例使用恒定不变的白色来渲染像素;\n\n```\nself.baseEffect = [[GLKBaseEffect alloc] init];\nself.baseEffect.useConstantColor = GL_TRUE;\nself.baseEffect.constantColor = GLKVector4Make(\n\t\t\t\t\t\t\t\t     1.0f, // Red\n\t\t\t\t\t\t\t\t     1.0f, // Green\n\t\t\t\t\t\t\t\t     1.0f, // Blue\n\t\t\t\t\t\t\t\t     1.0f);// Alpha\n//设置当前OGE上下文为不透明黑色，该黑色由RGBA颜色元素值组成，用于在上下文帧缓存被清除时对每个像素进行初始化\nglClearColor(0.0f, 0.0f, 0.0f, 1.0f); // background color\n```\n\n以下代码用于定义三角形的数据必须要发送到GPU来进行渲染，创建三角形数据数组缓存的前三个步骤，对应以下步骤：\n\n\n1.为缓存生成一个唯一的标志符；\n\n\n2.为运算绑定缓存；\n\n\n3.复制数据到缓存；\n\n```\n// Generate, bind, and initialize contents of a buffer to be\n// stored in GPU memory\nglGenBuffers(1,                // STEP 1\n      &vertexBufferID);\nNSLog(@\"vertexBufferID = %p\",vertexBufferID);\n//该结果是一个指针，指向所生成标志符的内存保存位置；\n//缓存标志符在文档中叫做 \"names\"\n\nglBindBuffer(GL_ARRAY_BUFFER,  // STEP 2\n      vertexBufferID);\n//保存不同类型的标志符到OGE的不同位置，同一时刻只能绑定一个缓存，即使它们是相同类型的；\n//OpenGLES2.0只支持绑定两种类型，GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER；\n\nglBufferData(                  // STEP 3\n      GL_ARRAY_BUFFER,  // Initialize buffer contents\n      sizeof(vertices), // Number of bytes to copy\n      vertices,         // Address of bytes to copy\n      GL_STATIC_DRAW);  // Hint: cache in GPU memory\n//第四个参数提示缓存在未来运算中可能会被怎样使用\n//GL_STATIC_DRAW 提示缓存内容适合复制到内存中，而很少对其进行修改；\n//GL_DYNAMIC_DRAW 缓存数据会频繁改变，提示OGE上下文用不同方式处理\n```\n##glkView:drawInRect:\n\n每当一个GLKView需要重绘时，保存在视图中的上下文都会成为当前上下文；如需要，它还会保存一个来自Core Animation层的帧缓存，并调用下面的方法；\n\n此处接上面使用缓存的前三步；\n\n4.启动；\n\n5.设置指针；\n\n6.绘图；\n\n```\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n    [self.baseEffect prepareToDraw];\n\n    // Clear Frame Buffer (erase previous drawing)\n    //它的值是前面glClearColor()设置的；\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n\n    // Enable use of positions from bound vertex buffer\n    glEnableVertexAttribArray(      // STEP 4\n      GLKVertexAttribPosition);\n\n    glVertexAttribPointer(          // STEP 5\n      GLKVertexAttribPosition,\n      3,                   // three components per vertex\n      GL_FLOAT,            // data is floating point\n      GL_FALSE,            // no fixed point scaling\n      sizeof(SceneVertex), // no gaps in data\n      NULL);               // NULL tells GPU to start at\n                           // beginning of bound buffer\n\n    // Draw triangles using the first three vertices in the\n    // currently bound vertex buffer\n    glDrawArrays(GL_TRIANGLES,      // STEP 6\n     \t\t 0,  // Start with first vertex in currently bound buffer\n     \t\t 3); // Use three vertices from currently bound buffer\n}\n```\n\nglDrawArrays函数调用完成，此时所需要显示的场景已经完全显示或者GPU处理完成后会完全显示;\n\nCPU运算和GPU运算是异步的，这个例子的所有代码都是运行在CPU上的，需要进一步处理时会向GPU发送命令；GPU可能也会处理Core Animation层的命令，所以GPU总执行次数不一定；\n\n##viewDidUnload\n    \n```\n- (void)viewDidUnload\n{\n    [super viewDidUnload];\n\n    // Make the view's context current\n    GLKView *view = (GLKView *)self.view;\n    [EAGLContext setCurrentContext:view.context];\n\n    // Delete buffers that aren't needed when view is unloaded\n    if (0 != vertexBufferID)\n    {\n       glDeleteBuffers (1,          // STEP 7\n                        &vertexBufferID);\n       vertexBufferID = 0;\n    }\n\n    // Stop using the context created in -viewDidLoad\n    ((GLKView *)self.view).context = nil;\n    [EAGLContext setCurrentContext:nil];\n}\n\n```\n[点击此处下载本文例子](https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch_2_1)\n\n\n","slug":"开始OpenGLES的探索","published":1,"updated":"2018-05-04T10:24:29.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucior00261v60h0kms11s","content":"<p>Summary: 本系列文章是学习《OpenGL ES应用开发实践指南 iOS卷》的过程，学习过程中参照书中给出的例子运行并记录笔记，此篇是开篇，书中的例子可以从本文给出的地址下载。</p>\n<a id=\"more\"></a>\n<p>##先介绍几个概念：</p>\n<blockquote>\n<p>渲染：用3D数据生成一个2D图像的过程就叫做渲染；</p>\n<p>像素：计算机显示矩形的颜色点叫做像素；</p>\n<p>缓存：是指图形处理器能够控制和管理的连续RAM（原来就是内存）；</p>\n<p>帧缓存：内存中接收2D结果数据的缓冲区；</p>\n<p>上下文：是用于配置OpenGL ES的特定的软件平台的数据结构信息；</p>\n</blockquote>\n<p>##开始我们的OGE之旅：</p>\n<p>首先是添加两个框架，一个是用于调用OpenGL ES进行渲染的<strong>OpenGLES.framework</strong>，另外一个是用于对接iOS系统和OpenGLES的<strong>GLKit.framework</strong>，后者开放了一套方便OpenGLES环境设置的接口，方便iOS程序进行OpenGLES编程；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface OpenGLESViewController : GLKViewController</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLuint vertexBufferID; //该值实际上是一个无符号整形，看名字可以看的出来</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@property (strong, nonatomic) GLKBaseEffect *baseEffect;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>下面这个结构体用来保存一个坐标，它是一个起始于坐标系原点的矢量（X,Y,Z）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//This data type is used to store information for each vertex</span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    GLKVector3  positionCoords;</span><br><span class=\"line\">&#125;SceneVertex;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用来定义三角形，以下空白部分是最后在屏幕上显示的结果，纯属娱乐</span><br><span class=\"line\">/*</span><br><span class=\"line\"> *************</span><br><span class=\"line\"> **** ********</span><br><span class=\"line\"> ****  *******</span><br><span class=\"line\"> ****   ******</span><br><span class=\"line\"> ****    *****</span><br><span class=\"line\"> ****     ****</span><br><span class=\"line\"> *************</span><br><span class=\"line\"> *************</span><br><span class=\"line\">*/</span><br><span class=\"line\">// Define vertex data for a triangle to use in example</span><br><span class=\"line\">static const SceneVertex vertices[] =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;&#123;-0.5f, -0.5f, 0.0&#125;&#125;, // lower left corner</span><br><span class=\"line\">    &#123;&#123; 0.5f, -0.5f, 0.0&#125;&#125;, // lower right corner</span><br><span class=\"line\">    &#123;&#123;-0.5f,  0.5f, 0.0&#125;&#125;  // upper left corner</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>##viewDidLoad</p>\n<p>先要将Controller的view强制转换成GLKView，GLKView提供了针对OpenGLES2.0版本的上下文，新建该类的上下文并将它设置为当前的上下文；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Verify the type of view created automatically by the</span><br><span class=\"line\">// Interface Builder storyboard</span><br><span class=\"line\">GLKView *view = (GLKView *)self.view;</span><br><span class=\"line\">NSAssert([view isKindOfClass:[GLKView class]],</span><br><span class=\"line\">   \t\t   @&quot;View controller&apos;s view is not a GLKView&quot;);</span><br></pre></td></tr></table></figure>\n<p>OpenGL ES的上下文不仅会保存它的状态，还会控制GPU去执行渲染运算,EAGLContext会封装一个特定于某个平台的上下文，一个应用可以使用多个上下文;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create an OpenGL ES 2.0 context and provide it to the</span><br><span class=\"line\">// view</span><br><span class=\"line\">view.context = [[EAGLContext alloc]</span><br><span class=\"line\">\t\t\t\t\tinitWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\"></span><br><span class=\"line\">//设置成当前上下文</span><br><span class=\"line\">// Make the new context current</span><br><span class=\"line\">[EAGLContext setCurrentContext:view.context];</span><br></pre></td></tr></table></figure>\n<p>GLKBaseEffect类提供了不依赖OGE版本的渲染方法，它会在需要的时候自动构建一个GPU程序,该实例使用恒定不变的白色来渲染像素;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class=\"line\">self.baseEffect.constantColor = GLKVector4Make(</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f, // Red</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f, // Green</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f, // Blue</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f);// Alpha</span><br><span class=\"line\">//设置当前OGE上下文为不透明黑色，该黑色由RGBA颜色元素值组成，用于在上下文帧缓存被清除时对每个像素进行初始化</span><br><span class=\"line\">glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // background color</span><br></pre></td></tr></table></figure>\n<p>以下代码用于定义三角形的数据必须要发送到GPU来进行渲染，创建三角形数据数组缓存的前三个步骤，对应以下步骤：</p>\n<p>1.为缓存生成一个唯一的标志符；</p>\n<p>2.为运算绑定缓存；</p>\n<p>3.复制数据到缓存；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Generate, bind, and initialize contents of a buffer to be</span><br><span class=\"line\">// stored in GPU memory</span><br><span class=\"line\">glGenBuffers(1,                // STEP 1</span><br><span class=\"line\">      &amp;vertexBufferID);</span><br><span class=\"line\">NSLog(@&quot;vertexBufferID = %p&quot;,vertexBufferID);</span><br><span class=\"line\">//该结果是一个指针，指向所生成标志符的内存保存位置；</span><br><span class=\"line\">//缓存标志符在文档中叫做 &quot;names&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class=\"line\">      vertexBufferID);</span><br><span class=\"line\">//保存不同类型的标志符到OGE的不同位置，同一时刻只能绑定一个缓存，即使它们是相同类型的；</span><br><span class=\"line\">//OpenGLES2.0只支持绑定两种类型，GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER；</span><br><span class=\"line\"></span><br><span class=\"line\">glBufferData(                  // STEP 3</span><br><span class=\"line\">      GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class=\"line\">      sizeof(vertices), // Number of bytes to copy</span><br><span class=\"line\">      vertices,         // Address of bytes to copy</span><br><span class=\"line\">      GL_STATIC_DRAW);  // Hint: cache in GPU memory</span><br><span class=\"line\">//第四个参数提示缓存在未来运算中可能会被怎样使用</span><br><span class=\"line\">//GL_STATIC_DRAW 提示缓存内容适合复制到内存中，而很少对其进行修改；</span><br><span class=\"line\">//GL_DYNAMIC_DRAW 缓存数据会频繁改变，提示OGE上下文用不同方式处理</span><br></pre></td></tr></table></figure>\n<p>##glkView:drawInRect:</p>\n<p>每当一个GLKView需要重绘时，保存在视图中的上下文都会成为当前上下文；如需要，它还会保存一个来自Core Animation层的帧缓存，并调用下面的方法；</p>\n<p>此处接上面使用缓存的前三步；</p>\n<p>4.启动；</p>\n<p>5.设置指针；</p>\n<p>6.绘图；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.baseEffect prepareToDraw];</span><br><span class=\"line\"></span><br><span class=\"line\">    // Clear Frame Buffer (erase previous drawing)</span><br><span class=\"line\">    //它的值是前面glClearColor()设置的；</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // Enable use of positions from bound vertex buffer</span><br><span class=\"line\">    glEnableVertexAttribArray(      // STEP 4</span><br><span class=\"line\">      GLKVertexAttribPosition);</span><br><span class=\"line\"></span><br><span class=\"line\">    glVertexAttribPointer(          // STEP 5</span><br><span class=\"line\">      GLKVertexAttribPosition,</span><br><span class=\"line\">      3,                   // three components per vertex</span><br><span class=\"line\">      GL_FLOAT,            // data is floating point</span><br><span class=\"line\">      GL_FALSE,            // no fixed point scaling</span><br><span class=\"line\">      sizeof(SceneVertex), // no gaps in data</span><br><span class=\"line\">      NULL);               // NULL tells GPU to start at</span><br><span class=\"line\">                           // beginning of bound buffer</span><br><span class=\"line\"></span><br><span class=\"line\">    // Draw triangles using the first three vertices in the</span><br><span class=\"line\">    // currently bound vertex buffer</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES,      // STEP 6</span><br><span class=\"line\">     \t\t 0,  // Start with first vertex in currently bound buffer</span><br><span class=\"line\">     \t\t 3); // Use three vertices from currently bound buffer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>glDrawArrays函数调用完成，此时所需要显示的场景已经完全显示或者GPU处理完成后会完全显示;</p>\n<p>CPU运算和GPU运算是异步的，这个例子的所有代码都是运行在CPU上的，需要进一步处理时会向GPU发送命令；GPU可能也会处理Core Animation层的命令，所以GPU总执行次数不一定；</p>\n<p>##viewDidUnload</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidUnload</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidUnload];</span><br><span class=\"line\"></span><br><span class=\"line\">    // Make the view&apos;s context current</span><br><span class=\"line\">    GLKView *view = (GLKView *)self.view;</span><br><span class=\"line\">    [EAGLContext setCurrentContext:view.context];</span><br><span class=\"line\"></span><br><span class=\"line\">    // Delete buffers that aren&apos;t needed when view is unloaded</span><br><span class=\"line\">    if (0 != vertexBufferID)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       glDeleteBuffers (1,          // STEP 7</span><br><span class=\"line\">                        &amp;vertexBufferID);</span><br><span class=\"line\">       vertexBufferID = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Stop using the context created in -viewDidLoad</span><br><span class=\"line\">    ((GLKView *)self.view).context = nil;</span><br><span class=\"line\">    [EAGLContext setCurrentContext:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch_2_1\" target=\"_blank\" rel=\"noopener\">点击此处下载本文例子</a></p>\n","site":{"data":{}},"excerpt":"<p>Summary: 本系列文章是学习《OpenGL ES应用开发实践指南 iOS卷》的过程，学习过程中参照书中给出的例子运行并记录笔记，此篇是开篇，书中的例子可以从本文给出的地址下载。</p>","more":"<p>##先介绍几个概念：</p>\n<blockquote>\n<p>渲染：用3D数据生成一个2D图像的过程就叫做渲染；</p>\n<p>像素：计算机显示矩形的颜色点叫做像素；</p>\n<p>缓存：是指图形处理器能够控制和管理的连续RAM（原来就是内存）；</p>\n<p>帧缓存：内存中接收2D结果数据的缓冲区；</p>\n<p>上下文：是用于配置OpenGL ES的特定的软件平台的数据结构信息；</p>\n</blockquote>\n<p>##开始我们的OGE之旅：</p>\n<p>首先是添加两个框架，一个是用于调用OpenGL ES进行渲染的<strong>OpenGLES.framework</strong>，另外一个是用于对接iOS系统和OpenGLES的<strong>GLKit.framework</strong>，后者开放了一套方便OpenGLES环境设置的接口，方便iOS程序进行OpenGLES编程；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface OpenGLESViewController : GLKViewController</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLuint vertexBufferID; //该值实际上是一个无符号整形，看名字可以看的出来</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@property (strong, nonatomic) GLKBaseEffect *baseEffect;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>下面这个结构体用来保存一个坐标，它是一个起始于坐标系原点的矢量（X,Y,Z）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//This data type is used to store information for each vertex</span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    GLKVector3  positionCoords;</span><br><span class=\"line\">&#125;SceneVertex;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用来定义三角形，以下空白部分是最后在屏幕上显示的结果，纯属娱乐</span><br><span class=\"line\">/*</span><br><span class=\"line\"> *************</span><br><span class=\"line\"> **** ********</span><br><span class=\"line\"> ****  *******</span><br><span class=\"line\"> ****   ******</span><br><span class=\"line\"> ****    *****</span><br><span class=\"line\"> ****     ****</span><br><span class=\"line\"> *************</span><br><span class=\"line\"> *************</span><br><span class=\"line\">*/</span><br><span class=\"line\">// Define vertex data for a triangle to use in example</span><br><span class=\"line\">static const SceneVertex vertices[] =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;&#123;-0.5f, -0.5f, 0.0&#125;&#125;, // lower left corner</span><br><span class=\"line\">    &#123;&#123; 0.5f, -0.5f, 0.0&#125;&#125;, // lower right corner</span><br><span class=\"line\">    &#123;&#123;-0.5f,  0.5f, 0.0&#125;&#125;  // upper left corner</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>##viewDidLoad</p>\n<p>先要将Controller的view强制转换成GLKView，GLKView提供了针对OpenGLES2.0版本的上下文，新建该类的上下文并将它设置为当前的上下文；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Verify the type of view created automatically by the</span><br><span class=\"line\">// Interface Builder storyboard</span><br><span class=\"line\">GLKView *view = (GLKView *)self.view;</span><br><span class=\"line\">NSAssert([view isKindOfClass:[GLKView class]],</span><br><span class=\"line\">   \t\t   @&quot;View controller&apos;s view is not a GLKView&quot;);</span><br></pre></td></tr></table></figure>\n<p>OpenGL ES的上下文不仅会保存它的状态，还会控制GPU去执行渲染运算,EAGLContext会封装一个特定于某个平台的上下文，一个应用可以使用多个上下文;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Create an OpenGL ES 2.0 context and provide it to the</span><br><span class=\"line\">// view</span><br><span class=\"line\">view.context = [[EAGLContext alloc]</span><br><span class=\"line\">\t\t\t\t\tinitWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\"></span><br><span class=\"line\">//设置成当前上下文</span><br><span class=\"line\">// Make the new context current</span><br><span class=\"line\">[EAGLContext setCurrentContext:view.context];</span><br></pre></td></tr></table></figure>\n<p>GLKBaseEffect类提供了不依赖OGE版本的渲染方法，它会在需要的时候自动构建一个GPU程序,该实例使用恒定不变的白色来渲染像素;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.baseEffect = [[GLKBaseEffect alloc] init];</span><br><span class=\"line\">self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class=\"line\">self.baseEffect.constantColor = GLKVector4Make(</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f, // Red</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f, // Green</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f, // Blue</span><br><span class=\"line\">\t\t\t\t\t\t\t\t     1.0f);// Alpha</span><br><span class=\"line\">//设置当前OGE上下文为不透明黑色，该黑色由RGBA颜色元素值组成，用于在上下文帧缓存被清除时对每个像素进行初始化</span><br><span class=\"line\">glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // background color</span><br></pre></td></tr></table></figure>\n<p>以下代码用于定义三角形的数据必须要发送到GPU来进行渲染，创建三角形数据数组缓存的前三个步骤，对应以下步骤：</p>\n<p>1.为缓存生成一个唯一的标志符；</p>\n<p>2.为运算绑定缓存；</p>\n<p>3.复制数据到缓存；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Generate, bind, and initialize contents of a buffer to be</span><br><span class=\"line\">// stored in GPU memory</span><br><span class=\"line\">glGenBuffers(1,                // STEP 1</span><br><span class=\"line\">      &amp;vertexBufferID);</span><br><span class=\"line\">NSLog(@&quot;vertexBufferID = %p&quot;,vertexBufferID);</span><br><span class=\"line\">//该结果是一个指针，指向所生成标志符的内存保存位置；</span><br><span class=\"line\">//缓存标志符在文档中叫做 &quot;names&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER,  // STEP 2</span><br><span class=\"line\">      vertexBufferID);</span><br><span class=\"line\">//保存不同类型的标志符到OGE的不同位置，同一时刻只能绑定一个缓存，即使它们是相同类型的；</span><br><span class=\"line\">//OpenGLES2.0只支持绑定两种类型，GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER；</span><br><span class=\"line\"></span><br><span class=\"line\">glBufferData(                  // STEP 3</span><br><span class=\"line\">      GL_ARRAY_BUFFER,  // Initialize buffer contents</span><br><span class=\"line\">      sizeof(vertices), // Number of bytes to copy</span><br><span class=\"line\">      vertices,         // Address of bytes to copy</span><br><span class=\"line\">      GL_STATIC_DRAW);  // Hint: cache in GPU memory</span><br><span class=\"line\">//第四个参数提示缓存在未来运算中可能会被怎样使用</span><br><span class=\"line\">//GL_STATIC_DRAW 提示缓存内容适合复制到内存中，而很少对其进行修改；</span><br><span class=\"line\">//GL_DYNAMIC_DRAW 缓存数据会频繁改变，提示OGE上下文用不同方式处理</span><br></pre></td></tr></table></figure>\n<p>##glkView:drawInRect:</p>\n<p>每当一个GLKView需要重绘时，保存在视图中的上下文都会成为当前上下文；如需要，它还会保存一个来自Core Animation层的帧缓存，并调用下面的方法；</p>\n<p>此处接上面使用缓存的前三步；</p>\n<p>4.启动；</p>\n<p>5.设置指针；</p>\n<p>6.绘图；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.baseEffect prepareToDraw];</span><br><span class=\"line\"></span><br><span class=\"line\">    // Clear Frame Buffer (erase previous drawing)</span><br><span class=\"line\">    //它的值是前面glClearColor()设置的；</span><br><span class=\"line\">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // Enable use of positions from bound vertex buffer</span><br><span class=\"line\">    glEnableVertexAttribArray(      // STEP 4</span><br><span class=\"line\">      GLKVertexAttribPosition);</span><br><span class=\"line\"></span><br><span class=\"line\">    glVertexAttribPointer(          // STEP 5</span><br><span class=\"line\">      GLKVertexAttribPosition,</span><br><span class=\"line\">      3,                   // three components per vertex</span><br><span class=\"line\">      GL_FLOAT,            // data is floating point</span><br><span class=\"line\">      GL_FALSE,            // no fixed point scaling</span><br><span class=\"line\">      sizeof(SceneVertex), // no gaps in data</span><br><span class=\"line\">      NULL);               // NULL tells GPU to start at</span><br><span class=\"line\">                           // beginning of bound buffer</span><br><span class=\"line\"></span><br><span class=\"line\">    // Draw triangles using the first three vertices in the</span><br><span class=\"line\">    // currently bound vertex buffer</span><br><span class=\"line\">    glDrawArrays(GL_TRIANGLES,      // STEP 6</span><br><span class=\"line\">     \t\t 0,  // Start with first vertex in currently bound buffer</span><br><span class=\"line\">     \t\t 3); // Use three vertices from currently bound buffer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>glDrawArrays函数调用完成，此时所需要显示的场景已经完全显示或者GPU处理完成后会完全显示;</p>\n<p>CPU运算和GPU运算是异步的，这个例子的所有代码都是运行在CPU上的，需要进一步处理时会向GPU发送命令；GPU可能也会处理Core Animation层的命令，所以GPU总执行次数不一定；</p>\n<p>##viewDidUnload</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidUnload</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidUnload];</span><br><span class=\"line\"></span><br><span class=\"line\">    // Make the view&apos;s context current</span><br><span class=\"line\">    GLKView *view = (GLKView *)self.view;</span><br><span class=\"line\">    [EAGLContext setCurrentContext:view.context];</span><br><span class=\"line\"></span><br><span class=\"line\">    // Delete buffers that aren&apos;t needed when view is unloaded</span><br><span class=\"line\">    if (0 != vertexBufferID)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       glDeleteBuffers (1,          // STEP 7</span><br><span class=\"line\">                        &amp;vertexBufferID);</span><br><span class=\"line\">       vertexBufferID = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Stop using the context created in -viewDidLoad</span><br><span class=\"line\">    ((GLKView *)self.view).context = nil;</span><br><span class=\"line\">    [EAGLContext setCurrentContext:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/usiege/OpenGLES/tree/master/OpenGLES_Ch2/OpenGLES_Ch_2_1\" target=\"_blank\" rel=\"noopener\">点击此处下载本文例子</a></p>"},{"title":"守护者与上古神的战斗","date":"2016-08-13T08:13:00.000Z","_content":"\n本篇我们讲讲万神殿的众位神仙们和他们的继承人，这些继承人在后来艾泽拉斯势力划分中起着很重要的作用。\n\n<!-- more -->\n\n\n泰坦的守护者们一到艾泽拉斯就接管了当地的管制，大肆宣传其在艾泽拉斯的主人地位。但是上古之神却把这些由金属和岩石组成的家伙当作是侵略者，而之前被上古恐怖组织所奴役的元素F4们更是把这当作另一次入侵。于是上古之神利用了F4的愤怒让它们去迎击共同的敌人。\n\n![泰坦元素之战](http://upload-images.jianshu.io/upload_images/1429775-660d3d68407e588e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n战争又一次展开，然而这些当地“土著”哪是这些神之继承者的对手，在各个区域又一次相继败下阵来。由于这些元素与艾泽拉斯有着很紧密的联系，所以无法完全摧毁他们，于是继承者们就把它们放逐在了元素位面中（作者自己编造的地方，以方便剧情需要的时候再把它们放出来）。东边的炎魔拉格纳罗斯被提尔和奥丁（阿格拉玛和神父阿曼苏尔的继承人）打败，后被放逐在这里，因此我们在魔兽世界中的东部大陆的副本熔火之心中才会有它的身影，这后面的故事发生在矮人一族中，以后我们慢慢道来；阿札达斯（卡兹格罗斯继承者）和芙蕾雅（伊欧娜继承者）对阵的是石母瑟拉赞恩，这位石头人后被打入地底的水晶洞穴，就是在现在的深岩之洲里，大灾变里貌似有一个以它的名字的声望，其他的了解的不多，后边慢慢看，不过玛拉顿应该有人了解，她是石母的女儿；元素里最为难对付的风神居住在万丈高空，莱（阿曼苏尔继承者）、索林姆和霍迪尔（高甘纳斯继承者）最终将它永远囚禁在了天空中，在现今的奥丹姆南方地域的上空我们叫它风神王座；与水元素之王耐普图隆对阵的是洛肯和米米隆（诺甘农继承者），大灾变中的潮汐王座我们可以看到它。\n\n守护者们解决完元素F4之后，自然顺便把亚基虫族也一块灭了，只有少部分逃到了地下躲了起来，不得不说这些神之子们的确主宰了整个艾泽拉斯的命运。\n\n![亚煞极](http://upload-images.jianshu.io/upload_images/1429775-45e3a41231ac7a1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里在上篇遗漏了一个重要人物，就是上古之神最为强大和邪恶的亚煞极，听名字就很霸气，它存在的周围就是恐怖军团的圣城所在，盘据着无数的恩剌基；守护者们最后自是要跟它做决战了。不过怎么说这些守护者只是泰坦们的小弟，跟人家恐怖头目打还是嫩了些，守护者们只得求助于他们的老大们。阿曼苏尔怒了，不给你点颜色看看你还无法无天了？一招就给亚煞极扯个稀烂，（我就想问你早干嘛去了，）这一扯不要紧，小泰坦的奥术能量也就跟着从这伤口散发出来。在这之后神届们再也不敢用这种方式，采取制服后直接囚禁起来的方针。\n\n最强大的上古神已然消灭，守护者们就继承开始了征伐，相继把恩佐斯、克苏恩、尤格隆萨、克瑟拉基制服，并深埋在了地底下。这些上古神们还会出来兴风作浪的哦，我觉得整个世界的格局都是由它们来引导的，所以请记下他们的名字，没准在以后的资料片里，你要杀的终BOSS，就是它们中的一个。","source":"_posts/守护者与上古神的战斗.md","raw":"title: 守护者与上古神的战斗\ndate: 2016-08-13 16:13:00\ncategories: Azeroth\n-----------\n\n本篇我们讲讲万神殿的众位神仙们和他们的继承人，这些继承人在后来艾泽拉斯势力划分中起着很重要的作用。\n\n<!-- more -->\n\n\n泰坦的守护者们一到艾泽拉斯就接管了当地的管制，大肆宣传其在艾泽拉斯的主人地位。但是上古之神却把这些由金属和岩石组成的家伙当作是侵略者，而之前被上古恐怖组织所奴役的元素F4们更是把这当作另一次入侵。于是上古之神利用了F4的愤怒让它们去迎击共同的敌人。\n\n![泰坦元素之战](http://upload-images.jianshu.io/upload_images/1429775-660d3d68407e588e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n战争又一次展开，然而这些当地“土著”哪是这些神之继承者的对手，在各个区域又一次相继败下阵来。由于这些元素与艾泽拉斯有着很紧密的联系，所以无法完全摧毁他们，于是继承者们就把它们放逐在了元素位面中（作者自己编造的地方，以方便剧情需要的时候再把它们放出来）。东边的炎魔拉格纳罗斯被提尔和奥丁（阿格拉玛和神父阿曼苏尔的继承人）打败，后被放逐在这里，因此我们在魔兽世界中的东部大陆的副本熔火之心中才会有它的身影，这后面的故事发生在矮人一族中，以后我们慢慢道来；阿札达斯（卡兹格罗斯继承者）和芙蕾雅（伊欧娜继承者）对阵的是石母瑟拉赞恩，这位石头人后被打入地底的水晶洞穴，就是在现在的深岩之洲里，大灾变里貌似有一个以它的名字的声望，其他的了解的不多，后边慢慢看，不过玛拉顿应该有人了解，她是石母的女儿；元素里最为难对付的风神居住在万丈高空，莱（阿曼苏尔继承者）、索林姆和霍迪尔（高甘纳斯继承者）最终将它永远囚禁在了天空中，在现今的奥丹姆南方地域的上空我们叫它风神王座；与水元素之王耐普图隆对阵的是洛肯和米米隆（诺甘农继承者），大灾变中的潮汐王座我们可以看到它。\n\n守护者们解决完元素F4之后，自然顺便把亚基虫族也一块灭了，只有少部分逃到了地下躲了起来，不得不说这些神之子们的确主宰了整个艾泽拉斯的命运。\n\n![亚煞极](http://upload-images.jianshu.io/upload_images/1429775-45e3a41231ac7a1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里在上篇遗漏了一个重要人物，就是上古之神最为强大和邪恶的亚煞极，听名字就很霸气，它存在的周围就是恐怖军团的圣城所在，盘据着无数的恩剌基；守护者们最后自是要跟它做决战了。不过怎么说这些守护者只是泰坦们的小弟，跟人家恐怖头目打还是嫩了些，守护者们只得求助于他们的老大们。阿曼苏尔怒了，不给你点颜色看看你还无法无天了？一招就给亚煞极扯个稀烂，（我就想问你早干嘛去了，）这一扯不要紧，小泰坦的奥术能量也就跟着从这伤口散发出来。在这之后神届们再也不敢用这种方式，采取制服后直接囚禁起来的方针。\n\n最强大的上古神已然消灭，守护者们就继承开始了征伐，相继把恩佐斯、克苏恩、尤格隆萨、克瑟拉基制服，并深埋在了地底下。这些上古神们还会出来兴风作浪的哦，我觉得整个世界的格局都是由它们来引导的，所以请记下他们的名字，没准在以后的资料片里，你要杀的终BOSS，就是它们中的一个。","slug":"守护者与上古神的战斗","published":1,"updated":"2018-05-04T10:24:15.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciot00281v60ospwga87","content":"<p>本篇我们讲讲万神殿的众位神仙们和他们的继承人，这些继承人在后来艾泽拉斯势力划分中起着很重要的作用。</p>\n<a id=\"more\"></a>\n<p>泰坦的守护者们一到艾泽拉斯就接管了当地的管制，大肆宣传其在艾泽拉斯的主人地位。但是上古之神却把这些由金属和岩石组成的家伙当作是侵略者，而之前被上古恐怖组织所奴役的元素F4们更是把这当作另一次入侵。于是上古之神利用了F4的愤怒让它们去迎击共同的敌人。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-660d3d68407e588e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"泰坦元素之战\"></p>\n<p>战争又一次展开，然而这些当地“土著”哪是这些神之继承者的对手，在各个区域又一次相继败下阵来。由于这些元素与艾泽拉斯有着很紧密的联系，所以无法完全摧毁他们，于是继承者们就把它们放逐在了元素位面中（作者自己编造的地方，以方便剧情需要的时候再把它们放出来）。东边的炎魔拉格纳罗斯被提尔和奥丁（阿格拉玛和神父阿曼苏尔的继承人）打败，后被放逐在这里，因此我们在魔兽世界中的东部大陆的副本熔火之心中才会有它的身影，这后面的故事发生在矮人一族中，以后我们慢慢道来；阿札达斯（卡兹格罗斯继承者）和芙蕾雅（伊欧娜继承者）对阵的是石母瑟拉赞恩，这位石头人后被打入地底的水晶洞穴，就是在现在的深岩之洲里，大灾变里貌似有一个以它的名字的声望，其他的了解的不多，后边慢慢看，不过玛拉顿应该有人了解，她是石母的女儿；元素里最为难对付的风神居住在万丈高空，莱（阿曼苏尔继承者）、索林姆和霍迪尔（高甘纳斯继承者）最终将它永远囚禁在了天空中，在现今的奥丹姆南方地域的上空我们叫它风神王座；与水元素之王耐普图隆对阵的是洛肯和米米隆（诺甘农继承者），大灾变中的潮汐王座我们可以看到它。</p>\n<p>守护者们解决完元素F4之后，自然顺便把亚基虫族也一块灭了，只有少部分逃到了地下躲了起来，不得不说这些神之子们的确主宰了整个艾泽拉斯的命运。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-45e3a41231ac7a1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"亚煞极\"></p>\n<p>这里在上篇遗漏了一个重要人物，就是上古之神最为强大和邪恶的亚煞极，听名字就很霸气，它存在的周围就是恐怖军团的圣城所在，盘据着无数的恩剌基；守护者们最后自是要跟它做决战了。不过怎么说这些守护者只是泰坦们的小弟，跟人家恐怖头目打还是嫩了些，守护者们只得求助于他们的老大们。阿曼苏尔怒了，不给你点颜色看看你还无法无天了？一招就给亚煞极扯个稀烂，（我就想问你早干嘛去了，）这一扯不要紧，小泰坦的奥术能量也就跟着从这伤口散发出来。在这之后神届们再也不敢用这种方式，采取制服后直接囚禁起来的方针。</p>\n<p>最强大的上古神已然消灭，守护者们就继承开始了征伐，相继把恩佐斯、克苏恩、尤格隆萨、克瑟拉基制服，并深埋在了地底下。这些上古神们还会出来兴风作浪的哦，我觉得整个世界的格局都是由它们来引导的，所以请记下他们的名字，没准在以后的资料片里，你要杀的终BOSS，就是它们中的一个。</p>\n","site":{"data":{}},"excerpt":"<p>本篇我们讲讲万神殿的众位神仙们和他们的继承人，这些继承人在后来艾泽拉斯势力划分中起着很重要的作用。</p>","more":"<p>泰坦的守护者们一到艾泽拉斯就接管了当地的管制，大肆宣传其在艾泽拉斯的主人地位。但是上古之神却把这些由金属和岩石组成的家伙当作是侵略者，而之前被上古恐怖组织所奴役的元素F4们更是把这当作另一次入侵。于是上古之神利用了F4的愤怒让它们去迎击共同的敌人。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-660d3d68407e588e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"泰坦元素之战\"></p>\n<p>战争又一次展开，然而这些当地“土著”哪是这些神之继承者的对手，在各个区域又一次相继败下阵来。由于这些元素与艾泽拉斯有着很紧密的联系，所以无法完全摧毁他们，于是继承者们就把它们放逐在了元素位面中（作者自己编造的地方，以方便剧情需要的时候再把它们放出来）。东边的炎魔拉格纳罗斯被提尔和奥丁（阿格拉玛和神父阿曼苏尔的继承人）打败，后被放逐在这里，因此我们在魔兽世界中的东部大陆的副本熔火之心中才会有它的身影，这后面的故事发生在矮人一族中，以后我们慢慢道来；阿札达斯（卡兹格罗斯继承者）和芙蕾雅（伊欧娜继承者）对阵的是石母瑟拉赞恩，这位石头人后被打入地底的水晶洞穴，就是在现在的深岩之洲里，大灾变里貌似有一个以它的名字的声望，其他的了解的不多，后边慢慢看，不过玛拉顿应该有人了解，她是石母的女儿；元素里最为难对付的风神居住在万丈高空，莱（阿曼苏尔继承者）、索林姆和霍迪尔（高甘纳斯继承者）最终将它永远囚禁在了天空中，在现今的奥丹姆南方地域的上空我们叫它风神王座；与水元素之王耐普图隆对阵的是洛肯和米米隆（诺甘农继承者），大灾变中的潮汐王座我们可以看到它。</p>\n<p>守护者们解决完元素F4之后，自然顺便把亚基虫族也一块灭了，只有少部分逃到了地下躲了起来，不得不说这些神之子们的确主宰了整个艾泽拉斯的命运。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-45e3a41231ac7a1a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"亚煞极\"></p>\n<p>这里在上篇遗漏了一个重要人物，就是上古之神最为强大和邪恶的亚煞极，听名字就很霸气，它存在的周围就是恐怖军团的圣城所在，盘据着无数的恩剌基；守护者们最后自是要跟它做决战了。不过怎么说这些守护者只是泰坦们的小弟，跟人家恐怖头目打还是嫩了些，守护者们只得求助于他们的老大们。阿曼苏尔怒了，不给你点颜色看看你还无法无天了？一招就给亚煞极扯个稀烂，（我就想问你早干嘛去了，）这一扯不要紧，小泰坦的奥术能量也就跟着从这伤口散发出来。在这之后神届们再也不敢用这种方式，采取制服后直接囚禁起来的方针。</p>\n<p>最强大的上古神已然消灭，守护者们就继承开始了征伐，相继把恩佐斯、克苏恩、尤格隆萨、克瑟拉基制服，并深埋在了地底下。这些上古神们还会出来兴风作浪的哦，我觉得整个世界的格局都是由它们来引导的，所以请记下他们的名字，没准在以后的资料片里，你要杀的终BOSS，就是它们中的一个。</p>"},{"title":"巨魔与虫族的世纪之战","date":"2016-08-26T00:33:00.000Z","_content":"\n![](http://upload-images.jianshu.io/upload_images/1429775-134a3bc6a48cb352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n根据魔兽世界编年史的记录，巨魔一族永恒之井周围最早的原生物种。我们先来回顾一下永恒之井的产生，艾泽拉斯中心地带被最厉害的上古之神亚煞极占据，神父阿曼苏尔将其扯出，在破碎的泰坦身体处流出一道能量翔，这翔营养比较丰富，时间一长，周围自然而然的少不了吃翔的物种。 \n<!-- more -->\n\n\n魔兽历史时间线黑门前一万六千年，艾泽拉斯原驻民在永恒之井的滋润下逐渐兴盛。巨魔就是这其中的一支。这个物种的有两个特点，第一，食人，第二，巫毒魔法。它们的信仰是荒野众神“洛阿”。集网友们的猜测与推断，巨魔的早期物种原型应该是南美印第安人，俗称玛雅人。而上面的两个特点是支撑这个观点的依据，后面我们会专门分析一下艾泽拉斯早期物种及其原型的猜想。\n\n我们继续说回巨魔。早期的巨魔总结来说就是对内战争和对外战争的结合。我们说一个种族的强大是通过内部矛盾的发生来保持的，内部的竞争促进了各部族强壮的发育。巨魔一族在战争中逐渐崛起的部族分别是赞达拉，古拉巴什，阿曼尼和达卡莱。这四个部族我们在魔兽世界的前几个版本中都有接触过，其中赞达拉是在熊猫人大陆一个强悍的种族，古拉巴什在卡利姆多的祖尔法拉克，阿曼尼分布在祖阿曼和祖尔格拉布，而达卡莱则是在北极。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-14f0a671b878b7c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n人们常说，不作就不会死。这四个部族本来大家打的挺和谐，你争我抢的也分不出个胜负。可偏偏族内有巫师玩起通灵术，玩着玩着就玩出火，把恶魔给唤醒了。还记得跟守护者提尔打架的基希克斯吗？这个家伙就是上古神的小弟克瑟拉基大将，当初被洛肯派来追杀提尔未果，就跑到巨魔的地盘睡起觉来。结果就被巨魔人给吵醒了，基希克斯很生气，说：爬虫们，是什么样的祸事在这样早的时候发生，打断了老子的安睡？于是就把之前被提尔打散的亚基召唤回来，建立起个根据地叫做阿兹亚基（老子垃圾？）。\n\n俗话说“兄弟隙于内，外御其辱”，巨魔眼看这外来物种甚是强大，各部族联合起来组成巨魔联盟，顺带着把他们大神洛阿请出来，一众人就跟基希克斯开干。说到底这临时组起来的队伍就是不行，基希克斯这回是彻底把自己给玩死了。树倒猢孙散，小弟一见老大死了，就转而去投靠别的老大。\n\n\n![](http://upload-images.jianshu.io/upload_images/1429775-ef6eb5cedcaadb4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n赞达拉巨魔头领心想，这亚基也忒不行，打打就完蛋，打完这又要分地盘，不行得想办法给其他几个族支开。其他几个部族的头领也想自己不如赞达拉强，在这跟他争争不过，不如去别地占个山头去。于是大家开了个会，一致同意将这些跑的亚基赶尽杀绝，其实是明着分地盘。达莱卡向北追击，占据了北方冰封的土地；古拉巴什一族向西南进发，控制了原囚禁上古之神克苏恩的安其拉堡垒附近的大部分区域；阿曼尼一族则是去向了东北方基希克斯老巢，在那里建立起了圣城祖尔阿曼；剩下的赞达拉则继续在中部圣城祖尔达萨发布指令，起着联系各部族的作用。后期这个中心据点的作用逐渐被淡化，各巨魔在新领地形成了不同的种族特色与文化，赞达拉部族也退回了山地。 至于黑暗巨魔我们这里还没有涉及到，这个分支比较复杂，总体来看是部族间融合的结果。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-dd1611d508252c55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里顺道介绍下战败的亚基虫族的命运。亚基的四散也形成了不同的虫族分类，在北方的虫族由于受到尤格隆萨囚牢的影响，慢慢演化成奈幽虫族，在地底建立了强大的阿兹奥奈幽帝国；西南方虫族定居了安其拉神殿，受克苏恩的影响被改造成其拉虫人；东南方是古神亚煞极死去的地方，在这个地方定居下来的虫族在这里筑起了虫巢，叫做曼提维斯。 这就是魔兽世界巨魔和亚基虫两大种族的早期战争与分化过程。","source":"_posts/巨魔与虫族的世纪之战.md","raw":"title: 巨魔与虫族的世纪之战\ndate: 2016-08-26 08:33:00\ncategories: Azeroth\n-----------\n\n![](http://upload-images.jianshu.io/upload_images/1429775-134a3bc6a48cb352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n根据魔兽世界编年史的记录，巨魔一族永恒之井周围最早的原生物种。我们先来回顾一下永恒之井的产生，艾泽拉斯中心地带被最厉害的上古之神亚煞极占据，神父阿曼苏尔将其扯出，在破碎的泰坦身体处流出一道能量翔，这翔营养比较丰富，时间一长，周围自然而然的少不了吃翔的物种。 \n<!-- more -->\n\n\n魔兽历史时间线黑门前一万六千年，艾泽拉斯原驻民在永恒之井的滋润下逐渐兴盛。巨魔就是这其中的一支。这个物种的有两个特点，第一，食人，第二，巫毒魔法。它们的信仰是荒野众神“洛阿”。集网友们的猜测与推断，巨魔的早期物种原型应该是南美印第安人，俗称玛雅人。而上面的两个特点是支撑这个观点的依据，后面我们会专门分析一下艾泽拉斯早期物种及其原型的猜想。\n\n我们继续说回巨魔。早期的巨魔总结来说就是对内战争和对外战争的结合。我们说一个种族的强大是通过内部矛盾的发生来保持的，内部的竞争促进了各部族强壮的发育。巨魔一族在战争中逐渐崛起的部族分别是赞达拉，古拉巴什，阿曼尼和达卡莱。这四个部族我们在魔兽世界的前几个版本中都有接触过，其中赞达拉是在熊猫人大陆一个强悍的种族，古拉巴什在卡利姆多的祖尔法拉克，阿曼尼分布在祖阿曼和祖尔格拉布，而达卡莱则是在北极。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-14f0a671b878b7c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n人们常说，不作就不会死。这四个部族本来大家打的挺和谐，你争我抢的也分不出个胜负。可偏偏族内有巫师玩起通灵术，玩着玩着就玩出火，把恶魔给唤醒了。还记得跟守护者提尔打架的基希克斯吗？这个家伙就是上古神的小弟克瑟拉基大将，当初被洛肯派来追杀提尔未果，就跑到巨魔的地盘睡起觉来。结果就被巨魔人给吵醒了，基希克斯很生气，说：爬虫们，是什么样的祸事在这样早的时候发生，打断了老子的安睡？于是就把之前被提尔打散的亚基召唤回来，建立起个根据地叫做阿兹亚基（老子垃圾？）。\n\n俗话说“兄弟隙于内，外御其辱”，巨魔眼看这外来物种甚是强大，各部族联合起来组成巨魔联盟，顺带着把他们大神洛阿请出来，一众人就跟基希克斯开干。说到底这临时组起来的队伍就是不行，基希克斯这回是彻底把自己给玩死了。树倒猢孙散，小弟一见老大死了，就转而去投靠别的老大。\n\n\n![](http://upload-images.jianshu.io/upload_images/1429775-ef6eb5cedcaadb4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n赞达拉巨魔头领心想，这亚基也忒不行，打打就完蛋，打完这又要分地盘，不行得想办法给其他几个族支开。其他几个部族的头领也想自己不如赞达拉强，在这跟他争争不过，不如去别地占个山头去。于是大家开了个会，一致同意将这些跑的亚基赶尽杀绝，其实是明着分地盘。达莱卡向北追击，占据了北方冰封的土地；古拉巴什一族向西南进发，控制了原囚禁上古之神克苏恩的安其拉堡垒附近的大部分区域；阿曼尼一族则是去向了东北方基希克斯老巢，在那里建立起了圣城祖尔阿曼；剩下的赞达拉则继续在中部圣城祖尔达萨发布指令，起着联系各部族的作用。后期这个中心据点的作用逐渐被淡化，各巨魔在新领地形成了不同的种族特色与文化，赞达拉部族也退回了山地。 至于黑暗巨魔我们这里还没有涉及到，这个分支比较复杂，总体来看是部族间融合的结果。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-dd1611d508252c55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里顺道介绍下战败的亚基虫族的命运。亚基的四散也形成了不同的虫族分类，在北方的虫族由于受到尤格隆萨囚牢的影响，慢慢演化成奈幽虫族，在地底建立了强大的阿兹奥奈幽帝国；西南方虫族定居了安其拉神殿，受克苏恩的影响被改造成其拉虫人；东南方是古神亚煞极死去的地方，在这个地方定居下来的虫族在这里筑起了虫巢，叫做曼提维斯。 这就是魔兽世界巨魔和亚基虫两大种族的早期战争与分化过程。","slug":"巨魔与虫族的世纪之战","published":1,"updated":"2018-05-04T10:24:23.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciov002b1v604lvn24mt","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-134a3bc6a48cb352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>根据魔兽世界编年史的记录，巨魔一族永恒之井周围最早的原生物种。我们先来回顾一下永恒之井的产生，艾泽拉斯中心地带被最厉害的上古之神亚煞极占据，神父阿曼苏尔将其扯出，在破碎的泰坦身体处流出一道能量翔，这翔营养比较丰富，时间一长，周围自然而然的少不了吃翔的物种。<br><a id=\"more\"></a></p>\n<p>魔兽历史时间线黑门前一万六千年，艾泽拉斯原驻民在永恒之井的滋润下逐渐兴盛。巨魔就是这其中的一支。这个物种的有两个特点，第一，食人，第二，巫毒魔法。它们的信仰是荒野众神“洛阿”。集网友们的猜测与推断，巨魔的早期物种原型应该是南美印第安人，俗称玛雅人。而上面的两个特点是支撑这个观点的依据，后面我们会专门分析一下艾泽拉斯早期物种及其原型的猜想。</p>\n<p>我们继续说回巨魔。早期的巨魔总结来说就是对内战争和对外战争的结合。我们说一个种族的强大是通过内部矛盾的发生来保持的，内部的竞争促进了各部族强壮的发育。巨魔一族在战争中逐渐崛起的部族分别是赞达拉，古拉巴什，阿曼尼和达卡莱。这四个部族我们在魔兽世界的前几个版本中都有接触过，其中赞达拉是在熊猫人大陆一个强悍的种族，古拉巴什在卡利姆多的祖尔法拉克，阿曼尼分布在祖阿曼和祖尔格拉布，而达卡莱则是在北极。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-14f0a671b878b7c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>人们常说，不作就不会死。这四个部族本来大家打的挺和谐，你争我抢的也分不出个胜负。可偏偏族内有巫师玩起通灵术，玩着玩着就玩出火，把恶魔给唤醒了。还记得跟守护者提尔打架的基希克斯吗？这个家伙就是上古神的小弟克瑟拉基大将，当初被洛肯派来追杀提尔未果，就跑到巨魔的地盘睡起觉来。结果就被巨魔人给吵醒了，基希克斯很生气，说：爬虫们，是什么样的祸事在这样早的时候发生，打断了老子的安睡？于是就把之前被提尔打散的亚基召唤回来，建立起个根据地叫做阿兹亚基（老子垃圾？）。</p>\n<p>俗话说“兄弟隙于内，外御其辱”，巨魔眼看这外来物种甚是强大，各部族联合起来组成巨魔联盟，顺带着把他们大神洛阿请出来，一众人就跟基希克斯开干。说到底这临时组起来的队伍就是不行，基希克斯这回是彻底把自己给玩死了。树倒猢孙散，小弟一见老大死了，就转而去投靠别的老大。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-ef6eb5cedcaadb4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>赞达拉巨魔头领心想，这亚基也忒不行，打打就完蛋，打完这又要分地盘，不行得想办法给其他几个族支开。其他几个部族的头领也想自己不如赞达拉强，在这跟他争争不过，不如去别地占个山头去。于是大家开了个会，一致同意将这些跑的亚基赶尽杀绝，其实是明着分地盘。达莱卡向北追击，占据了北方冰封的土地；古拉巴什一族向西南进发，控制了原囚禁上古之神克苏恩的安其拉堡垒附近的大部分区域；阿曼尼一族则是去向了东北方基希克斯老巢，在那里建立起了圣城祖尔阿曼；剩下的赞达拉则继续在中部圣城祖尔达萨发布指令，起着联系各部族的作用。后期这个中心据点的作用逐渐被淡化，各巨魔在新领地形成了不同的种族特色与文化，赞达拉部族也退回了山地。 至于黑暗巨魔我们这里还没有涉及到，这个分支比较复杂，总体来看是部族间融合的结果。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-dd1611d508252c55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里顺道介绍下战败的亚基虫族的命运。亚基的四散也形成了不同的虫族分类，在北方的虫族由于受到尤格隆萨囚牢的影响，慢慢演化成奈幽虫族，在地底建立了强大的阿兹奥奈幽帝国；西南方虫族定居了安其拉神殿，受克苏恩的影响被改造成其拉虫人；东南方是古神亚煞极死去的地方，在这个地方定居下来的虫族在这里筑起了虫巢，叫做曼提维斯。 这就是魔兽世界巨魔和亚基虫两大种族的早期战争与分化过程。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-134a3bc6a48cb352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>根据魔兽世界编年史的记录，巨魔一族永恒之井周围最早的原生物种。我们先来回顾一下永恒之井的产生，艾泽拉斯中心地带被最厉害的上古之神亚煞极占据，神父阿曼苏尔将其扯出，在破碎的泰坦身体处流出一道能量翔，这翔营养比较丰富，时间一长，周围自然而然的少不了吃翔的物种。<br>","more":"</p>\n<p>魔兽历史时间线黑门前一万六千年，艾泽拉斯原驻民在永恒之井的滋润下逐渐兴盛。巨魔就是这其中的一支。这个物种的有两个特点，第一，食人，第二，巫毒魔法。它们的信仰是荒野众神“洛阿”。集网友们的猜测与推断，巨魔的早期物种原型应该是南美印第安人，俗称玛雅人。而上面的两个特点是支撑这个观点的依据，后面我们会专门分析一下艾泽拉斯早期物种及其原型的猜想。</p>\n<p>我们继续说回巨魔。早期的巨魔总结来说就是对内战争和对外战争的结合。我们说一个种族的强大是通过内部矛盾的发生来保持的，内部的竞争促进了各部族强壮的发育。巨魔一族在战争中逐渐崛起的部族分别是赞达拉，古拉巴什，阿曼尼和达卡莱。这四个部族我们在魔兽世界的前几个版本中都有接触过，其中赞达拉是在熊猫人大陆一个强悍的种族，古拉巴什在卡利姆多的祖尔法拉克，阿曼尼分布在祖阿曼和祖尔格拉布，而达卡莱则是在北极。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-14f0a671b878b7c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>人们常说，不作就不会死。这四个部族本来大家打的挺和谐，你争我抢的也分不出个胜负。可偏偏族内有巫师玩起通灵术，玩着玩着就玩出火，把恶魔给唤醒了。还记得跟守护者提尔打架的基希克斯吗？这个家伙就是上古神的小弟克瑟拉基大将，当初被洛肯派来追杀提尔未果，就跑到巨魔的地盘睡起觉来。结果就被巨魔人给吵醒了，基希克斯很生气，说：爬虫们，是什么样的祸事在这样早的时候发生，打断了老子的安睡？于是就把之前被提尔打散的亚基召唤回来，建立起个根据地叫做阿兹亚基（老子垃圾？）。</p>\n<p>俗话说“兄弟隙于内，外御其辱”，巨魔眼看这外来物种甚是强大，各部族联合起来组成巨魔联盟，顺带着把他们大神洛阿请出来，一众人就跟基希克斯开干。说到底这临时组起来的队伍就是不行，基希克斯这回是彻底把自己给玩死了。树倒猢孙散，小弟一见老大死了，就转而去投靠别的老大。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-ef6eb5cedcaadb4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>赞达拉巨魔头领心想，这亚基也忒不行，打打就完蛋，打完这又要分地盘，不行得想办法给其他几个族支开。其他几个部族的头领也想自己不如赞达拉强，在这跟他争争不过，不如去别地占个山头去。于是大家开了个会，一致同意将这些跑的亚基赶尽杀绝，其实是明着分地盘。达莱卡向北追击，占据了北方冰封的土地；古拉巴什一族向西南进发，控制了原囚禁上古之神克苏恩的安其拉堡垒附近的大部分区域；阿曼尼一族则是去向了东北方基希克斯老巢，在那里建立起了圣城祖尔阿曼；剩下的赞达拉则继续在中部圣城祖尔达萨发布指令，起着联系各部族的作用。后期这个中心据点的作用逐渐被淡化，各巨魔在新领地形成了不同的种族特色与文化，赞达拉部族也退回了山地。 至于黑暗巨魔我们这里还没有涉及到，这个分支比较复杂，总体来看是部族间融合的结果。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-dd1611d508252c55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里顺道介绍下战败的亚基虫族的命运。亚基的四散也形成了不同的虫族分类，在北方的虫族由于受到尤格隆萨囚牢的影响，慢慢演化成奈幽虫族，在地底建立了强大的阿兹奥奈幽帝国；西南方虫族定居了安其拉神殿，受克苏恩的影响被改造成其拉虫人；东南方是古神亚煞极死去的地方，在这个地方定居下来的虫族在这里筑起了虫巢，叫做曼提维斯。 这就是魔兽世界巨魔和亚基虫两大种族的早期战争与分化过程。</p>"},{"title":"朴素贝叶斯使用Python进行文本分类","date":"2018-04-17T15:08:00.000Z","_content":"这是我第一篇关于机器学习的文章。\n<!-- more -->\n\n1. 从文本中创建词向量bayes.py\n\n```\n#!usr/bin/python\n#-*-encoding:utf-8-*-\n\n'''\n该函数返回实验样本，该样本被切分成词条集合；\n第二个变量返回类别，该类别由人工标注，用于训练程序以便自动检查侮辱性留言；\n'''\ndef loadDataSet():\n\tpostingList = [\n\t\t['my','dog','has','flea','problems','help','please'],\n\t\t['maybe','not','take','him','to','dog','park','stupid'],\n\t\t['my','dalmation','is','so','cute','I','love','him'],\n\t\t['stop','posting','stupid','worthless','garbage'],\n\t\t['mr','licks','ate','my','steak','how','to','stop','him'],\n\t\t['quit','buying','worthless','dog','food','stupid']\n\t]\n\tclassVec = [0, 1, 0, 1, 0, 1] # 1代表侮辱性文字 0代表正常\n\treturn postingList, classVec\n\n'''\n\n'''\ndef createVocabList(dataSet):\n\tvocabSet = set([])\t#创建一个空集\n\tfor document in dataSet:\n\t\tvocabSet = vocabSet | set(document) #创建两集合并集\n\treturn list(vocabSet)\n\n'''\n该函数输入参数为词汇表及某个文档，输出的是文档向量，向量每一元素为1or0，分别表示词汇表中的单词在输入文档中是否出现\n'''\ndef setOfWords2Vec(vocabList, inputSet):\n\treturnVec = [0] * len(vocabList)\n\tfor word in inputSet:\n\t\tif word in vocabList:\n\t\t\treturnVec[vocabList.index(word)] = 1\n\t\telse:\n\t\t\tprint(\"the word: %s is not in my Vocabulary!\" % word)\n\treturn returnVec\n```\n![image_1cb7dhd105761rg11lkq1mgjpt19.png-132.9kB][1]\n\n2. 朴素贝叶斯训练函数\n\n```\n#朴素贝叶斯训练函数\ndef trainNB0(trainMatrix, trainCategory):\n\tnumTrainDocs = len(trainMatrix)\n\tnumWords = len(trainMatrix[0])\n\n\t#\n\tpAbusive = sum(trainCategory)/float(numTrainDocs) \n\n\t#某词出现次数\n\tp0Num = zeros(numWords)\n\tp1Num = zeros(numWords)\n\t#在所有的文档中，出现某词的文档的总词数\n\tp0Denom = 0.0\n\tp1Denom = 0.0\n\n\tfor i in range(numTrainDocs):\n\t\tif trainCategory[i] == 1:\n\t\t\tp1Num += trainMatrix[i]\n\t\t\tp1Denom += sum(trainMatrix[i])\n\t\telse:\n\t\t\tp0Num += trainMatrix[i]\n\t\t\tp0Denom += sum(trainMatrix[i])\n\n\tp1Vect = p1Num/p1Denom\n\tp0Vect = p0Num/p0Denom\n\n\treturn p0Vect, p1Vect, pAbusive\n```\n![image_1cb7gr8l6tli1gq8515ev19i013.png-368.4kB][2]\n\n![image_1cb7gs04bmv319kp11841cvq73i1g.png-125.3kB][3]\n\n3. 修改分类器\n\n* Problem1:计算多个概率的乘积以获得文档属于某个类别概率，如果其中有一个概率值为0，那最后乘积也为0；为降低这种影响，可以将所有词出现初始化为1，并将分母初始化为2\n```\n\tp0Num = ones(numWords); \n\tp1Num = ones(numWords)\n\tp0Denom = 2.0;\t\n\tp1Denom = 2.0\n```\n* Problem2: 下溢出，太多很小的数相乘会造成下溢出，解决办法是取自然对数，把乘法转换成加法，通过求对数避免下溢出或者浮点数舍入导致错误\n```\n    p1Vect = log(p1Num/p1Denom)\n\tp0Vect = log(p0Num/p0Denom)\n```   \n\n4. 分类器编写\n\n```\n#构建朴素贝叶斯分类函数\ndef classityNB(vec2Classify, p0Vec, p1Vec, pClass1):\n\tp1 = sum(vec2Classify * p1Vec) + log(pClass1)\n\tp0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1)\n\tif p1 > p0: \n\t\treturn 1;\n\telse: \n\t\treturn 0;\n\ndef testingNB():\n\tlistOPosts, listClasses = loadDataSet()\n\tmyVocabList = createVocabList(listOPosts)\n\ttrainMat = []\n\tfor postinDoc in listOPosts:\n\t\ttrainMat.append(setOfWords2Vec(myVocabList, postinDoc))\n\tp0V, p1V, pAb = trainNB0(array(trainMat), array(listClasses))\n\n\ttestEntry = ['love', 'my', 'dalmation']\n\tthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\n\tprint(testEntry, 'classified as:', classityNB(thisDoc, p0V, p1V, pAb))\n\n\ttestEntry = ['stupid', 'garbage']\n\tthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\n\tprint(testEntry, 'classified as:', classityNB(thisDoc, p0V, p1V, pAb))\t\n```\n通过训练器分类得出结果：\n![image_1cba21hoeuca2kt17n5bdu3e9p.png-38.4kB][4]\n\n5. 文档词袋模型\n\n```\n#文档词袋模型\ndef bagofWords2VecMN(vocabList, inputSet):\n\treturnVec = [0] * len(vocabList)\n\tfor word in inputSet:\n\t\tif word in vocabList:\n\t\t\treturnVec[vocabList.index(word)] += 1\n\treturn returnVec\n```\n\n\n  [1]: http://static.zybuluo.com/usiege/08jgn0fh17i3tesytmd39qsl/image_1cb7dhd105761rg11lkq1mgjpt19.png\n  [2]: http://static.zybuluo.com/usiege/41wgod8054yss08dj5zcae5d/image_1cb7gr8l6tli1gq8515ev19i013.png\n  [3]: http://static.zybuluo.com/usiege/vw73jzr2d42s7l5us6duu8d8/image_1cb7gs04bmv319kp11841cvq73i1g.png\n  [4]: http://static.zybuluo.com/usiege/qfnldhvk83es60qqfapx4kn4/image_1cba21hoeuca2kt17n5bdu3e9p.png","source":"_posts/朴素贝叶斯使用Python进行文本分类.md","raw":"title: 朴素贝叶斯使用Python进行文本分类\ndate: 2018-04-17 23:08:00\ncategories: coder\ntags: [Python, Mechine-Learning]\n-----------\n这是我第一篇关于机器学习的文章。\n<!-- more -->\n\n1. 从文本中创建词向量bayes.py\n\n```\n#!usr/bin/python\n#-*-encoding:utf-8-*-\n\n'''\n该函数返回实验样本，该样本被切分成词条集合；\n第二个变量返回类别，该类别由人工标注，用于训练程序以便自动检查侮辱性留言；\n'''\ndef loadDataSet():\n\tpostingList = [\n\t\t['my','dog','has','flea','problems','help','please'],\n\t\t['maybe','not','take','him','to','dog','park','stupid'],\n\t\t['my','dalmation','is','so','cute','I','love','him'],\n\t\t['stop','posting','stupid','worthless','garbage'],\n\t\t['mr','licks','ate','my','steak','how','to','stop','him'],\n\t\t['quit','buying','worthless','dog','food','stupid']\n\t]\n\tclassVec = [0, 1, 0, 1, 0, 1] # 1代表侮辱性文字 0代表正常\n\treturn postingList, classVec\n\n'''\n\n'''\ndef createVocabList(dataSet):\n\tvocabSet = set([])\t#创建一个空集\n\tfor document in dataSet:\n\t\tvocabSet = vocabSet | set(document) #创建两集合并集\n\treturn list(vocabSet)\n\n'''\n该函数输入参数为词汇表及某个文档，输出的是文档向量，向量每一元素为1or0，分别表示词汇表中的单词在输入文档中是否出现\n'''\ndef setOfWords2Vec(vocabList, inputSet):\n\treturnVec = [0] * len(vocabList)\n\tfor word in inputSet:\n\t\tif word in vocabList:\n\t\t\treturnVec[vocabList.index(word)] = 1\n\t\telse:\n\t\t\tprint(\"the word: %s is not in my Vocabulary!\" % word)\n\treturn returnVec\n```\n![image_1cb7dhd105761rg11lkq1mgjpt19.png-132.9kB][1]\n\n2. 朴素贝叶斯训练函数\n\n```\n#朴素贝叶斯训练函数\ndef trainNB0(trainMatrix, trainCategory):\n\tnumTrainDocs = len(trainMatrix)\n\tnumWords = len(trainMatrix[0])\n\n\t#\n\tpAbusive = sum(trainCategory)/float(numTrainDocs) \n\n\t#某词出现次数\n\tp0Num = zeros(numWords)\n\tp1Num = zeros(numWords)\n\t#在所有的文档中，出现某词的文档的总词数\n\tp0Denom = 0.0\n\tp1Denom = 0.0\n\n\tfor i in range(numTrainDocs):\n\t\tif trainCategory[i] == 1:\n\t\t\tp1Num += trainMatrix[i]\n\t\t\tp1Denom += sum(trainMatrix[i])\n\t\telse:\n\t\t\tp0Num += trainMatrix[i]\n\t\t\tp0Denom += sum(trainMatrix[i])\n\n\tp1Vect = p1Num/p1Denom\n\tp0Vect = p0Num/p0Denom\n\n\treturn p0Vect, p1Vect, pAbusive\n```\n![image_1cb7gr8l6tli1gq8515ev19i013.png-368.4kB][2]\n\n![image_1cb7gs04bmv319kp11841cvq73i1g.png-125.3kB][3]\n\n3. 修改分类器\n\n* Problem1:计算多个概率的乘积以获得文档属于某个类别概率，如果其中有一个概率值为0，那最后乘积也为0；为降低这种影响，可以将所有词出现初始化为1，并将分母初始化为2\n```\n\tp0Num = ones(numWords); \n\tp1Num = ones(numWords)\n\tp0Denom = 2.0;\t\n\tp1Denom = 2.0\n```\n* Problem2: 下溢出，太多很小的数相乘会造成下溢出，解决办法是取自然对数，把乘法转换成加法，通过求对数避免下溢出或者浮点数舍入导致错误\n```\n    p1Vect = log(p1Num/p1Denom)\n\tp0Vect = log(p0Num/p0Denom)\n```   \n\n4. 分类器编写\n\n```\n#构建朴素贝叶斯分类函数\ndef classityNB(vec2Classify, p0Vec, p1Vec, pClass1):\n\tp1 = sum(vec2Classify * p1Vec) + log(pClass1)\n\tp0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1)\n\tif p1 > p0: \n\t\treturn 1;\n\telse: \n\t\treturn 0;\n\ndef testingNB():\n\tlistOPosts, listClasses = loadDataSet()\n\tmyVocabList = createVocabList(listOPosts)\n\ttrainMat = []\n\tfor postinDoc in listOPosts:\n\t\ttrainMat.append(setOfWords2Vec(myVocabList, postinDoc))\n\tp0V, p1V, pAb = trainNB0(array(trainMat), array(listClasses))\n\n\ttestEntry = ['love', 'my', 'dalmation']\n\tthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\n\tprint(testEntry, 'classified as:', classityNB(thisDoc, p0V, p1V, pAb))\n\n\ttestEntry = ['stupid', 'garbage']\n\tthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\n\tprint(testEntry, 'classified as:', classityNB(thisDoc, p0V, p1V, pAb))\t\n```\n通过训练器分类得出结果：\n![image_1cba21hoeuca2kt17n5bdu3e9p.png-38.4kB][4]\n\n5. 文档词袋模型\n\n```\n#文档词袋模型\ndef bagofWords2VecMN(vocabList, inputSet):\n\treturnVec = [0] * len(vocabList)\n\tfor word in inputSet:\n\t\tif word in vocabList:\n\t\t\treturnVec[vocabList.index(word)] += 1\n\treturn returnVec\n```\n\n\n  [1]: http://static.zybuluo.com/usiege/08jgn0fh17i3tesytmd39qsl/image_1cb7dhd105761rg11lkq1mgjpt19.png\n  [2]: http://static.zybuluo.com/usiege/41wgod8054yss08dj5zcae5d/image_1cb7gr8l6tli1gq8515ev19i013.png\n  [3]: http://static.zybuluo.com/usiege/vw73jzr2d42s7l5us6duu8d8/image_1cb7gs04bmv319kp11841cvq73i1g.png\n  [4]: http://static.zybuluo.com/usiege/qfnldhvk83es60qqfapx4kn4/image_1cba21hoeuca2kt17n5bdu3e9p.png","slug":"朴素贝叶斯使用Python进行文本分类","published":1,"updated":"2018-05-04T08:50:50.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgruciox002e1v60e13n0e05","content":"<p>这是我第一篇关于机器学习的文章。<br><a id=\"more\"></a></p>\n<ol>\n<li>从文本中创建词向量bayes.py</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!usr/bin/python</span><br><span class=\"line\">#-*-encoding:utf-8-*-</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">该函数返回实验样本，该样本被切分成词条集合；</span><br><span class=\"line\">第二个变量返回类别，该类别由人工标注，用于训练程序以便自动检查侮辱性留言；</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">def loadDataSet():</span><br><span class=\"line\">\tpostingList = [</span><br><span class=\"line\">\t\t[&apos;my&apos;,&apos;dog&apos;,&apos;has&apos;,&apos;flea&apos;,&apos;problems&apos;,&apos;help&apos;,&apos;please&apos;],</span><br><span class=\"line\">\t\t[&apos;maybe&apos;,&apos;not&apos;,&apos;take&apos;,&apos;him&apos;,&apos;to&apos;,&apos;dog&apos;,&apos;park&apos;,&apos;stupid&apos;],</span><br><span class=\"line\">\t\t[&apos;my&apos;,&apos;dalmation&apos;,&apos;is&apos;,&apos;so&apos;,&apos;cute&apos;,&apos;I&apos;,&apos;love&apos;,&apos;him&apos;],</span><br><span class=\"line\">\t\t[&apos;stop&apos;,&apos;posting&apos;,&apos;stupid&apos;,&apos;worthless&apos;,&apos;garbage&apos;],</span><br><span class=\"line\">\t\t[&apos;mr&apos;,&apos;licks&apos;,&apos;ate&apos;,&apos;my&apos;,&apos;steak&apos;,&apos;how&apos;,&apos;to&apos;,&apos;stop&apos;,&apos;him&apos;],</span><br><span class=\"line\">\t\t[&apos;quit&apos;,&apos;buying&apos;,&apos;worthless&apos;,&apos;dog&apos;,&apos;food&apos;,&apos;stupid&apos;]</span><br><span class=\"line\">\t]</span><br><span class=\"line\">\tclassVec = [0, 1, 0, 1, 0, 1] # 1代表侮辱性文字 0代表正常</span><br><span class=\"line\">\treturn postingList, classVec</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">def createVocabList(dataSet):</span><br><span class=\"line\">\tvocabSet = set([])\t#创建一个空集</span><br><span class=\"line\">\tfor document in dataSet:</span><br><span class=\"line\">\t\tvocabSet = vocabSet | set(document) #创建两集合并集</span><br><span class=\"line\">\treturn list(vocabSet)</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">该函数输入参数为词汇表及某个文档，输出的是文档向量，向量每一元素为1or0，分别表示词汇表中的单词在输入文档中是否出现</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">def setOfWords2Vec(vocabList, inputSet):</span><br><span class=\"line\">\treturnVec = [0] * len(vocabList)</span><br><span class=\"line\">\tfor word in inputSet:</span><br><span class=\"line\">\t\tif word in vocabList:</span><br><span class=\"line\">\t\t\treturnVec[vocabList.index(word)] = 1</span><br><span class=\"line\">\t\telse:</span><br><span class=\"line\">\t\t\tprint(&quot;the word: %s is not in my Vocabulary!&quot; % word)</span><br><span class=\"line\">\treturn returnVec</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://static.zybuluo.com/usiege/08jgn0fh17i3tesytmd39qsl/image_1cb7dhd105761rg11lkq1mgjpt19.png\" alt=\"image_1cb7dhd105761rg11lkq1mgjpt19.png-132.9kB\"></p>\n<ol start=\"2\">\n<li>朴素贝叶斯训练函数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#朴素贝叶斯训练函数</span><br><span class=\"line\">def trainNB0(trainMatrix, trainCategory):</span><br><span class=\"line\">\tnumTrainDocs = len(trainMatrix)</span><br><span class=\"line\">\tnumWords = len(trainMatrix[0])</span><br><span class=\"line\"></span><br><span class=\"line\">\t#</span><br><span class=\"line\">\tpAbusive = sum(trainCategory)/float(numTrainDocs) </span><br><span class=\"line\"></span><br><span class=\"line\">\t#某词出现次数</span><br><span class=\"line\">\tp0Num = zeros(numWords)</span><br><span class=\"line\">\tp1Num = zeros(numWords)</span><br><span class=\"line\">\t#在所有的文档中，出现某词的文档的总词数</span><br><span class=\"line\">\tp0Denom = 0.0</span><br><span class=\"line\">\tp1Denom = 0.0</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor i in range(numTrainDocs):</span><br><span class=\"line\">\t\tif trainCategory[i] == 1:</span><br><span class=\"line\">\t\t\tp1Num += trainMatrix[i]</span><br><span class=\"line\">\t\t\tp1Denom += sum(trainMatrix[i])</span><br><span class=\"line\">\t\telse:</span><br><span class=\"line\">\t\t\tp0Num += trainMatrix[i]</span><br><span class=\"line\">\t\t\tp0Denom += sum(trainMatrix[i])</span><br><span class=\"line\"></span><br><span class=\"line\">\tp1Vect = p1Num/p1Denom</span><br><span class=\"line\">\tp0Vect = p0Num/p0Denom</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn p0Vect, p1Vect, pAbusive</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://static.zybuluo.com/usiege/41wgod8054yss08dj5zcae5d/image_1cb7gr8l6tli1gq8515ev19i013.png\" alt=\"image_1cb7gr8l6tli1gq8515ev19i013.png-368.4kB\"></p>\n<p><img src=\"http://static.zybuluo.com/usiege/vw73jzr2d42s7l5us6duu8d8/image_1cb7gs04bmv319kp11841cvq73i1g.png\" alt=\"image_1cb7gs04bmv319kp11841cvq73i1g.png-125.3kB\"></p>\n<ol start=\"3\">\n<li>修改分类器</li>\n</ol>\n<ul>\n<li><p>Problem1:计算多个概率的乘积以获得文档属于某个类别概率，如果其中有一个概率值为0，那最后乘积也为0；为降低这种影响，可以将所有词出现初始化为1，并将分母初始化为2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p0Num = ones(numWords); </span><br><span class=\"line\">p1Num = ones(numWords)</span><br><span class=\"line\">p0Denom = 2.0;\t</span><br><span class=\"line\">p1Denom = 2.0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Problem2: 下溢出，太多很小的数相乘会造成下溢出，解决办法是取自然对数，把乘法转换成加法，通过求对数避免下溢出或者浮点数舍入导致错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    p1Vect = log(p1Num/p1Denom)</span><br><span class=\"line\">\tp0Vect = log(p0Num/p0Denom)</span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">4. 分类器编写</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>#构建朴素贝叶斯分类函数<br>def classityNB(vec2Classify, p0Vec, p1Vec, pClass1):<br>    p1 = sum(vec2Classify <em> p1Vec) + log(pClass1)<br>    p0 = sum(vec2Classify </em> p0Vec) + log(1.0 - pClass1)<br>    if p1 &gt; p0:<br>        return 1;<br>    else:<br>        return 0;</p>\n<p>def testingNB():<br>    listOPosts, listClasses = loadDataSet()<br>    myVocabList = createVocabList(listOPosts)<br>    trainMat = []<br>    for postinDoc in listOPosts:<br>        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))<br>    p0V, p1V, pAb = trainNB0(array(trainMat), array(listClasses))</p>\n<pre><code>testEntry = [&apos;love&apos;, &apos;my&apos;, &apos;dalmation&apos;]\nthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\nprint(testEntry, &apos;classified as:&apos;, classityNB(thisDoc, p0V, p1V, pAb))\n\ntestEntry = [&apos;stupid&apos;, &apos;garbage&apos;]\nthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\nprint(testEntry, &apos;classified as:&apos;, classityNB(thisDoc, p0V, p1V, pAb))    \n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过训练器分类得出结果：</span><br><span class=\"line\">![image_1cba21hoeuca2kt17n5bdu3e9p.png-38.4kB][4]</span><br><span class=\"line\"></span><br><span class=\"line\">5. 文档词袋模型</span><br></pre></td></tr></table></figure>\n<p>#文档词袋模型<br>def bagofWords2VecMN(vocabList, inputSet):<br>    returnVec = [0] * len(vocabList)<br>    for word in inputSet:<br>        if word in vocabList:<br>            returnVec[vocabList.index(word)] += 1<br>    return returnVec<br><code>`</code></p>\n","site":{"data":{}},"excerpt":"<p>这是我第一篇关于机器学习的文章。<br>","more":"</p>\n<ol>\n<li>从文本中创建词向量bayes.py</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!usr/bin/python</span><br><span class=\"line\">#-*-encoding:utf-8-*-</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">该函数返回实验样本，该样本被切分成词条集合；</span><br><span class=\"line\">第二个变量返回类别，该类别由人工标注，用于训练程序以便自动检查侮辱性留言；</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">def loadDataSet():</span><br><span class=\"line\">\tpostingList = [</span><br><span class=\"line\">\t\t[&apos;my&apos;,&apos;dog&apos;,&apos;has&apos;,&apos;flea&apos;,&apos;problems&apos;,&apos;help&apos;,&apos;please&apos;],</span><br><span class=\"line\">\t\t[&apos;maybe&apos;,&apos;not&apos;,&apos;take&apos;,&apos;him&apos;,&apos;to&apos;,&apos;dog&apos;,&apos;park&apos;,&apos;stupid&apos;],</span><br><span class=\"line\">\t\t[&apos;my&apos;,&apos;dalmation&apos;,&apos;is&apos;,&apos;so&apos;,&apos;cute&apos;,&apos;I&apos;,&apos;love&apos;,&apos;him&apos;],</span><br><span class=\"line\">\t\t[&apos;stop&apos;,&apos;posting&apos;,&apos;stupid&apos;,&apos;worthless&apos;,&apos;garbage&apos;],</span><br><span class=\"line\">\t\t[&apos;mr&apos;,&apos;licks&apos;,&apos;ate&apos;,&apos;my&apos;,&apos;steak&apos;,&apos;how&apos;,&apos;to&apos;,&apos;stop&apos;,&apos;him&apos;],</span><br><span class=\"line\">\t\t[&apos;quit&apos;,&apos;buying&apos;,&apos;worthless&apos;,&apos;dog&apos;,&apos;food&apos;,&apos;stupid&apos;]</span><br><span class=\"line\">\t]</span><br><span class=\"line\">\tclassVec = [0, 1, 0, 1, 0, 1] # 1代表侮辱性文字 0代表正常</span><br><span class=\"line\">\treturn postingList, classVec</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">def createVocabList(dataSet):</span><br><span class=\"line\">\tvocabSet = set([])\t#创建一个空集</span><br><span class=\"line\">\tfor document in dataSet:</span><br><span class=\"line\">\t\tvocabSet = vocabSet | set(document) #创建两集合并集</span><br><span class=\"line\">\treturn list(vocabSet)</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">该函数输入参数为词汇表及某个文档，输出的是文档向量，向量每一元素为1or0，分别表示词汇表中的单词在输入文档中是否出现</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">def setOfWords2Vec(vocabList, inputSet):</span><br><span class=\"line\">\treturnVec = [0] * len(vocabList)</span><br><span class=\"line\">\tfor word in inputSet:</span><br><span class=\"line\">\t\tif word in vocabList:</span><br><span class=\"line\">\t\t\treturnVec[vocabList.index(word)] = 1</span><br><span class=\"line\">\t\telse:</span><br><span class=\"line\">\t\t\tprint(&quot;the word: %s is not in my Vocabulary!&quot; % word)</span><br><span class=\"line\">\treturn returnVec</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://static.zybuluo.com/usiege/08jgn0fh17i3tesytmd39qsl/image_1cb7dhd105761rg11lkq1mgjpt19.png\" alt=\"image_1cb7dhd105761rg11lkq1mgjpt19.png-132.9kB\"></p>\n<ol start=\"2\">\n<li>朴素贝叶斯训练函数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#朴素贝叶斯训练函数</span><br><span class=\"line\">def trainNB0(trainMatrix, trainCategory):</span><br><span class=\"line\">\tnumTrainDocs = len(trainMatrix)</span><br><span class=\"line\">\tnumWords = len(trainMatrix[0])</span><br><span class=\"line\"></span><br><span class=\"line\">\t#</span><br><span class=\"line\">\tpAbusive = sum(trainCategory)/float(numTrainDocs) </span><br><span class=\"line\"></span><br><span class=\"line\">\t#某词出现次数</span><br><span class=\"line\">\tp0Num = zeros(numWords)</span><br><span class=\"line\">\tp1Num = zeros(numWords)</span><br><span class=\"line\">\t#在所有的文档中，出现某词的文档的总词数</span><br><span class=\"line\">\tp0Denom = 0.0</span><br><span class=\"line\">\tp1Denom = 0.0</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor i in range(numTrainDocs):</span><br><span class=\"line\">\t\tif trainCategory[i] == 1:</span><br><span class=\"line\">\t\t\tp1Num += trainMatrix[i]</span><br><span class=\"line\">\t\t\tp1Denom += sum(trainMatrix[i])</span><br><span class=\"line\">\t\telse:</span><br><span class=\"line\">\t\t\tp0Num += trainMatrix[i]</span><br><span class=\"line\">\t\t\tp0Denom += sum(trainMatrix[i])</span><br><span class=\"line\"></span><br><span class=\"line\">\tp1Vect = p1Num/p1Denom</span><br><span class=\"line\">\tp0Vect = p0Num/p0Denom</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn p0Vect, p1Vect, pAbusive</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://static.zybuluo.com/usiege/41wgod8054yss08dj5zcae5d/image_1cb7gr8l6tli1gq8515ev19i013.png\" alt=\"image_1cb7gr8l6tli1gq8515ev19i013.png-368.4kB\"></p>\n<p><img src=\"http://static.zybuluo.com/usiege/vw73jzr2d42s7l5us6duu8d8/image_1cb7gs04bmv319kp11841cvq73i1g.png\" alt=\"image_1cb7gs04bmv319kp11841cvq73i1g.png-125.3kB\"></p>\n<ol start=\"3\">\n<li>修改分类器</li>\n</ol>\n<ul>\n<li><p>Problem1:计算多个概率的乘积以获得文档属于某个类别概率，如果其中有一个概率值为0，那最后乘积也为0；为降低这种影响，可以将所有词出现初始化为1，并将分母初始化为2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p0Num = ones(numWords); </span><br><span class=\"line\">p1Num = ones(numWords)</span><br><span class=\"line\">p0Denom = 2.0;\t</span><br><span class=\"line\">p1Denom = 2.0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Problem2: 下溢出，太多很小的数相乘会造成下溢出，解决办法是取自然对数，把乘法转换成加法，通过求对数避免下溢出或者浮点数舍入导致错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    p1Vect = log(p1Num/p1Denom)</span><br><span class=\"line\">\tp0Vect = log(p0Num/p0Denom)</span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">4. 分类器编写</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>#构建朴素贝叶斯分类函数<br>def classityNB(vec2Classify, p0Vec, p1Vec, pClass1):<br>    p1 = sum(vec2Classify <em> p1Vec) + log(pClass1)<br>    p0 = sum(vec2Classify </em> p0Vec) + log(1.0 - pClass1)<br>    if p1 &gt; p0:<br>        return 1;<br>    else:<br>        return 0;</p>\n<p>def testingNB():<br>    listOPosts, listClasses = loadDataSet()<br>    myVocabList = createVocabList(listOPosts)<br>    trainMat = []<br>    for postinDoc in listOPosts:<br>        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))<br>    p0V, p1V, pAb = trainNB0(array(trainMat), array(listClasses))</p>\n<pre><code>testEntry = [&apos;love&apos;, &apos;my&apos;, &apos;dalmation&apos;]\nthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\nprint(testEntry, &apos;classified as:&apos;, classityNB(thisDoc, p0V, p1V, pAb))\n\ntestEntry = [&apos;stupid&apos;, &apos;garbage&apos;]\nthisDoc = array(setOfWords2Vec(myVocabList, testEntry))\nprint(testEntry, &apos;classified as:&apos;, classityNB(thisDoc, p0V, p1V, pAb))    \n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过训练器分类得出结果：</span><br><span class=\"line\">![image_1cba21hoeuca2kt17n5bdu3e9p.png-38.4kB][4]</span><br><span class=\"line\"></span><br><span class=\"line\">5. 文档词袋模型</span><br></pre></td></tr></table></figure>\n<p>#文档词袋模型<br>def bagofWords2VecMN(vocabList, inputSet):<br>    returnVec = [0] * len(vocabList)<br>    for word in inputSet:<br>        if word in vocabList:<br>            returnVec[vocabList.index(word)] += 1<br>    return returnVec<br><code>`</code></p>"},{"title":"我为何这样堕落？","date":"2016-08-11T00:30:00.000Z","_content":"\n![图文无关](http://upload-images.jianshu.io/upload_images/1429775-10d2a560272a60a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n所有艾泽拉斯的原驻及非原驻渣子们，我是你们的神（这个时候，我是不是该有一句台词“I’m the King!”）。这个称呼对我来说是再合适不过了，因为我本来就是这个世界的神，只不过我后来堕落了，不过，那又怎么样呢，我还是神一般的存在。\n\n或许你们当中有很多人非常非常地恨我，但是我说的这些人都差不多死的死，跑的跑，比方说伊利丹，阿尔萨斯，古尔丹？可是又但是，即使是他们与我也没有什么直接的关系。我只是一个被你们称为“万恶的源头”罢了。这里我说的恨我的人是指你们这些凡人们，是你们这些还在论坛上争吵到底用点卡还是用分钟数来玩游戏的准备杀我的玩家们。\n\n我并不觉得你们应该恨我，没有我，你们在艾泽拉斯也没有那么多的事可以做，我说的对不对呢？话说我来这里已经几个世纪了，换算成你们人类的时间应该是十几年，在这期间我从来没有出现在你们面前，事实上我真的是个神的存在，神总是孤独的。\n\n哦，对了，我堕落的最开始，也是因为孤独。我玩你们地球人的微博，在上面看到一句称做“鸡汤”的话，说什么优秀的人成功之前都必须有一个孤独的过程。我尼玛活的够长了，头回听到这么扯淡的话。老子就是因为太孤独了，最后闲的蛋疼才打算干坏事的。所以说这话的以及觉得这话挺对的，还是给自己找点事干吧，学我，干坏事也比憋着强啊。憋死你个龟孙儿！\n\n其实我本来不打算干那些伤天害理的事，只是阿曼苏尔那老头整天在我面前BB，烦的不行。后来还他**的给我派来个小弟监视我（唉呀，我又说脏话了，自己屏蔽成星），实在是让人不能忍，我一气之下，就把那小子给砍了，就当着那群二货神们的面。当时那画面的确有点血腥，反正我是闭眼了，主要我怕把血溅眼睛里。\n\n老头一看可吓坏了，叫帮手准备弄我。还好哥是练过的，一下把他们全干死了，不过我还是给他们留了灵魂，他们当时还以为我不知道。共事一场，哥也不是那种把事做绝的人，对吧。他们就整天用无线脑电波跟他们那些小弟联络，但是据说信号也不怎么好，主要还是因为官方的东西当时建的时候好多都是豆腐渣，现在轮到他们自己用了，活该信号不好。\n\n接下来，你们都知道啦。哥有了山头，也招了一批小弟，在宇宙里开始实行哥的“三光政策”。当了老大才知道，小弟也不是那么好管的，这群小弟猛是猛，不过都是楞头青，一点脑子都没有，沟通简直是太废劲。你想啊，我一个神，跟一堆**（这里的星星你们自己补）没法说话，代沟啊！\n\n我于是就在一个阿古斯的地方找了一群高级的天外种族，这个种族的人可足够聪明，有什么高科技之类的玩意，你们人类现在的科技估计在他们那连小儿科都算不上。那个种族叫什么艾瑞达，长相也比较好看，被我稍加改造，长的足够像坏人。\n然后我就开始给他们讲经嘛，你想啊，统治什么的，需要靠的是脑子，要深入人心。你们人类历史上不是用宗教来统治国家嘛，这都一个道理，改天我得收你们版权费。\n\n这艾瑞达种族里有三个头，一个叫基尔加丹，一个叫阿克蒙德，还有一个是维仑。刚开始他们反正都挺崇拜哥的，而且有一些理念小基和小阿还跟我的观点很契合，就那个叫维仑的，总以为我是在忽悠他们。靠，哥是那种人么，要不是看你们聪明，不废话早干你们了。我总觉得这家伙鸡贼，不过他倒也没怎么跟我发生正面冲突，我也就没找他茬儿。\n\n最后这家伙还是带着一群人跑了，据说还联系上了纳鲁什么的。我也不知道那个鲁是什么玩意，估计也是有点小本事，自己封个神就出来招摇撞骗了。跑就跑呗，哥也不差你这一个，哥还有更重要事呢！\n\n好在小基和小阿都挺给力，我就给他们的名字加了点前缀，听起来具霸气：欺诈者基尔加丹，污染者阿克蒙德。我教给他们了一些法术，就让他们替我做事去了。这两个家伙挺厉害，把我那堆小弟整的服服贴贴的，而且小基还给我又招来了更多新的种群，总的来说，哥还是相当满意的。\n\n维仑那个家伙么，坐着纳鲁给他的飞船跑河外星系了，还挺文艺的给自己起名“德兰尼”（意思就是流亡者），那就让你们王八。反正我是不会亲自动手的，伤手（立白广告商加钱啊）。哥巧妙的利用了维仑和小基的嫌隙，因为我觉得这两个小伙有基情。管他呢，我可没有那么八卦，反正小基是气的不行，满世界的找维仑，说一定要追到天涯海角。听的我菊花一紧，一定有基情！\n\n后来呢，我听说阿曼苏尔老头找到了一个我的兄弟，叫艾泽拉斯，就是你们现在住的地方。而且这个兄弟貌似比哥还厉害，我独孤求败怎么能不找他呢，后来就找啊找，找啊找，找到一个好朋友…….\n\n再然后呢，唉呀，哥笔记本没电了呢，不是说你们地球人这东西质量就是不行，我得找个小弟给我冲冲电。今天就写到这吧，估计有错别字，也不带查了。\n\n记得去艾泽拉斯做日常哦。不来哥连你也弄。","source":"_posts/我为何这样堕落？.md","raw":"title: 我为何这样堕落？\ndate: 2016-08-11 08:30:00\ncategories: Azeroth\n-----------\n\n![图文无关](http://upload-images.jianshu.io/upload_images/1429775-10d2a560272a60a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n所有艾泽拉斯的原驻及非原驻渣子们，我是你们的神（这个时候，我是不是该有一句台词“I’m the King!”）。这个称呼对我来说是再合适不过了，因为我本来就是这个世界的神，只不过我后来堕落了，不过，那又怎么样呢，我还是神一般的存在。\n\n或许你们当中有很多人非常非常地恨我，但是我说的这些人都差不多死的死，跑的跑，比方说伊利丹，阿尔萨斯，古尔丹？可是又但是，即使是他们与我也没有什么直接的关系。我只是一个被你们称为“万恶的源头”罢了。这里我说的恨我的人是指你们这些凡人们，是你们这些还在论坛上争吵到底用点卡还是用分钟数来玩游戏的准备杀我的玩家们。\n\n我并不觉得你们应该恨我，没有我，你们在艾泽拉斯也没有那么多的事可以做，我说的对不对呢？话说我来这里已经几个世纪了，换算成你们人类的时间应该是十几年，在这期间我从来没有出现在你们面前，事实上我真的是个神的存在，神总是孤独的。\n\n哦，对了，我堕落的最开始，也是因为孤独。我玩你们地球人的微博，在上面看到一句称做“鸡汤”的话，说什么优秀的人成功之前都必须有一个孤独的过程。我尼玛活的够长了，头回听到这么扯淡的话。老子就是因为太孤独了，最后闲的蛋疼才打算干坏事的。所以说这话的以及觉得这话挺对的，还是给自己找点事干吧，学我，干坏事也比憋着强啊。憋死你个龟孙儿！\n\n其实我本来不打算干那些伤天害理的事，只是阿曼苏尔那老头整天在我面前BB，烦的不行。后来还他**的给我派来个小弟监视我（唉呀，我又说脏话了，自己屏蔽成星），实在是让人不能忍，我一气之下，就把那小子给砍了，就当着那群二货神们的面。当时那画面的确有点血腥，反正我是闭眼了，主要我怕把血溅眼睛里。\n\n老头一看可吓坏了，叫帮手准备弄我。还好哥是练过的，一下把他们全干死了，不过我还是给他们留了灵魂，他们当时还以为我不知道。共事一场，哥也不是那种把事做绝的人，对吧。他们就整天用无线脑电波跟他们那些小弟联络，但是据说信号也不怎么好，主要还是因为官方的东西当时建的时候好多都是豆腐渣，现在轮到他们自己用了，活该信号不好。\n\n接下来，你们都知道啦。哥有了山头，也招了一批小弟，在宇宙里开始实行哥的“三光政策”。当了老大才知道，小弟也不是那么好管的，这群小弟猛是猛，不过都是楞头青，一点脑子都没有，沟通简直是太废劲。你想啊，我一个神，跟一堆**（这里的星星你们自己补）没法说话，代沟啊！\n\n我于是就在一个阿古斯的地方找了一群高级的天外种族，这个种族的人可足够聪明，有什么高科技之类的玩意，你们人类现在的科技估计在他们那连小儿科都算不上。那个种族叫什么艾瑞达，长相也比较好看，被我稍加改造，长的足够像坏人。\n然后我就开始给他们讲经嘛，你想啊，统治什么的，需要靠的是脑子，要深入人心。你们人类历史上不是用宗教来统治国家嘛，这都一个道理，改天我得收你们版权费。\n\n这艾瑞达种族里有三个头，一个叫基尔加丹，一个叫阿克蒙德，还有一个是维仑。刚开始他们反正都挺崇拜哥的，而且有一些理念小基和小阿还跟我的观点很契合，就那个叫维仑的，总以为我是在忽悠他们。靠，哥是那种人么，要不是看你们聪明，不废话早干你们了。我总觉得这家伙鸡贼，不过他倒也没怎么跟我发生正面冲突，我也就没找他茬儿。\n\n最后这家伙还是带着一群人跑了，据说还联系上了纳鲁什么的。我也不知道那个鲁是什么玩意，估计也是有点小本事，自己封个神就出来招摇撞骗了。跑就跑呗，哥也不差你这一个，哥还有更重要事呢！\n\n好在小基和小阿都挺给力，我就给他们的名字加了点前缀，听起来具霸气：欺诈者基尔加丹，污染者阿克蒙德。我教给他们了一些法术，就让他们替我做事去了。这两个家伙挺厉害，把我那堆小弟整的服服贴贴的，而且小基还给我又招来了更多新的种群，总的来说，哥还是相当满意的。\n\n维仑那个家伙么，坐着纳鲁给他的飞船跑河外星系了，还挺文艺的给自己起名“德兰尼”（意思就是流亡者），那就让你们王八。反正我是不会亲自动手的，伤手（立白广告商加钱啊）。哥巧妙的利用了维仑和小基的嫌隙，因为我觉得这两个小伙有基情。管他呢，我可没有那么八卦，反正小基是气的不行，满世界的找维仑，说一定要追到天涯海角。听的我菊花一紧，一定有基情！\n\n后来呢，我听说阿曼苏尔老头找到了一个我的兄弟，叫艾泽拉斯，就是你们现在住的地方。而且这个兄弟貌似比哥还厉害，我独孤求败怎么能不找他呢，后来就找啊找，找啊找，找到一个好朋友…….\n\n再然后呢，唉呀，哥笔记本没电了呢，不是说你们地球人这东西质量就是不行，我得找个小弟给我冲冲电。今天就写到这吧，估计有错别字，也不带查了。\n\n记得去艾泽拉斯做日常哦。不来哥连你也弄。","slug":"我为何这样堕落？","published":1,"updated":"2018-05-04T10:24:36.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucioz002i1v609dpp0ywv","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-10d2a560272a60a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图文无关\"></p>\n<a id=\"more\"></a>\n<p>所有艾泽拉斯的原驻及非原驻渣子们，我是你们的神（这个时候，我是不是该有一句台词“I’m the King!”）。这个称呼对我来说是再合适不过了，因为我本来就是这个世界的神，只不过我后来堕落了，不过，那又怎么样呢，我还是神一般的存在。</p>\n<p>或许你们当中有很多人非常非常地恨我，但是我说的这些人都差不多死的死，跑的跑，比方说伊利丹，阿尔萨斯，古尔丹？可是又但是，即使是他们与我也没有什么直接的关系。我只是一个被你们称为“万恶的源头”罢了。这里我说的恨我的人是指你们这些凡人们，是你们这些还在论坛上争吵到底用点卡还是用分钟数来玩游戏的准备杀我的玩家们。</p>\n<p>我并不觉得你们应该恨我，没有我，你们在艾泽拉斯也没有那么多的事可以做，我说的对不对呢？话说我来这里已经几个世纪了，换算成你们人类的时间应该是十几年，在这期间我从来没有出现在你们面前，事实上我真的是个神的存在，神总是孤独的。</p>\n<p>哦，对了，我堕落的最开始，也是因为孤独。我玩你们地球人的微博，在上面看到一句称做“鸡汤”的话，说什么优秀的人成功之前都必须有一个孤独的过程。我尼玛活的够长了，头回听到这么扯淡的话。老子就是因为太孤独了，最后闲的蛋疼才打算干坏事的。所以说这话的以及觉得这话挺对的，还是给自己找点事干吧，学我，干坏事也比憋着强啊。憋死你个龟孙儿！</p>\n<p>其实我本来不打算干那些伤天害理的事，只是阿曼苏尔那老头整天在我面前BB，烦的不行。后来还他**的给我派来个小弟监视我（唉呀，我又说脏话了，自己屏蔽成星），实在是让人不能忍，我一气之下，就把那小子给砍了，就当着那群二货神们的面。当时那画面的确有点血腥，反正我是闭眼了，主要我怕把血溅眼睛里。</p>\n<p>老头一看可吓坏了，叫帮手准备弄我。还好哥是练过的，一下把他们全干死了，不过我还是给他们留了灵魂，他们当时还以为我不知道。共事一场，哥也不是那种把事做绝的人，对吧。他们就整天用无线脑电波跟他们那些小弟联络，但是据说信号也不怎么好，主要还是因为官方的东西当时建的时候好多都是豆腐渣，现在轮到他们自己用了，活该信号不好。</p>\n<p>接下来，你们都知道啦。哥有了山头，也招了一批小弟，在宇宙里开始实行哥的“三光政策”。当了老大才知道，小弟也不是那么好管的，这群小弟猛是猛，不过都是楞头青，一点脑子都没有，沟通简直是太废劲。你想啊，我一个神，跟一堆**（这里的星星你们自己补）没法说话，代沟啊！</p>\n<p>我于是就在一个阿古斯的地方找了一群高级的天外种族，这个种族的人可足够聪明，有什么高科技之类的玩意，你们人类现在的科技估计在他们那连小儿科都算不上。那个种族叫什么艾瑞达，长相也比较好看，被我稍加改造，长的足够像坏人。<br>然后我就开始给他们讲经嘛，你想啊，统治什么的，需要靠的是脑子，要深入人心。你们人类历史上不是用宗教来统治国家嘛，这都一个道理，改天我得收你们版权费。</p>\n<p>这艾瑞达种族里有三个头，一个叫基尔加丹，一个叫阿克蒙德，还有一个是维仑。刚开始他们反正都挺崇拜哥的，而且有一些理念小基和小阿还跟我的观点很契合，就那个叫维仑的，总以为我是在忽悠他们。靠，哥是那种人么，要不是看你们聪明，不废话早干你们了。我总觉得这家伙鸡贼，不过他倒也没怎么跟我发生正面冲突，我也就没找他茬儿。</p>\n<p>最后这家伙还是带着一群人跑了，据说还联系上了纳鲁什么的。我也不知道那个鲁是什么玩意，估计也是有点小本事，自己封个神就出来招摇撞骗了。跑就跑呗，哥也不差你这一个，哥还有更重要事呢！</p>\n<p>好在小基和小阿都挺给力，我就给他们的名字加了点前缀，听起来具霸气：欺诈者基尔加丹，污染者阿克蒙德。我教给他们了一些法术，就让他们替我做事去了。这两个家伙挺厉害，把我那堆小弟整的服服贴贴的，而且小基还给我又招来了更多新的种群，总的来说，哥还是相当满意的。</p>\n<p>维仑那个家伙么，坐着纳鲁给他的飞船跑河外星系了，还挺文艺的给自己起名“德兰尼”（意思就是流亡者），那就让你们王八。反正我是不会亲自动手的，伤手（立白广告商加钱啊）。哥巧妙的利用了维仑和小基的嫌隙，因为我觉得这两个小伙有基情。管他呢，我可没有那么八卦，反正小基是气的不行，满世界的找维仑，说一定要追到天涯海角。听的我菊花一紧，一定有基情！</p>\n<p>后来呢，我听说阿曼苏尔老头找到了一个我的兄弟，叫艾泽拉斯，就是你们现在住的地方。而且这个兄弟貌似比哥还厉害，我独孤求败怎么能不找他呢，后来就找啊找，找啊找，找到一个好朋友…….</p>\n<p>再然后呢，唉呀，哥笔记本没电了呢，不是说你们地球人这东西质量就是不行，我得找个小弟给我冲冲电。今天就写到这吧，估计有错别字，也不带查了。</p>\n<p>记得去艾泽拉斯做日常哦。不来哥连你也弄。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-10d2a560272a60a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图文无关\"></p>","more":"<p>所有艾泽拉斯的原驻及非原驻渣子们，我是你们的神（这个时候，我是不是该有一句台词“I’m the King!”）。这个称呼对我来说是再合适不过了，因为我本来就是这个世界的神，只不过我后来堕落了，不过，那又怎么样呢，我还是神一般的存在。</p>\n<p>或许你们当中有很多人非常非常地恨我，但是我说的这些人都差不多死的死，跑的跑，比方说伊利丹，阿尔萨斯，古尔丹？可是又但是，即使是他们与我也没有什么直接的关系。我只是一个被你们称为“万恶的源头”罢了。这里我说的恨我的人是指你们这些凡人们，是你们这些还在论坛上争吵到底用点卡还是用分钟数来玩游戏的准备杀我的玩家们。</p>\n<p>我并不觉得你们应该恨我，没有我，你们在艾泽拉斯也没有那么多的事可以做，我说的对不对呢？话说我来这里已经几个世纪了，换算成你们人类的时间应该是十几年，在这期间我从来没有出现在你们面前，事实上我真的是个神的存在，神总是孤独的。</p>\n<p>哦，对了，我堕落的最开始，也是因为孤独。我玩你们地球人的微博，在上面看到一句称做“鸡汤”的话，说什么优秀的人成功之前都必须有一个孤独的过程。我尼玛活的够长了，头回听到这么扯淡的话。老子就是因为太孤独了，最后闲的蛋疼才打算干坏事的。所以说这话的以及觉得这话挺对的，还是给自己找点事干吧，学我，干坏事也比憋着强啊。憋死你个龟孙儿！</p>\n<p>其实我本来不打算干那些伤天害理的事，只是阿曼苏尔那老头整天在我面前BB，烦的不行。后来还他**的给我派来个小弟监视我（唉呀，我又说脏话了，自己屏蔽成星），实在是让人不能忍，我一气之下，就把那小子给砍了，就当着那群二货神们的面。当时那画面的确有点血腥，反正我是闭眼了，主要我怕把血溅眼睛里。</p>\n<p>老头一看可吓坏了，叫帮手准备弄我。还好哥是练过的，一下把他们全干死了，不过我还是给他们留了灵魂，他们当时还以为我不知道。共事一场，哥也不是那种把事做绝的人，对吧。他们就整天用无线脑电波跟他们那些小弟联络，但是据说信号也不怎么好，主要还是因为官方的东西当时建的时候好多都是豆腐渣，现在轮到他们自己用了，活该信号不好。</p>\n<p>接下来，你们都知道啦。哥有了山头，也招了一批小弟，在宇宙里开始实行哥的“三光政策”。当了老大才知道，小弟也不是那么好管的，这群小弟猛是猛，不过都是楞头青，一点脑子都没有，沟通简直是太废劲。你想啊，我一个神，跟一堆**（这里的星星你们自己补）没法说话，代沟啊！</p>\n<p>我于是就在一个阿古斯的地方找了一群高级的天外种族，这个种族的人可足够聪明，有什么高科技之类的玩意，你们人类现在的科技估计在他们那连小儿科都算不上。那个种族叫什么艾瑞达，长相也比较好看，被我稍加改造，长的足够像坏人。<br>然后我就开始给他们讲经嘛，你想啊，统治什么的，需要靠的是脑子，要深入人心。你们人类历史上不是用宗教来统治国家嘛，这都一个道理，改天我得收你们版权费。</p>\n<p>这艾瑞达种族里有三个头，一个叫基尔加丹，一个叫阿克蒙德，还有一个是维仑。刚开始他们反正都挺崇拜哥的，而且有一些理念小基和小阿还跟我的观点很契合，就那个叫维仑的，总以为我是在忽悠他们。靠，哥是那种人么，要不是看你们聪明，不废话早干你们了。我总觉得这家伙鸡贼，不过他倒也没怎么跟我发生正面冲突，我也就没找他茬儿。</p>\n<p>最后这家伙还是带着一群人跑了，据说还联系上了纳鲁什么的。我也不知道那个鲁是什么玩意，估计也是有点小本事，自己封个神就出来招摇撞骗了。跑就跑呗，哥也不差你这一个，哥还有更重要事呢！</p>\n<p>好在小基和小阿都挺给力，我就给他们的名字加了点前缀，听起来具霸气：欺诈者基尔加丹，污染者阿克蒙德。我教给他们了一些法术，就让他们替我做事去了。这两个家伙挺厉害，把我那堆小弟整的服服贴贴的，而且小基还给我又招来了更多新的种群，总的来说，哥还是相当满意的。</p>\n<p>维仑那个家伙么，坐着纳鲁给他的飞船跑河外星系了，还挺文艺的给自己起名“德兰尼”（意思就是流亡者），那就让你们王八。反正我是不会亲自动手的，伤手（立白广告商加钱啊）。哥巧妙的利用了维仑和小基的嫌隙，因为我觉得这两个小伙有基情。管他呢，我可没有那么八卦，反正小基是气的不行，满世界的找维仑，说一定要追到天涯海角。听的我菊花一紧，一定有基情！</p>\n<p>后来呢，我听说阿曼苏尔老头找到了一个我的兄弟，叫艾泽拉斯，就是你们现在住的地方。而且这个兄弟貌似比哥还厉害，我独孤求败怎么能不找他呢，后来就找啊找，找啊找，找到一个好朋友…….</p>\n<p>再然后呢，唉呀，哥笔记本没电了呢，不是说你们地球人这东西质量就是不行，我得找个小弟给我冲冲电。今天就写到这吧，估计有错别字，也不带查了。</p>\n<p>记得去艾泽拉斯做日常哦。不来哥连你也弄。</p>"},{"title":"本行三件事：猎龙 训龙 调教龙","date":"2018-04-27T12:45:00.000Z","_content":"大家好，我是花木兰。\n<!-- more -->\n\n## 第一件\n\n今天在**Nothing**项目中添加了一个小的功能，就是按压屏幕出现一个有弹出效果的*Label*，涉及到的点；\n\n1. thereis\n\n* touches\n\n我们知道，UIResponder处理函数，根据不同的触摸状态会调用不同的函数，以下：\n```\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n\n-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n\n-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n\n-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;\n```\n注意第四个取消函数，调用时机是触摸被取消，一定要注意是被取消，自己主动点击然后结束这不叫取消，举个例子如在触摸过程中被来电打断，这种情况才算；\n回调中可以通过*UITouch*来操作点击次数和手指数，*UIEvent*可以操作屏幕点信息，这样就把手指与屏幕的交互处理完成。\n* transform\n这里出现了一个现象，原代码如下：\n```\n//进入时的设置\n        //向x y轴方向平移 0 0\n        self.transform = CGAffineTransform(translationX: 0, y: 0) //(1)\n        self.transform = CGAffineTransform(rotationAngle: 0) // (2)\n        \n        self.transform = CGAffineTransform(scaleX: 0.1, y: 0.1) //(3)\n        //transform scale 改变中间不能添加其他变换\n        //动画播放\n        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {\n            self.transform = CGAffineTransform(scaleX: 1, y: 1)\n        }, completion: nil) //(4)\n```\n如上代码*(2)*如果放在*(3)*和*(4)*的中间，则动画会不执行，直接形成动画后的结果，天知道这其中发生了什么，怕是动画函数做了某些优化，如果你知道，还请赐教。\n* Another Problem\n```\nUIView.animate(withDuration: 1, delay: 0, \nusingSpringWithDamping: 0.5, \ninitialSpringVelocity: 0.5, options: .curveEaseIn, animations: {\n           self.transform = CGAffineTransform(scaleX: 1, y: 1)\n}, completion: nil)\n// 抗阻尼 以及 弹簧 的问题\n// 涉及到了一些物理知识，不细究\n// 只是贴出这个api 注意用法\n```\n\n2.  仿射变换\n\n[仿射空间和仿射变换](http://www.fuzihao.org/blog/2014/10/23/%E4%BB%BF%E5%B0%84%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/)\n关于仿射变换的先看这篇文章了解一下吧，它是计算机图形学中一个很重要的概念，简单的理解就是线性变换加上平移变换，当然看到这里你得先知道什么是线性变换和平移变换，好了，这个概念先不多说了。\n\n\n3. currying function\n\n经过了一系列的实验，最终得出了一个函数链的方案，虽然跟柯里化没有什么关系，代码如下，细细品味一下：\n```\npublic func maybe(noDate: NODate, _ some: () -> ()) -> ThereIs {\n        switch noDate {\n        case let .April(date):\n            let myDate = date.toDate()\n            let currentDate = Date()\n            if let myDate = myDate {\n                if myDate.compare(currentDate) == .orderedSame {\n                    some()\n                }\n            }\n        }\n        return self\n    }\n```\n其实也没有多么深奥，只是函数在调用外部传进的闭包后又返回了自身，然而，就是一个这样简单的设计，在调用时你会发现是多么的便利；\n```\n_ = thereis?.maybe(noDate: dates[0]) {\n                self.noLabel.appear()\n            }\n            .maybe(noDate: dates[1]) {\n                \n            }\n```\n上图中的*maybe*函数可以无限调用，这样根据传进来的参数可以实现一个小功能，如果将本方法的类似方法分散在不同的函数中调用，那么我们可以用传进不同参数来区分调用的时机，这样可以将某一次的逻辑调用统一在一个地方处理，说的有点绕，用一张图来理一下思路：\n![maybe函数思维导图](https://upload-images.jianshu.io/upload_images/1429775-e58a9faeb3c885d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 第二件\n此时我面前有一个作业，叫做文献综述，今天跟老铁聊天中发现自己在面对困难问题时拖延的问题。朋友说当你有一大堆的事情不知道做哪件时，挑最难的那件事情做。\n于是把每天最棘手的问题做为首要，比方说难做的作业，比方说写一篇文章。\n![轻课听力](http://upload-images.jianshu.io/upload_images/1429775-1aea7d4c63680f89.jpg)\n上图是昨晚在轻课群的口语练习，留作复习用。\n\n\n## 第三件\n已经很久没有写日志了，这么些年断断续续的，从来没把它当作一个习惯来做。在github上看到一个学习库，有所启发，想来该培养一个习惯来让自己保持一个学习的状态。完成的并不一定要完美，完成就好，记录下心情，记录下问题，记录下昨天那个“愚蠢”的自己。","source":"_posts/本行三件事：猎龙 训龙 调教龙.md","raw":"title: 本行三件事：猎龙 训龙 调教龙\ndate: 2018-04-27 20:45:00\ncategories: coder\ntags: [iOS, paradigm]\n-----------\n大家好，我是花木兰。\n<!-- more -->\n\n## 第一件\n\n今天在**Nothing**项目中添加了一个小的功能，就是按压屏幕出现一个有弹出效果的*Label*，涉及到的点；\n\n1. thereis\n\n* touches\n\n我们知道，UIResponder处理函数，根据不同的触摸状态会调用不同的函数，以下：\n```\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n\n-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n\n-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n\n-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;\n```\n注意第四个取消函数，调用时机是触摸被取消，一定要注意是被取消，自己主动点击然后结束这不叫取消，举个例子如在触摸过程中被来电打断，这种情况才算；\n回调中可以通过*UITouch*来操作点击次数和手指数，*UIEvent*可以操作屏幕点信息，这样就把手指与屏幕的交互处理完成。\n* transform\n这里出现了一个现象，原代码如下：\n```\n//进入时的设置\n        //向x y轴方向平移 0 0\n        self.transform = CGAffineTransform(translationX: 0, y: 0) //(1)\n        self.transform = CGAffineTransform(rotationAngle: 0) // (2)\n        \n        self.transform = CGAffineTransform(scaleX: 0.1, y: 0.1) //(3)\n        //transform scale 改变中间不能添加其他变换\n        //动画播放\n        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {\n            self.transform = CGAffineTransform(scaleX: 1, y: 1)\n        }, completion: nil) //(4)\n```\n如上代码*(2)*如果放在*(3)*和*(4)*的中间，则动画会不执行，直接形成动画后的结果，天知道这其中发生了什么，怕是动画函数做了某些优化，如果你知道，还请赐教。\n* Another Problem\n```\nUIView.animate(withDuration: 1, delay: 0, \nusingSpringWithDamping: 0.5, \ninitialSpringVelocity: 0.5, options: .curveEaseIn, animations: {\n           self.transform = CGAffineTransform(scaleX: 1, y: 1)\n}, completion: nil)\n// 抗阻尼 以及 弹簧 的问题\n// 涉及到了一些物理知识，不细究\n// 只是贴出这个api 注意用法\n```\n\n2.  仿射变换\n\n[仿射空间和仿射变换](http://www.fuzihao.org/blog/2014/10/23/%E4%BB%BF%E5%B0%84%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/)\n关于仿射变换的先看这篇文章了解一下吧，它是计算机图形学中一个很重要的概念，简单的理解就是线性变换加上平移变换，当然看到这里你得先知道什么是线性变换和平移变换，好了，这个概念先不多说了。\n\n\n3. currying function\n\n经过了一系列的实验，最终得出了一个函数链的方案，虽然跟柯里化没有什么关系，代码如下，细细品味一下：\n```\npublic func maybe(noDate: NODate, _ some: () -> ()) -> ThereIs {\n        switch noDate {\n        case let .April(date):\n            let myDate = date.toDate()\n            let currentDate = Date()\n            if let myDate = myDate {\n                if myDate.compare(currentDate) == .orderedSame {\n                    some()\n                }\n            }\n        }\n        return self\n    }\n```\n其实也没有多么深奥，只是函数在调用外部传进的闭包后又返回了自身，然而，就是一个这样简单的设计，在调用时你会发现是多么的便利；\n```\n_ = thereis?.maybe(noDate: dates[0]) {\n                self.noLabel.appear()\n            }\n            .maybe(noDate: dates[1]) {\n                \n            }\n```\n上图中的*maybe*函数可以无限调用，这样根据传进来的参数可以实现一个小功能，如果将本方法的类似方法分散在不同的函数中调用，那么我们可以用传进不同参数来区分调用的时机，这样可以将某一次的逻辑调用统一在一个地方处理，说的有点绕，用一张图来理一下思路：\n![maybe函数思维导图](https://upload-images.jianshu.io/upload_images/1429775-e58a9faeb3c885d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 第二件\n此时我面前有一个作业，叫做文献综述，今天跟老铁聊天中发现自己在面对困难问题时拖延的问题。朋友说当你有一大堆的事情不知道做哪件时，挑最难的那件事情做。\n于是把每天最棘手的问题做为首要，比方说难做的作业，比方说写一篇文章。\n![轻课听力](http://upload-images.jianshu.io/upload_images/1429775-1aea7d4c63680f89.jpg)\n上图是昨晚在轻课群的口语练习，留作复习用。\n\n\n## 第三件\n已经很久没有写日志了，这么些年断断续续的，从来没把它当作一个习惯来做。在github上看到一个学习库，有所启发，想来该培养一个习惯来让自己保持一个学习的状态。完成的并不一定要完美，完成就好，记录下心情，记录下问题，记录下昨天那个“愚蠢”的自己。","slug":"本行三件事：猎龙 训龙 调教龙","published":1,"updated":"2018-05-04T08:49:00.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucip1002k1v60vt77f9si","content":"<p>大家好，我是花木兰。<br><a id=\"more\"></a></p>\n<h2 id=\"第一件\"><a href=\"#第一件\" class=\"headerlink\" title=\"第一件\"></a>第一件</h2><p>今天在<strong>Nothing</strong>项目中添加了一个小的功能，就是按压屏幕出现一个有弹出效果的<em>Label</em>，涉及到的点；</p>\n<ol>\n<li>thereis</li>\n</ol>\n<ul>\n<li>touches</li>\n</ul>\n<p>我们知道，UIResponder处理函数，根据不同的触摸状态会调用不同的函数，以下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure></p>\n<p>注意第四个取消函数，调用时机是触摸被取消，一定要注意是被取消，自己主动点击然后结束这不叫取消，举个例子如在触摸过程中被来电打断，这种情况才算；<br>回调中可以通过<em>UITouch</em>来操作点击次数和手指数，<em>UIEvent</em>可以操作屏幕点信息，这样就把手指与屏幕的交互处理完成。</p>\n<ul>\n<li>transform<br>这里出现了一个现象，原代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//进入时的设置</span><br><span class=\"line\">        //向x y轴方向平移 0 0</span><br><span class=\"line\">        self.transform = CGAffineTransform(translationX: 0, y: 0) //(1)</span><br><span class=\"line\">        self.transform = CGAffineTransform(rotationAngle: 0) // (2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.transform = CGAffineTransform(scaleX: 0.1, y: 0.1) //(3)</span><br><span class=\"line\">        //transform scale 改变中间不能添加其他变换</span><br><span class=\"line\">        //动画播放</span><br><span class=\"line\">        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: &#123;</span><br><span class=\"line\">            self.transform = CGAffineTransform(scaleX: 1, y: 1)</span><br><span class=\"line\">        &#125;, completion: nil) //(4)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上代码<em>(2)</em>如果放在<em>(3)</em>和<em>(4)</em>的中间，则动画会不执行，直接形成动画后的结果，天知道这其中发生了什么，怕是动画函数做了某些优化，如果你知道，还请赐教。</p>\n<ul>\n<li>Another Problem<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView.animate(withDuration: 1, delay: 0, </span><br><span class=\"line\">usingSpringWithDamping: 0.5, </span><br><span class=\"line\">initialSpringVelocity: 0.5, options: .curveEaseIn, animations: &#123;</span><br><span class=\"line\">           self.transform = CGAffineTransform(scaleX: 1, y: 1)</span><br><span class=\"line\">&#125;, completion: nil)</span><br><span class=\"line\">// 抗阻尼 以及 弹簧 的问题</span><br><span class=\"line\">// 涉及到了一些物理知识，不细究</span><br><span class=\"line\">// 只是贴出这个api 注意用法</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>仿射变换</li>\n</ol>\n<p><a href=\"http://www.fuzihao.org/blog/2014/10/23/%E4%BB%BF%E5%B0%84%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/\" target=\"_blank\" rel=\"noopener\">仿射空间和仿射变换</a><br>关于仿射变换的先看这篇文章了解一下吧，它是计算机图形学中一个很重要的概念，简单的理解就是线性变换加上平移变换，当然看到这里你得先知道什么是线性变换和平移变换，好了，这个概念先不多说了。</p>\n<ol start=\"3\">\n<li>currying function</li>\n</ol>\n<p>经过了一系列的实验，最终得出了一个函数链的方案，虽然跟柯里化没有什么关系，代码如下，细细品味一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func maybe(noDate: NODate, _ some: () -&gt; ()) -&gt; ThereIs &#123;</span><br><span class=\"line\">        switch noDate &#123;</span><br><span class=\"line\">        case let .April(date):</span><br><span class=\"line\">            let myDate = date.toDate()</span><br><span class=\"line\">            let currentDate = Date()</span><br><span class=\"line\">            if let myDate = myDate &#123;</span><br><span class=\"line\">                if myDate.compare(currentDate) == .orderedSame &#123;</span><br><span class=\"line\">                    some()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return self</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实也没有多么深奥，只是函数在调用外部传进的闭包后又返回了自身，然而，就是一个这样简单的设计，在调用时你会发现是多么的便利；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ = thereis?.maybe(noDate: dates[0]) &#123;</span><br><span class=\"line\">                self.noLabel.appear()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            .maybe(noDate: dates[1]) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上图中的<em>maybe</em>函数可以无限调用，这样根据传进来的参数可以实现一个小功能，如果将本方法的类似方法分散在不同的函数中调用，那么我们可以用传进不同参数来区分调用的时机，这样可以将某一次的逻辑调用统一在一个地方处理，说的有点绕，用一张图来理一下思路：<br><img src=\"https://upload-images.jianshu.io/upload_images/1429775-e58a9faeb3c885d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"maybe函数思维导图\"></p>\n<h2 id=\"第二件\"><a href=\"#第二件\" class=\"headerlink\" title=\"第二件\"></a>第二件</h2><p>此时我面前有一个作业，叫做文献综述，今天跟老铁聊天中发现自己在面对困难问题时拖延的问题。朋友说当你有一大堆的事情不知道做哪件时，挑最难的那件事情做。<br>于是把每天最棘手的问题做为首要，比方说难做的作业，比方说写一篇文章。<br><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1aea7d4c63680f89.jpg\" alt=\"轻课听力\"><br>上图是昨晚在轻课群的口语练习，留作复习用。</p>\n<h2 id=\"第三件\"><a href=\"#第三件\" class=\"headerlink\" title=\"第三件\"></a>第三件</h2><p>已经很久没有写日志了，这么些年断断续续的，从来没把它当作一个习惯来做。在github上看到一个学习库，有所启发，想来该培养一个习惯来让自己保持一个学习的状态。完成的并不一定要完美，完成就好，记录下心情，记录下问题，记录下昨天那个“愚蠢”的自己。</p>\n","site":{"data":{}},"excerpt":"<p>大家好，我是花木兰。<br>","more":"</p>\n<h2 id=\"第一件\"><a href=\"#第一件\" class=\"headerlink\" title=\"第一件\"></a>第一件</h2><p>今天在<strong>Nothing</strong>项目中添加了一个小的功能，就是按压屏幕出现一个有弹出效果的<em>Label</em>，涉及到的点；</p>\n<ol>\n<li>thereis</li>\n</ol>\n<ul>\n<li>touches</li>\n</ul>\n<p>我们知道，UIResponder处理函数，根据不同的触摸状态会调用不同的函数，以下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure></p>\n<p>注意第四个取消函数，调用时机是触摸被取消，一定要注意是被取消，自己主动点击然后结束这不叫取消，举个例子如在触摸过程中被来电打断，这种情况才算；<br>回调中可以通过<em>UITouch</em>来操作点击次数和手指数，<em>UIEvent</em>可以操作屏幕点信息，这样就把手指与屏幕的交互处理完成。</p>\n<ul>\n<li>transform<br>这里出现了一个现象，原代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//进入时的设置</span><br><span class=\"line\">        //向x y轴方向平移 0 0</span><br><span class=\"line\">        self.transform = CGAffineTransform(translationX: 0, y: 0) //(1)</span><br><span class=\"line\">        self.transform = CGAffineTransform(rotationAngle: 0) // (2)</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.transform = CGAffineTransform(scaleX: 0.1, y: 0.1) //(3)</span><br><span class=\"line\">        //transform scale 改变中间不能添加其他变换</span><br><span class=\"line\">        //动画播放</span><br><span class=\"line\">        UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: &#123;</span><br><span class=\"line\">            self.transform = CGAffineTransform(scaleX: 1, y: 1)</span><br><span class=\"line\">        &#125;, completion: nil) //(4)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上代码<em>(2)</em>如果放在<em>(3)</em>和<em>(4)</em>的中间，则动画会不执行，直接形成动画后的结果，天知道这其中发生了什么，怕是动画函数做了某些优化，如果你知道，还请赐教。</p>\n<ul>\n<li>Another Problem<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIView.animate(withDuration: 1, delay: 0, </span><br><span class=\"line\">usingSpringWithDamping: 0.5, </span><br><span class=\"line\">initialSpringVelocity: 0.5, options: .curveEaseIn, animations: &#123;</span><br><span class=\"line\">           self.transform = CGAffineTransform(scaleX: 1, y: 1)</span><br><span class=\"line\">&#125;, completion: nil)</span><br><span class=\"line\">// 抗阻尼 以及 弹簧 的问题</span><br><span class=\"line\">// 涉及到了一些物理知识，不细究</span><br><span class=\"line\">// 只是贴出这个api 注意用法</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li>仿射变换</li>\n</ol>\n<p><a href=\"http://www.fuzihao.org/blog/2014/10/23/%E4%BB%BF%E5%B0%84%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/\" target=\"_blank\" rel=\"noopener\">仿射空间和仿射变换</a><br>关于仿射变换的先看这篇文章了解一下吧，它是计算机图形学中一个很重要的概念，简单的理解就是线性变换加上平移变换，当然看到这里你得先知道什么是线性变换和平移变换，好了，这个概念先不多说了。</p>\n<ol start=\"3\">\n<li>currying function</li>\n</ol>\n<p>经过了一系列的实验，最终得出了一个函数链的方案，虽然跟柯里化没有什么关系，代码如下，细细品味一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func maybe(noDate: NODate, _ some: () -&gt; ()) -&gt; ThereIs &#123;</span><br><span class=\"line\">        switch noDate &#123;</span><br><span class=\"line\">        case let .April(date):</span><br><span class=\"line\">            let myDate = date.toDate()</span><br><span class=\"line\">            let currentDate = Date()</span><br><span class=\"line\">            if let myDate = myDate &#123;</span><br><span class=\"line\">                if myDate.compare(currentDate) == .orderedSame &#123;</span><br><span class=\"line\">                    some()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return self</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实也没有多么深奥，只是函数在调用外部传进的闭包后又返回了自身，然而，就是一个这样简单的设计，在调用时你会发现是多么的便利；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ = thereis?.maybe(noDate: dates[0]) &#123;</span><br><span class=\"line\">                self.noLabel.appear()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            .maybe(noDate: dates[1]) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上图中的<em>maybe</em>函数可以无限调用，这样根据传进来的参数可以实现一个小功能，如果将本方法的类似方法分散在不同的函数中调用，那么我们可以用传进不同参数来区分调用的时机，这样可以将某一次的逻辑调用统一在一个地方处理，说的有点绕，用一张图来理一下思路：<br><img src=\"https://upload-images.jianshu.io/upload_images/1429775-e58a9faeb3c885d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"maybe函数思维导图\"></p>\n<h2 id=\"第二件\"><a href=\"#第二件\" class=\"headerlink\" title=\"第二件\"></a>第二件</h2><p>此时我面前有一个作业，叫做文献综述，今天跟老铁聊天中发现自己在面对困难问题时拖延的问题。朋友说当你有一大堆的事情不知道做哪件时，挑最难的那件事情做。<br>于是把每天最棘手的问题做为首要，比方说难做的作业，比方说写一篇文章。<br><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1aea7d4c63680f89.jpg\" alt=\"轻课听力\"><br>上图是昨晚在轻课群的口语练习，留作复习用。</p>\n<h2 id=\"第三件\"><a href=\"#第三件\" class=\"headerlink\" title=\"第三件\"></a>第三件</h2><p>已经很久没有写日志了，这么些年断断续续的，从来没把它当作一个习惯来做。在github上看到一个学习库，有所启发，想来该培养一个习惯来让自己保持一个学习的状态。完成的并不一定要完美，完成就好，记录下心情，记录下问题，记录下昨天那个“愚蠢”的自己。</p>"},{"title":"艾泽拉斯上古探秘","date":"2016-08-12T01:16:00.000Z","_content":"\n了解魔兽世界的朋友一定不会对“艾泽拉斯”陌生，这个一度让我们魂牵梦绕的地方，魔兽文化的发详地。本篇我们就来了解下它的诞生以及在其上的早期生物。\n\n![众神造访艾泽拉斯](http://upload-images.jianshu.io/upload_images/1429775-770ff650ffd24fe3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n我在看魔兽编年史的过程中，第一个让我感到意外的就是艾泽拉斯（以下称作小艾）的身世。首先是它一个泰坦的身份就足以让人诧异（泰坦跟跟地球有什么联系？）；第二是它的畸形，萨格拉斯才算是异类好嘛，小艾顶多算一个别人家的孩子，不过别人家的孩子受人妒忌；第三，同样是泰坦，为什么萨格拉斯就能到处活动，而艾泽拉斯却是一个没有什么存在感的地名（我觉得魔兽最后应该让小艾活，不过这样魔兽世界也就没什么可写了）。\n \n因为刚生下来就天赋异禀，使得这位初生小泰坦遭遇了各种不幸。所谓树大招风，才大受虐，定义了这个世界不变的原则之一（天妒英才也要在魔兽里体现一下吗）。\n\n首先是在它身上自然繁衍的元素横行，这些元素包括：火、水、土、风以及来自它身体周围的第五元素——星魂（这让我想起了《第五元素》这部电影，是时候可以复习下）。各元素自有它们各自的首领。风神奥拉基尔，擅长煽风点火，善使计谋，这个家伙是魔兽多人副本风神王座的终BOSS；炎魔拉格纳罗斯性情暴躁，蛮力十足，魔兽火焰之地终BOSS；石母瑟拉赞恩，与地为阵，跟石头有关的东西它能利用为武器；猎潮者耐普图隆是几位元素领主中最为奸滑者，用兵巧妙;小五嘛暂时在这还没有什么作为。前四股势力在小艾身上不断地发生征战，我们称它们为元素F4团，它们连年混战，全然不顾泰坦妈妈的感受。\n\n![元素F4团](http://upload-images.jianshu.io/upload_images/1429775-5b36eacc89efa6c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然像小艾这样强大的能量，我们的宇宙恐怖组织怎能不觊觎？首先是黑暗恐怖组织上古之神在小艾身上建立据点，并且开始进行实地探测。既而两大种族相继出生，一为恩剌基（听着怎么像“嗯垃圾”），又名“无面者”；二为亚基虫族。这些生物的形态也许在卡利姆多安其拉神殿可以找到，回头上线的时候我得专门去找一下，之后我会帖图进来。这里我们继续讲故事。\n\n![恩垃圾和亚基虫](http://upload-images.jianshu.io/upload_images/1429775-a266a623c373165e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n虽然元素领主们之间的战争历时弥久，但是毕竟在艾泽拉斯这片土地上他们还是主人，岂容你外来个什么恐怖组织造次。于是小F4签订停战协定，一致公开对外。不过即使是联合貌似也并无甚卵用，这恐怖组织绝非等闲之辈。一战即开，F4团全数被缚。垃圾和亚基将他们送给上古大神们，继而主人变为奴隶，跟着外来大大们一起开始混社会了。  \n     \n小艾的出生同时也牵动着整个神届，萨格拉斯的徒弟阿格拉玛首先找到了它。刚好上古大大正给小艾也喂黑奶，跟之前小萨碰上的情况一模一样。小阿一看也挺害怕，不过他可不如小萨那么有魄力直接就给小孩干死，他赶紧把情况报告给了神届。神届于是展开了讨论，最后决定创造一支大军来抵抗黑暗力量的腐蚀。\n\n![天神团成员](http://upload-images.jianshu.io/upload_images/1429775-e8e2a31cd640ae19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这张图片就是我们的天神团，左上是阿曼苏尔，阿格拉斯就是右边拿长剑的，这是他还没有堕落时的寸照，比较帅，堕落之后走的是狂野风。下面是一张对比图。\n\n![小萨堕落前后对比图](http://upload-images.jianshu.io/upload_images/1429775-97c270d6a31ec941.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n 由锻铸神卡兹格罗斯创造的艾瑟耶尔和瓦尼尔形成，他们是第一批泰坦造物。各路神仙也各展神通，基于他们自己的形貌和力量制造出了守护者，并将他们全部派遣到了艾泽拉斯，完成清剿任务。     \n  \n这里我们认识一些新的人物，对应神届各路众神以及艾泽拉斯守护者（艾泽拉斯众神）。之后神届的神仙会经历一次灭鼎，而后的故事就都跟他们的守护者相关了。       \n\n我们的神父阿曼苏尔的继承者是大守护者莱和守护者奥丁，莱在后来的魔古一族的称覇中起着重要的作用。\n\n![莱和奥丁](http://upload-images.jianshu.io/upload_images/1429775-8f3238f2d8538011.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n锻造师及塑形者卡兹格罗斯的继承守护者是阿札达斯；\n天穹及啸海之王高甘纳斯将力量授予了守护者索林姆和守护者霍迪尔，前者常控风暴之力，后者掌控天穹之能；\n创生者伊欧娜（唯一一位女神吧）给予了守护者芙蕾娜自然的力量，让她可以动用动植物的力量；\n天外魔法诺甘农的继承者是守护者洛肯和米米隆，这两个人应该不陌生，副本奥杜尔中可以看到他们的身影，而后者掉落的坐骑恐怕是好多魔兽玩家都想拥有的；\n\n![索林姆（上左）、霍迪尔（上右）和米米隆](http://upload-images.jianshu.io/upload_images/1429775-74d2de96cbf30cf2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n阿格拉玛，我们的小阿的继承者是提尔，他是艾泽拉斯最为强大的战士，白银之手就出自于他。这样，守护者大军便就此形成，而精彩的故事才刚刚开始。       \n\n下篇我们会从艾泽拉斯最初的战争开始讲述，今天的故事就到这里吧，欢迎关注我的公众号哦。","source":"_posts/艾泽拉斯上古探秘.md","raw":"title: 艾泽拉斯上古探秘\ndate: 2016-08-12 09:16:00\ncategories: Azeroth\n-----------\n\n了解魔兽世界的朋友一定不会对“艾泽拉斯”陌生，这个一度让我们魂牵梦绕的地方，魔兽文化的发详地。本篇我们就来了解下它的诞生以及在其上的早期生物。\n\n![众神造访艾泽拉斯](http://upload-images.jianshu.io/upload_images/1429775-770ff650ffd24fe3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n我在看魔兽编年史的过程中，第一个让我感到意外的就是艾泽拉斯（以下称作小艾）的身世。首先是它一个泰坦的身份就足以让人诧异（泰坦跟跟地球有什么联系？）；第二是它的畸形，萨格拉斯才算是异类好嘛，小艾顶多算一个别人家的孩子，不过别人家的孩子受人妒忌；第三，同样是泰坦，为什么萨格拉斯就能到处活动，而艾泽拉斯却是一个没有什么存在感的地名（我觉得魔兽最后应该让小艾活，不过这样魔兽世界也就没什么可写了）。\n \n因为刚生下来就天赋异禀，使得这位初生小泰坦遭遇了各种不幸。所谓树大招风，才大受虐，定义了这个世界不变的原则之一（天妒英才也要在魔兽里体现一下吗）。\n\n首先是在它身上自然繁衍的元素横行，这些元素包括：火、水、土、风以及来自它身体周围的第五元素——星魂（这让我想起了《第五元素》这部电影，是时候可以复习下）。各元素自有它们各自的首领。风神奥拉基尔，擅长煽风点火，善使计谋，这个家伙是魔兽多人副本风神王座的终BOSS；炎魔拉格纳罗斯性情暴躁，蛮力十足，魔兽火焰之地终BOSS；石母瑟拉赞恩，与地为阵，跟石头有关的东西它能利用为武器；猎潮者耐普图隆是几位元素领主中最为奸滑者，用兵巧妙;小五嘛暂时在这还没有什么作为。前四股势力在小艾身上不断地发生征战，我们称它们为元素F4团，它们连年混战，全然不顾泰坦妈妈的感受。\n\n![元素F4团](http://upload-images.jianshu.io/upload_images/1429775-5b36eacc89efa6c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然像小艾这样强大的能量，我们的宇宙恐怖组织怎能不觊觎？首先是黑暗恐怖组织上古之神在小艾身上建立据点，并且开始进行实地探测。既而两大种族相继出生，一为恩剌基（听着怎么像“嗯垃圾”），又名“无面者”；二为亚基虫族。这些生物的形态也许在卡利姆多安其拉神殿可以找到，回头上线的时候我得专门去找一下，之后我会帖图进来。这里我们继续讲故事。\n\n![恩垃圾和亚基虫](http://upload-images.jianshu.io/upload_images/1429775-a266a623c373165e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n虽然元素领主们之间的战争历时弥久，但是毕竟在艾泽拉斯这片土地上他们还是主人，岂容你外来个什么恐怖组织造次。于是小F4签订停战协定，一致公开对外。不过即使是联合貌似也并无甚卵用，这恐怖组织绝非等闲之辈。一战即开，F4团全数被缚。垃圾和亚基将他们送给上古大神们，继而主人变为奴隶，跟着外来大大们一起开始混社会了。  \n     \n小艾的出生同时也牵动着整个神届，萨格拉斯的徒弟阿格拉玛首先找到了它。刚好上古大大正给小艾也喂黑奶，跟之前小萨碰上的情况一模一样。小阿一看也挺害怕，不过他可不如小萨那么有魄力直接就给小孩干死，他赶紧把情况报告给了神届。神届于是展开了讨论，最后决定创造一支大军来抵抗黑暗力量的腐蚀。\n\n![天神团成员](http://upload-images.jianshu.io/upload_images/1429775-e8e2a31cd640ae19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这张图片就是我们的天神团，左上是阿曼苏尔，阿格拉斯就是右边拿长剑的，这是他还没有堕落时的寸照，比较帅，堕落之后走的是狂野风。下面是一张对比图。\n\n![小萨堕落前后对比图](http://upload-images.jianshu.io/upload_images/1429775-97c270d6a31ec941.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n 由锻铸神卡兹格罗斯创造的艾瑟耶尔和瓦尼尔形成，他们是第一批泰坦造物。各路神仙也各展神通，基于他们自己的形貌和力量制造出了守护者，并将他们全部派遣到了艾泽拉斯，完成清剿任务。     \n  \n这里我们认识一些新的人物，对应神届各路众神以及艾泽拉斯守护者（艾泽拉斯众神）。之后神届的神仙会经历一次灭鼎，而后的故事就都跟他们的守护者相关了。       \n\n我们的神父阿曼苏尔的继承者是大守护者莱和守护者奥丁，莱在后来的魔古一族的称覇中起着重要的作用。\n\n![莱和奥丁](http://upload-images.jianshu.io/upload_images/1429775-8f3238f2d8538011.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n锻造师及塑形者卡兹格罗斯的继承守护者是阿札达斯；\n天穹及啸海之王高甘纳斯将力量授予了守护者索林姆和守护者霍迪尔，前者常控风暴之力，后者掌控天穹之能；\n创生者伊欧娜（唯一一位女神吧）给予了守护者芙蕾娜自然的力量，让她可以动用动植物的力量；\n天外魔法诺甘农的继承者是守护者洛肯和米米隆，这两个人应该不陌生，副本奥杜尔中可以看到他们的身影，而后者掉落的坐骑恐怕是好多魔兽玩家都想拥有的；\n\n![索林姆（上左）、霍迪尔（上右）和米米隆](http://upload-images.jianshu.io/upload_images/1429775-74d2de96cbf30cf2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n阿格拉玛，我们的小阿的继承者是提尔，他是艾泽拉斯最为强大的战士，白银之手就出自于他。这样，守护者大军便就此形成，而精彩的故事才刚刚开始。       \n\n下篇我们会从艾泽拉斯最初的战争开始讲述，今天的故事就到这里吧，欢迎关注我的公众号哦。","slug":"艾泽拉斯上古探秘","published":1,"updated":"2018-05-04T10:24:50.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucip3002n1v60mzb0osk9","content":"<p>了解魔兽世界的朋友一定不会对“艾泽拉斯”陌生，这个一度让我们魂牵梦绕的地方，魔兽文化的发详地。本篇我们就来了解下它的诞生以及在其上的早期生物。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-770ff650ffd24fe3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"众神造访艾泽拉斯\"></p>\n<a id=\"more\"></a>\n<p>我在看魔兽编年史的过程中，第一个让我感到意外的就是艾泽拉斯（以下称作小艾）的身世。首先是它一个泰坦的身份就足以让人诧异（泰坦跟跟地球有什么联系？）；第二是它的畸形，萨格拉斯才算是异类好嘛，小艾顶多算一个别人家的孩子，不过别人家的孩子受人妒忌；第三，同样是泰坦，为什么萨格拉斯就能到处活动，而艾泽拉斯却是一个没有什么存在感的地名（我觉得魔兽最后应该让小艾活，不过这样魔兽世界也就没什么可写了）。</p>\n<p>因为刚生下来就天赋异禀，使得这位初生小泰坦遭遇了各种不幸。所谓树大招风，才大受虐，定义了这个世界不变的原则之一（天妒英才也要在魔兽里体现一下吗）。</p>\n<p>首先是在它身上自然繁衍的元素横行，这些元素包括：火、水、土、风以及来自它身体周围的第五元素——星魂（这让我想起了《第五元素》这部电影，是时候可以复习下）。各元素自有它们各自的首领。风神奥拉基尔，擅长煽风点火，善使计谋，这个家伙是魔兽多人副本风神王座的终BOSS；炎魔拉格纳罗斯性情暴躁，蛮力十足，魔兽火焰之地终BOSS；石母瑟拉赞恩，与地为阵，跟石头有关的东西它能利用为武器；猎潮者耐普图隆是几位元素领主中最为奸滑者，用兵巧妙;小五嘛暂时在这还没有什么作为。前四股势力在小艾身上不断地发生征战，我们称它们为元素F4团，它们连年混战，全然不顾泰坦妈妈的感受。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5b36eacc89efa6c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元素F4团\"></p>\n<p>当然像小艾这样强大的能量，我们的宇宙恐怖组织怎能不觊觎？首先是黑暗恐怖组织上古之神在小艾身上建立据点，并且开始进行实地探测。既而两大种族相继出生，一为恩剌基（听着怎么像“嗯垃圾”），又名“无面者”；二为亚基虫族。这些生物的形态也许在卡利姆多安其拉神殿可以找到，回头上线的时候我得专门去找一下，之后我会帖图进来。这里我们继续讲故事。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-a266a623c373165e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恩垃圾和亚基虫\"></p>\n<p>虽然元素领主们之间的战争历时弥久，但是毕竟在艾泽拉斯这片土地上他们还是主人，岂容你外来个什么恐怖组织造次。于是小F4签订停战协定，一致公开对外。不过即使是联合貌似也并无甚卵用，这恐怖组织绝非等闲之辈。一战即开，F4团全数被缚。垃圾和亚基将他们送给上古大神们，继而主人变为奴隶，跟着外来大大们一起开始混社会了。  </p>\n<p>小艾的出生同时也牵动着整个神届，萨格拉斯的徒弟阿格拉玛首先找到了它。刚好上古大大正给小艾也喂黑奶，跟之前小萨碰上的情况一模一样。小阿一看也挺害怕，不过他可不如小萨那么有魄力直接就给小孩干死，他赶紧把情况报告给了神届。神届于是展开了讨论，最后决定创造一支大军来抵抗黑暗力量的腐蚀。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-e8e2a31cd640ae19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"天神团成员\"><br>这张图片就是我们的天神团，左上是阿曼苏尔，阿格拉斯就是右边拿长剑的，这是他还没有堕落时的寸照，比较帅，堕落之后走的是狂野风。下面是一张对比图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-97c270d6a31ec941.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"小萨堕落前后对比图\"></p>\n<p> 由锻铸神卡兹格罗斯创造的艾瑟耶尔和瓦尼尔形成，他们是第一批泰坦造物。各路神仙也各展神通，基于他们自己的形貌和力量制造出了守护者，并将他们全部派遣到了艾泽拉斯，完成清剿任务。     </p>\n<p>这里我们认识一些新的人物，对应神届各路众神以及艾泽拉斯守护者（艾泽拉斯众神）。之后神届的神仙会经历一次灭鼎，而后的故事就都跟他们的守护者相关了。       </p>\n<p>我们的神父阿曼苏尔的继承者是大守护者莱和守护者奥丁，莱在后来的魔古一族的称覇中起着重要的作用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-8f3238f2d8538011.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"莱和奥丁\"></p>\n<p>锻造师及塑形者卡兹格罗斯的继承守护者是阿札达斯；<br>天穹及啸海之王高甘纳斯将力量授予了守护者索林姆和守护者霍迪尔，前者常控风暴之力，后者掌控天穹之能；<br>创生者伊欧娜（唯一一位女神吧）给予了守护者芙蕾娜自然的力量，让她可以动用动植物的力量；<br>天外魔法诺甘农的继承者是守护者洛肯和米米隆，这两个人应该不陌生，副本奥杜尔中可以看到他们的身影，而后者掉落的坐骑恐怕是好多魔兽玩家都想拥有的；</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-74d2de96cbf30cf2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"索林姆（上左）、霍迪尔（上右）和米米隆\"></p>\n<p>阿格拉玛，我们的小阿的继承者是提尔，他是艾泽拉斯最为强大的战士，白银之手就出自于他。这样，守护者大军便就此形成，而精彩的故事才刚刚开始。       </p>\n<p>下篇我们会从艾泽拉斯最初的战争开始讲述，今天的故事就到这里吧，欢迎关注我的公众号哦。</p>\n","site":{"data":{}},"excerpt":"<p>了解魔兽世界的朋友一定不会对“艾泽拉斯”陌生，这个一度让我们魂牵梦绕的地方，魔兽文化的发详地。本篇我们就来了解下它的诞生以及在其上的早期生物。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-770ff650ffd24fe3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"众神造访艾泽拉斯\"></p>","more":"<p>我在看魔兽编年史的过程中，第一个让我感到意外的就是艾泽拉斯（以下称作小艾）的身世。首先是它一个泰坦的身份就足以让人诧异（泰坦跟跟地球有什么联系？）；第二是它的畸形，萨格拉斯才算是异类好嘛，小艾顶多算一个别人家的孩子，不过别人家的孩子受人妒忌；第三，同样是泰坦，为什么萨格拉斯就能到处活动，而艾泽拉斯却是一个没有什么存在感的地名（我觉得魔兽最后应该让小艾活，不过这样魔兽世界也就没什么可写了）。</p>\n<p>因为刚生下来就天赋异禀，使得这位初生小泰坦遭遇了各种不幸。所谓树大招风，才大受虐，定义了这个世界不变的原则之一（天妒英才也要在魔兽里体现一下吗）。</p>\n<p>首先是在它身上自然繁衍的元素横行，这些元素包括：火、水、土、风以及来自它身体周围的第五元素——星魂（这让我想起了《第五元素》这部电影，是时候可以复习下）。各元素自有它们各自的首领。风神奥拉基尔，擅长煽风点火，善使计谋，这个家伙是魔兽多人副本风神王座的终BOSS；炎魔拉格纳罗斯性情暴躁，蛮力十足，魔兽火焰之地终BOSS；石母瑟拉赞恩，与地为阵，跟石头有关的东西它能利用为武器；猎潮者耐普图隆是几位元素领主中最为奸滑者，用兵巧妙;小五嘛暂时在这还没有什么作为。前四股势力在小艾身上不断地发生征战，我们称它们为元素F4团，它们连年混战，全然不顾泰坦妈妈的感受。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5b36eacc89efa6c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"元素F4团\"></p>\n<p>当然像小艾这样强大的能量，我们的宇宙恐怖组织怎能不觊觎？首先是黑暗恐怖组织上古之神在小艾身上建立据点，并且开始进行实地探测。既而两大种族相继出生，一为恩剌基（听着怎么像“嗯垃圾”），又名“无面者”；二为亚基虫族。这些生物的形态也许在卡利姆多安其拉神殿可以找到，回头上线的时候我得专门去找一下，之后我会帖图进来。这里我们继续讲故事。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-a266a623c373165e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恩垃圾和亚基虫\"></p>\n<p>虽然元素领主们之间的战争历时弥久，但是毕竟在艾泽拉斯这片土地上他们还是主人，岂容你外来个什么恐怖组织造次。于是小F4签订停战协定，一致公开对外。不过即使是联合貌似也并无甚卵用，这恐怖组织绝非等闲之辈。一战即开，F4团全数被缚。垃圾和亚基将他们送给上古大神们，继而主人变为奴隶，跟着外来大大们一起开始混社会了。  </p>\n<p>小艾的出生同时也牵动着整个神届，萨格拉斯的徒弟阿格拉玛首先找到了它。刚好上古大大正给小艾也喂黑奶，跟之前小萨碰上的情况一模一样。小阿一看也挺害怕，不过他可不如小萨那么有魄力直接就给小孩干死，他赶紧把情况报告给了神届。神届于是展开了讨论，最后决定创造一支大军来抵抗黑暗力量的腐蚀。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-e8e2a31cd640ae19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"天神团成员\"><br>这张图片就是我们的天神团，左上是阿曼苏尔，阿格拉斯就是右边拿长剑的，这是他还没有堕落时的寸照，比较帅，堕落之后走的是狂野风。下面是一张对比图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-97c270d6a31ec941.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"小萨堕落前后对比图\"></p>\n<p> 由锻铸神卡兹格罗斯创造的艾瑟耶尔和瓦尼尔形成，他们是第一批泰坦造物。各路神仙也各展神通，基于他们自己的形貌和力量制造出了守护者，并将他们全部派遣到了艾泽拉斯，完成清剿任务。     </p>\n<p>这里我们认识一些新的人物，对应神届各路众神以及艾泽拉斯守护者（艾泽拉斯众神）。之后神届的神仙会经历一次灭鼎，而后的故事就都跟他们的守护者相关了。       </p>\n<p>我们的神父阿曼苏尔的继承者是大守护者莱和守护者奥丁，莱在后来的魔古一族的称覇中起着重要的作用。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-8f3238f2d8538011.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"莱和奥丁\"></p>\n<p>锻造师及塑形者卡兹格罗斯的继承守护者是阿札达斯；<br>天穹及啸海之王高甘纳斯将力量授予了守护者索林姆和守护者霍迪尔，前者常控风暴之力，后者掌控天穹之能；<br>创生者伊欧娜（唯一一位女神吧）给予了守护者芙蕾娜自然的力量，让她可以动用动植物的力量；<br>天外魔法诺甘农的继承者是守护者洛肯和米米隆，这两个人应该不陌生，副本奥杜尔中可以看到他们的身影，而后者掉落的坐骑恐怕是好多魔兽玩家都想拥有的；</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-74d2de96cbf30cf2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"索林姆（上左）、霍迪尔（上右）和米米隆\"></p>\n<p>阿格拉玛，我们的小阿的继承者是提尔，他是艾泽拉斯最为强大的战士，白银之手就出自于他。这样，守护者大军便就此形成，而精彩的故事才刚刚开始。       </p>\n<p>下篇我们会从艾泽拉斯最初的战争开始讲述，今天的故事就到这里吧，欢迎关注我的公众号哦。</p>"},{"title":"艾泽拉斯龙族的诞生","date":"2016-08-16T00:34:00.000Z","_content":"\n![](http://upload-images.jianshu.io/upload_images/1429775-7db2fe0eb6e1a890.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n万神殿的大BOSS们培养了自己的继承者，放心的去度假了。不过走之前还留了个看家的，被称为观察者阿加隆。这个家伙厉害了，它的能力就是清楚艾泽拉斯的一切，所以守护者们也都不敢惹。听说过白银之手骑士团吧，白银之手就是提尔之手，是不是想到了什么？大BOSS们走了之后，艾泽拉斯是更加的不太平。上回说到元素有了血肉之后就叫做，元龙，这个物种比较狂暴。其中有一个头目叫做迦拉克隆，这个家伙除了比较厉害还有一个特点，就是吃同类，吃了以后呢还长。于是越长越大，没人能收拾得了。我觉得魔兽争覇中冰霜巨龙的原型就应该是它，编年体中还说它后来带了一支亡灵军团，那这样就验证了这一点。\n\n![迦拉克隆](http://upload-images.jianshu.io/upload_images/1429775-de109639dcc950a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n守护者提尔率先发现了它并准备解决掉这个祸害，但是他的守护者朋友们没有来帮助他的，他只能去找一些帮手。他从元龙中找到了几条能力强大的队友，它们就是后来的龙族头目，它们分别是，阿莱克兹塔萨、耐萨里奥、玛里苟斯、伊瑟拉、诺兹多姆。讲到这终于有好多名字开始熟悉起来，这五条龙就是我们在魔兽资料片中遇到的那五条守护巨龙。它们和提尔一同杀掉了吃同类的迦拉克隆，还记得北极的龙眠神殿吗，在它北部的龙骨荒野就是迦拉克隆最后死的地方。当然这个故事的主人公是我们的提尔，在与迦拉克隆的对战中起主导作用的还是守护者力量，只是战斗的过程中，提尔被大家伙咬断手臂，提尔后来用一条白银手臂替代了自己被咬断的石头臂膀，它象征着正义和英勇。\n\n![龙骨荒野](http://upload-images.jianshu.io/upload_images/1429775-a2cf7b3d35d534e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这次战斗为表彰五条元龙的助力，守护者们除奥丁一人均选定了自己的继承者们，于是第二批守护者诞生，五条守护巨龙分别各司其职，红龙阿莱克兹塔萨是生命女王，青铜龙诺兹多姆掌管时间的力量，蓝龙玛里苟斯控制魔法，绿龙伊瑟拉掌控梦境之力，黑龙耐萨里奥则拥有大地之力。龙眠神殿就从此在龙骨荒野建起，各龙随后各自领导了五色龙族。龙族历史开始。","source":"_posts/艾泽拉斯龙族的诞生.md","raw":"title: 艾泽拉斯龙族的诞生\ndate: 2016-08-16 08:34:00\ncategories: Azeroth\n-----------\n\n![](http://upload-images.jianshu.io/upload_images/1429775-7db2fe0eb6e1a890.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n万神殿的大BOSS们培养了自己的继承者，放心的去度假了。不过走之前还留了个看家的，被称为观察者阿加隆。这个家伙厉害了，它的能力就是清楚艾泽拉斯的一切，所以守护者们也都不敢惹。听说过白银之手骑士团吧，白银之手就是提尔之手，是不是想到了什么？大BOSS们走了之后，艾泽拉斯是更加的不太平。上回说到元素有了血肉之后就叫做，元龙，这个物种比较狂暴。其中有一个头目叫做迦拉克隆，这个家伙除了比较厉害还有一个特点，就是吃同类，吃了以后呢还长。于是越长越大，没人能收拾得了。我觉得魔兽争覇中冰霜巨龙的原型就应该是它，编年体中还说它后来带了一支亡灵军团，那这样就验证了这一点。\n\n![迦拉克隆](http://upload-images.jianshu.io/upload_images/1429775-de109639dcc950a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n守护者提尔率先发现了它并准备解决掉这个祸害，但是他的守护者朋友们没有来帮助他的，他只能去找一些帮手。他从元龙中找到了几条能力强大的队友，它们就是后来的龙族头目，它们分别是，阿莱克兹塔萨、耐萨里奥、玛里苟斯、伊瑟拉、诺兹多姆。讲到这终于有好多名字开始熟悉起来，这五条龙就是我们在魔兽资料片中遇到的那五条守护巨龙。它们和提尔一同杀掉了吃同类的迦拉克隆，还记得北极的龙眠神殿吗，在它北部的龙骨荒野就是迦拉克隆最后死的地方。当然这个故事的主人公是我们的提尔，在与迦拉克隆的对战中起主导作用的还是守护者力量，只是战斗的过程中，提尔被大家伙咬断手臂，提尔后来用一条白银手臂替代了自己被咬断的石头臂膀，它象征着正义和英勇。\n\n![龙骨荒野](http://upload-images.jianshu.io/upload_images/1429775-a2cf7b3d35d534e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这次战斗为表彰五条元龙的助力，守护者们除奥丁一人均选定了自己的继承者们，于是第二批守护者诞生，五条守护巨龙分别各司其职，红龙阿莱克兹塔萨是生命女王，青铜龙诺兹多姆掌管时间的力量，蓝龙玛里苟斯控制魔法，绿龙伊瑟拉掌控梦境之力，黑龙耐萨里奥则拥有大地之力。龙眠神殿就从此在龙骨荒野建起，各龙随后各自领导了五色龙族。龙族历史开始。","slug":"艾泽拉斯龙族的诞生","published":1,"updated":"2018-05-04T10:25:03.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucip5002q1v603a59a1dw","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-7db2fe0eb6e1a890.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>万神殿的大BOSS们培养了自己的继承者，放心的去度假了。不过走之前还留了个看家的，被称为观察者阿加隆。这个家伙厉害了，它的能力就是清楚艾泽拉斯的一切，所以守护者们也都不敢惹。听说过白银之手骑士团吧，白银之手就是提尔之手，是不是想到了什么？大BOSS们走了之后，艾泽拉斯是更加的不太平。上回说到元素有了血肉之后就叫做，元龙，这个物种比较狂暴。其中有一个头目叫做迦拉克隆，这个家伙除了比较厉害还有一个特点，就是吃同类，吃了以后呢还长。于是越长越大，没人能收拾得了。我觉得魔兽争覇中冰霜巨龙的原型就应该是它，编年体中还说它后来带了一支亡灵军团，那这样就验证了这一点。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-de109639dcc950a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"迦拉克隆\"></p>\n<p>守护者提尔率先发现了它并准备解决掉这个祸害，但是他的守护者朋友们没有来帮助他的，他只能去找一些帮手。他从元龙中找到了几条能力强大的队友，它们就是后来的龙族头目，它们分别是，阿莱克兹塔萨、耐萨里奥、玛里苟斯、伊瑟拉、诺兹多姆。讲到这终于有好多名字开始熟悉起来，这五条龙就是我们在魔兽资料片中遇到的那五条守护巨龙。它们和提尔一同杀掉了吃同类的迦拉克隆，还记得北极的龙眠神殿吗，在它北部的龙骨荒野就是迦拉克隆最后死的地方。当然这个故事的主人公是我们的提尔，在与迦拉克隆的对战中起主导作用的还是守护者力量，只是战斗的过程中，提尔被大家伙咬断手臂，提尔后来用一条白银手臂替代了自己被咬断的石头臂膀，它象征着正义和英勇。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-a2cf7b3d35d534e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"龙骨荒野\"></p>\n<p>这次战斗为表彰五条元龙的助力，守护者们除奥丁一人均选定了自己的继承者们，于是第二批守护者诞生，五条守护巨龙分别各司其职，红龙阿莱克兹塔萨是生命女王，青铜龙诺兹多姆掌管时间的力量，蓝龙玛里苟斯控制魔法，绿龙伊瑟拉掌控梦境之力，黑龙耐萨里奥则拥有大地之力。龙眠神殿就从此在龙骨荒野建起，各龙随后各自领导了五色龙族。龙族历史开始。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-7db2fe0eb6e1a890.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>","more":"<p>万神殿的大BOSS们培养了自己的继承者，放心的去度假了。不过走之前还留了个看家的，被称为观察者阿加隆。这个家伙厉害了，它的能力就是清楚艾泽拉斯的一切，所以守护者们也都不敢惹。听说过白银之手骑士团吧，白银之手就是提尔之手，是不是想到了什么？大BOSS们走了之后，艾泽拉斯是更加的不太平。上回说到元素有了血肉之后就叫做，元龙，这个物种比较狂暴。其中有一个头目叫做迦拉克隆，这个家伙除了比较厉害还有一个特点，就是吃同类，吃了以后呢还长。于是越长越大，没人能收拾得了。我觉得魔兽争覇中冰霜巨龙的原型就应该是它，编年体中还说它后来带了一支亡灵军团，那这样就验证了这一点。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-de109639dcc950a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"迦拉克隆\"></p>\n<p>守护者提尔率先发现了它并准备解决掉这个祸害，但是他的守护者朋友们没有来帮助他的，他只能去找一些帮手。他从元龙中找到了几条能力强大的队友，它们就是后来的龙族头目，它们分别是，阿莱克兹塔萨、耐萨里奥、玛里苟斯、伊瑟拉、诺兹多姆。讲到这终于有好多名字开始熟悉起来，这五条龙就是我们在魔兽资料片中遇到的那五条守护巨龙。它们和提尔一同杀掉了吃同类的迦拉克隆，还记得北极的龙眠神殿吗，在它北部的龙骨荒野就是迦拉克隆最后死的地方。当然这个故事的主人公是我们的提尔，在与迦拉克隆的对战中起主导作用的还是守护者力量，只是战斗的过程中，提尔被大家伙咬断手臂，提尔后来用一条白银手臂替代了自己被咬断的石头臂膀，它象征着正义和英勇。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-a2cf7b3d35d534e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"龙骨荒野\"></p>\n<p>这次战斗为表彰五条元龙的助力，守护者们除奥丁一人均选定了自己的继承者们，于是第二批守护者诞生，五条守护巨龙分别各司其职，红龙阿莱克兹塔萨是生命女王，青铜龙诺兹多姆掌管时间的力量，蓝龙玛里苟斯控制魔法，绿龙伊瑟拉掌控梦境之力，黑龙耐萨里奥则拥有大地之力。龙眠神殿就从此在龙骨荒野建起，各龙随后各自领导了五色龙族。龙族历史开始。</p>"},{"title":"雷神陨落与巨魔日衰","date":"2016-09-17T04:36:00.000Z","_content":"\n本篇讲述了魔古族和巨魔两大帝国的衰落，文章采用半文言体，不喜勿喷。\n\n<!-- more -->\n\n我们说，任何的暴虐都不会永远持续，任何的刚愎自用只会自取灭亡，任何的偏执疯狂都会招致灭鼎；雷神陨落，熊猫帝国，历史长河，匆匆而过。\n \n\n>昔雷神称帝，建号魔古，灭诸国，囚天神，筑长城以御螳妖轮回，修地宫以显帝王之功，指点江山，挥斥方遒。\n\n>又艾泽巨魔赞达拉氏族盛极一时，其头领称祖拉瑟拉，与魔古呈鼎力之势。雷神欣喜，诚邀巨魔共谋大业，以得两族子嗣绵延。\n\n>巨魔之臣进言，“尝闻大陆以西，奥丹姆人杰地灵，托维尔一族据守，又有起源熔炉不熄，当取之。”两君商之，甚喜，遂派使者前去招安。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-57b0747bd3ab4c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>使者一路西行，源沙漠入，有幸见此地貌——苍翠雨林，清湖瀑布，土地平旷，金塔俨然，其中生灵奇景满目皆然，人间天堂，美不胜收。然托维尔一族早知雷神背叛行径，声称不与之同流合污，拒之。\n\n>雷神甚怒，集两族之势欲取之。大军压境，兵临城下。托维尔自知无力抵挡，启泰坦遗物，誓不让地一寸，欲与外敌同归黄泉。雷神率众冲锋，未觉异动，行至深处，四周隆隆，地裂数尺，颠簸起伏，能量倾泄，有吞天灭地之势。雷神卒，其众皆陨，奥丹姆不复往日，周遭死迹，颓萎崩裂。托维尔之族，有幸存者，现西去山路，以魔法蔽之，隐于世。\n\n>至于雷神之众，自是有逃出回国者，夺雷神尸体，于帝国征服者之墓供奉。赞达拉也再无兴风作浪之能是。有道是，多行不义必自毙。双魔帝国，国力渐衰。\n\n>魔古末年，帝称牢非，异号“缚奴”，生平极奢。其下熊猫人康，苦于皇帝压迫，又魔古自奥丹姆之役一蹶不振，遂揭竿而起。康深谙武道，教习众人，于魔古山宝库大胜牢非。各路诸侯见势，群雄尽起。猢狲、锦鱼人、土地精、野牛人，皆于各地抗击魔古。牢非不敌众人，退守锦绣谷，盘据帝国皇土。后康乘胜追击，杀牢非，废奴制，除不公，建新国。各种族相继称王，各国之间互通有无，繁荣之相，一派详和。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-1922c521289b7024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>魔古虽灭，巨魔又至。熊猫帝国初建，北御巨魔，南据螳妖。然国之武力，唯初时一众武僧，一拳难敌四手，战势危机。人曰，乱世当有才杰出。英雄救世不问出处，时有熊猫人蒋，幼时救猛兽云端翔龙，好生照料，翔龙喜，为之友，蒋以罗称。战事至翡翠林，蒋携罗从天而降，杀巨魔。巨魔又至，巨魔又败。凡艾泽拉斯之战，行此不义之师，多有英雄起而灭之，此为艾泽之福，众生之福。\n\n \n魔兽世界两大帝国，终因行不义之师，使得帝国终成明日黄花，往昔的繁荣，不过成历史长河中沧海一粟。一部魔兽历史，亦是一部世界历史，历史告诫我们，并非不义之师不能存在，而是因它有悖人道，必然不能长久，必然不能受到人们颂扬。历史只会记往那些给人们带来更好生活的人和事，于是我们有了这样的词语：英雄，事迹，杰出，仁治，盛世，爱戴，歌颂……","source":"_posts/雷神陨落与巨魔日衰.md","raw":"title: 雷神陨落与巨魔日衰\ndate: 2016-09-17 12:36:00\ncategories: Azeroth\n-----------\n\n本篇讲述了魔古族和巨魔两大帝国的衰落，文章采用半文言体，不喜勿喷。\n\n<!-- more -->\n\n我们说，任何的暴虐都不会永远持续，任何的刚愎自用只会自取灭亡，任何的偏执疯狂都会招致灭鼎；雷神陨落，熊猫帝国，历史长河，匆匆而过。\n \n\n>昔雷神称帝，建号魔古，灭诸国，囚天神，筑长城以御螳妖轮回，修地宫以显帝王之功，指点江山，挥斥方遒。\n\n>又艾泽巨魔赞达拉氏族盛极一时，其头领称祖拉瑟拉，与魔古呈鼎力之势。雷神欣喜，诚邀巨魔共谋大业，以得两族子嗣绵延。\n\n>巨魔之臣进言，“尝闻大陆以西，奥丹姆人杰地灵，托维尔一族据守，又有起源熔炉不熄，当取之。”两君商之，甚喜，遂派使者前去招安。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-57b0747bd3ab4c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>使者一路西行，源沙漠入，有幸见此地貌——苍翠雨林，清湖瀑布，土地平旷，金塔俨然，其中生灵奇景满目皆然，人间天堂，美不胜收。然托维尔一族早知雷神背叛行径，声称不与之同流合污，拒之。\n\n>雷神甚怒，集两族之势欲取之。大军压境，兵临城下。托维尔自知无力抵挡，启泰坦遗物，誓不让地一寸，欲与外敌同归黄泉。雷神率众冲锋，未觉异动，行至深处，四周隆隆，地裂数尺，颠簸起伏，能量倾泄，有吞天灭地之势。雷神卒，其众皆陨，奥丹姆不复往日，周遭死迹，颓萎崩裂。托维尔之族，有幸存者，现西去山路，以魔法蔽之，隐于世。\n\n>至于雷神之众，自是有逃出回国者，夺雷神尸体，于帝国征服者之墓供奉。赞达拉也再无兴风作浪之能是。有道是，多行不义必自毙。双魔帝国，国力渐衰。\n\n>魔古末年，帝称牢非，异号“缚奴”，生平极奢。其下熊猫人康，苦于皇帝压迫，又魔古自奥丹姆之役一蹶不振，遂揭竿而起。康深谙武道，教习众人，于魔古山宝库大胜牢非。各路诸侯见势，群雄尽起。猢狲、锦鱼人、土地精、野牛人，皆于各地抗击魔古。牢非不敌众人，退守锦绣谷，盘据帝国皇土。后康乘胜追击，杀牢非，废奴制，除不公，建新国。各种族相继称王，各国之间互通有无，繁荣之相，一派详和。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-1922c521289b7024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>魔古虽灭，巨魔又至。熊猫帝国初建，北御巨魔，南据螳妖。然国之武力，唯初时一众武僧，一拳难敌四手，战势危机。人曰，乱世当有才杰出。英雄救世不问出处，时有熊猫人蒋，幼时救猛兽云端翔龙，好生照料，翔龙喜，为之友，蒋以罗称。战事至翡翠林，蒋携罗从天而降，杀巨魔。巨魔又至，巨魔又败。凡艾泽拉斯之战，行此不义之师，多有英雄起而灭之，此为艾泽之福，众生之福。\n\n \n魔兽世界两大帝国，终因行不义之师，使得帝国终成明日黄花，往昔的繁荣，不过成历史长河中沧海一粟。一部魔兽历史，亦是一部世界历史，历史告诫我们，并非不义之师不能存在，而是因它有悖人道，必然不能长久，必然不能受到人们颂扬。历史只会记往那些给人们带来更好生活的人和事，于是我们有了这样的词语：英雄，事迹，杰出，仁治，盛世，爱戴，歌颂……","slug":"雷神陨落与巨魔日衰","published":1,"updated":"2018-05-04T10:25:19.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucip7002u1v60gme9ul5d","content":"<p>本篇讲述了魔古族和巨魔两大帝国的衰落，文章采用半文言体，不喜勿喷。</p>\n<a id=\"more\"></a>\n<p>我们说，任何的暴虐都不会永远持续，任何的刚愎自用只会自取灭亡，任何的偏执疯狂都会招致灭鼎；雷神陨落，熊猫帝国，历史长河，匆匆而过。</p>\n<blockquote>\n<p>昔雷神称帝，建号魔古，灭诸国，囚天神，筑长城以御螳妖轮回，修地宫以显帝王之功，指点江山，挥斥方遒。</p>\n</blockquote>\n<blockquote>\n<p>又艾泽巨魔赞达拉氏族盛极一时，其头领称祖拉瑟拉，与魔古呈鼎力之势。雷神欣喜，诚邀巨魔共谋大业，以得两族子嗣绵延。</p>\n</blockquote>\n<blockquote>\n<p>巨魔之臣进言，“尝闻大陆以西，奥丹姆人杰地灵，托维尔一族据守，又有起源熔炉不熄，当取之。”两君商之，甚喜，遂派使者前去招安。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-57b0747bd3ab4c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>使者一路西行，源沙漠入，有幸见此地貌——苍翠雨林，清湖瀑布，土地平旷，金塔俨然，其中生灵奇景满目皆然，人间天堂，美不胜收。然托维尔一族早知雷神背叛行径，声称不与之同流合污，拒之。</p>\n</blockquote>\n<blockquote>\n<p>雷神甚怒，集两族之势欲取之。大军压境，兵临城下。托维尔自知无力抵挡，启泰坦遗物，誓不让地一寸，欲与外敌同归黄泉。雷神率众冲锋，未觉异动，行至深处，四周隆隆，地裂数尺，颠簸起伏，能量倾泄，有吞天灭地之势。雷神卒，其众皆陨，奥丹姆不复往日，周遭死迹，颓萎崩裂。托维尔之族，有幸存者，现西去山路，以魔法蔽之，隐于世。</p>\n</blockquote>\n<blockquote>\n<p>至于雷神之众，自是有逃出回国者，夺雷神尸体，于帝国征服者之墓供奉。赞达拉也再无兴风作浪之能是。有道是，多行不义必自毙。双魔帝国，国力渐衰。</p>\n</blockquote>\n<blockquote>\n<p>魔古末年，帝称牢非，异号“缚奴”，生平极奢。其下熊猫人康，苦于皇帝压迫，又魔古自奥丹姆之役一蹶不振，遂揭竿而起。康深谙武道，教习众人，于魔古山宝库大胜牢非。各路诸侯见势，群雄尽起。猢狲、锦鱼人、土地精、野牛人，皆于各地抗击魔古。牢非不敌众人，退守锦绣谷，盘据帝国皇土。后康乘胜追击，杀牢非，废奴制，除不公，建新国。各种族相继称王，各国之间互通有无，繁荣之相，一派详和。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1922c521289b7024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>魔古虽灭，巨魔又至。熊猫帝国初建，北御巨魔，南据螳妖。然国之武力，唯初时一众武僧，一拳难敌四手，战势危机。人曰，乱世当有才杰出。英雄救世不问出处，时有熊猫人蒋，幼时救猛兽云端翔龙，好生照料，翔龙喜，为之友，蒋以罗称。战事至翡翠林，蒋携罗从天而降，杀巨魔。巨魔又至，巨魔又败。凡艾泽拉斯之战，行此不义之师，多有英雄起而灭之，此为艾泽之福，众生之福。</p>\n</blockquote>\n<p>魔兽世界两大帝国，终因行不义之师，使得帝国终成明日黄花，往昔的繁荣，不过成历史长河中沧海一粟。一部魔兽历史，亦是一部世界历史，历史告诫我们，并非不义之师不能存在，而是因它有悖人道，必然不能长久，必然不能受到人们颂扬。历史只会记往那些给人们带来更好生活的人和事，于是我们有了这样的词语：英雄，事迹，杰出，仁治，盛世，爱戴，歌颂……</p>\n","site":{"data":{}},"excerpt":"<p>本篇讲述了魔古族和巨魔两大帝国的衰落，文章采用半文言体，不喜勿喷。</p>","more":"<p>我们说，任何的暴虐都不会永远持续，任何的刚愎自用只会自取灭亡，任何的偏执疯狂都会招致灭鼎；雷神陨落，熊猫帝国，历史长河，匆匆而过。</p>\n<blockquote>\n<p>昔雷神称帝，建号魔古，灭诸国，囚天神，筑长城以御螳妖轮回，修地宫以显帝王之功，指点江山，挥斥方遒。</p>\n</blockquote>\n<blockquote>\n<p>又艾泽巨魔赞达拉氏族盛极一时，其头领称祖拉瑟拉，与魔古呈鼎力之势。雷神欣喜，诚邀巨魔共谋大业，以得两族子嗣绵延。</p>\n</blockquote>\n<blockquote>\n<p>巨魔之臣进言，“尝闻大陆以西，奥丹姆人杰地灵，托维尔一族据守，又有起源熔炉不熄，当取之。”两君商之，甚喜，遂派使者前去招安。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-57b0747bd3ab4c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>使者一路西行，源沙漠入，有幸见此地貌——苍翠雨林，清湖瀑布，土地平旷，金塔俨然，其中生灵奇景满目皆然，人间天堂，美不胜收。然托维尔一族早知雷神背叛行径，声称不与之同流合污，拒之。</p>\n</blockquote>\n<blockquote>\n<p>雷神甚怒，集两族之势欲取之。大军压境，兵临城下。托维尔自知无力抵挡，启泰坦遗物，誓不让地一寸，欲与外敌同归黄泉。雷神率众冲锋，未觉异动，行至深处，四周隆隆，地裂数尺，颠簸起伏，能量倾泄，有吞天灭地之势。雷神卒，其众皆陨，奥丹姆不复往日，周遭死迹，颓萎崩裂。托维尔之族，有幸存者，现西去山路，以魔法蔽之，隐于世。</p>\n</blockquote>\n<blockquote>\n<p>至于雷神之众，自是有逃出回国者，夺雷神尸体，于帝国征服者之墓供奉。赞达拉也再无兴风作浪之能是。有道是，多行不义必自毙。双魔帝国，国力渐衰。</p>\n</blockquote>\n<blockquote>\n<p>魔古末年，帝称牢非，异号“缚奴”，生平极奢。其下熊猫人康，苦于皇帝压迫，又魔古自奥丹姆之役一蹶不振，遂揭竿而起。康深谙武道，教习众人，于魔古山宝库大胜牢非。各路诸侯见势，群雄尽起。猢狲、锦鱼人、土地精、野牛人，皆于各地抗击魔古。牢非不敌众人，退守锦绣谷，盘据帝国皇土。后康乘胜追击，杀牢非，废奴制，除不公，建新国。各种族相继称王，各国之间互通有无，繁荣之相，一派详和。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1922c521289b7024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>魔古虽灭，巨魔又至。熊猫帝国初建，北御巨魔，南据螳妖。然国之武力，唯初时一众武僧，一拳难敌四手，战势危机。人曰，乱世当有才杰出。英雄救世不问出处，时有熊猫人蒋，幼时救猛兽云端翔龙，好生照料，翔龙喜，为之友，蒋以罗称。战事至翡翠林，蒋携罗从天而降，杀巨魔。巨魔又至，巨魔又败。凡艾泽拉斯之战，行此不义之师，多有英雄起而灭之，此为艾泽之福，众生之福。</p>\n</blockquote>\n<p>魔兽世界两大帝国，终因行不义之师，使得帝国终成明日黄花，往昔的繁荣，不过成历史长河中沧海一粟。一部魔兽历史，亦是一部世界历史，历史告诫我们，并非不义之师不能存在，而是因它有悖人道，必然不能长久，必然不能受到人们颂扬。历史只会记往那些给人们带来更好生活的人和事，于是我们有了这样的词语：英雄，事迹，杰出，仁治，盛世，爱戴，歌颂……</p>"},{"title":"记一次iOS上线提审","date":"2017-12-07T09:50:00.000Z","_content":"\n公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。\n\n<!-- more -->\n\n首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：\n\n![image_1bu7k3nt22m3cmearq636qua9.png-14.8kB][1]\n\n本人在ios11上做了提交，发现问题进行分类：\n1. 第一个是第三方库存在x86_64,i386的链接库，有以下问题：\n\n```\niTunes Store Operation Failed\nERROR ITMS-90087: \"Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures '[x86_64, i386]'.\"\n```\n\nPS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；\n```\niTunes Store Operation Failed\nERROR ITMS-90209: \"Invalid Segment Alignment. The app binary at 'LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.\"\n无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。\n```\n\n```\niTunes Store Operation Failed\nERROR ITMS-90125: \"The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple's linker.\"\n“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”\n```\n```\niTunes Store Operation Failed\nWARNING ITMS-90080: \"The executable 'Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&A QA1788 - Building a Position Independent Executable in the iOS Developer Library.\"\n“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”\n```\n\n```\nERROR ITMS-90362: \"Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0\"\n```\n后面这个**90362**貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；\n\n解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：\n![image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB][2]\n```\nAPP_PATH=\"${TARGET_BUILD_DIR}/${WRAPPER_NAME}\"\n\n# This script loops through the frameworks embedded in the application and\n# removes unused architectures.\nfind \"$APP_PATH\" -name '*.framework' -type d | while read -r FRAMEWORK\ndo\nFRAMEWORK_EXECUTABLE_NAME=$(defaults read \"$FRAMEWORK/Info.plist\" CFBundleExecutable)\nFRAMEWORK_EXECUTABLE_PATH=\"$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME\"\necho \"Executable is $FRAMEWORK_EXECUTABLE_PATH\"\n\nEXTRACTED_ARCHS=()\n\nfor ARCH in $ARCHS\ndo\necho \"Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME\"\nlipo -extract \"$ARCH\" \"$FRAMEWORK_EXECUTABLE_PATH\" -o \"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\"\nEXTRACTED_ARCHS+=(\"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\")\ndone\n\necho \"Merging extracted architectures: ${ARCHS}\"\nlipo -o \"$FRAMEWORK_EXECUTABLE_PATH-merged\" -create \"${EXTRACTED_ARCHS[@]}\"\nrm \"${EXTRACTED_ARCHS[@]}\"\n\necho \"Replacing original executable with thinned version\"\nrm \"$FRAMEWORK_EXECUTABLE_PATH\"\nmv \"$FRAMEWORK_EXECUTABLE_PATH-merged\" \"$FRAMEWORK_EXECUTABLE_PATH\"\ndone\n```\n以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；\n\n2. 项目有icon不合规定的错误\n```\niTunes Store Operation Failed\nERROR ITMS-90717: \"Invalid App Store Icon. The App Store Icon in the asset catalog in 'LeWaiJiao.app' can't be transparent nor contain an alpha channel.\"\n无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”\n```\n该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；\n解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：\n\n![image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB][3]\n\n用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；\n![image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB][4]\n\n3. 提交上传结束后又出现了一个问题\n\n```\nApp Installation failed, No code signature found.\n```\n真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入\n\n```\nsudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk \n```\n\n修改文件权限，然后修改字段属性，打开：\n\n**/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist**\n\n，修改 **CODE_SIGNING_REQUIRED** 字段为 **YES** ，保存；\n\n\n\n  [1]: http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\n  [2]: http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\n  [3]: http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\n  [4]: http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png","source":"_posts/记一次iOS上线提审.md","raw":"title: 记一次iOS上线提审\ndate: 2017-12-07 17:50:00\ncategories: coder\ntags: [iOS]\n-----------\n\n公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。\n\n<!-- more -->\n\n首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：\n\n![image_1bu7k3nt22m3cmearq636qua9.png-14.8kB][1]\n\n本人在ios11上做了提交，发现问题进行分类：\n1. 第一个是第三方库存在x86_64,i386的链接库，有以下问题：\n\n```\niTunes Store Operation Failed\nERROR ITMS-90087: \"Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures '[x86_64, i386]'.\"\n```\n\nPS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；\n```\niTunes Store Operation Failed\nERROR ITMS-90209: \"Invalid Segment Alignment. The app binary at 'LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers' does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.\"\n无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。\n```\n\n```\niTunes Store Operation Failed\nERROR ITMS-90125: \"The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple's linker.\"\n“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”\n```\n```\niTunes Store Operation Failed\nWARNING ITMS-90080: \"The executable 'Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework' is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&A QA1788 - Building a Position Independent Executable in the iOS Developer Library.\"\n“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”\n```\n\n```\nERROR ITMS-90362: \"Invalid Info.plist value. The value for the key 'MinimumOSVersion' in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0\"\n```\n后面这个**90362**貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；\n\n解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：\n![image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB][2]\n```\nAPP_PATH=\"${TARGET_BUILD_DIR}/${WRAPPER_NAME}\"\n\n# This script loops through the frameworks embedded in the application and\n# removes unused architectures.\nfind \"$APP_PATH\" -name '*.framework' -type d | while read -r FRAMEWORK\ndo\nFRAMEWORK_EXECUTABLE_NAME=$(defaults read \"$FRAMEWORK/Info.plist\" CFBundleExecutable)\nFRAMEWORK_EXECUTABLE_PATH=\"$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME\"\necho \"Executable is $FRAMEWORK_EXECUTABLE_PATH\"\n\nEXTRACTED_ARCHS=()\n\nfor ARCH in $ARCHS\ndo\necho \"Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME\"\nlipo -extract \"$ARCH\" \"$FRAMEWORK_EXECUTABLE_PATH\" -o \"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\"\nEXTRACTED_ARCHS+=(\"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\")\ndone\n\necho \"Merging extracted architectures: ${ARCHS}\"\nlipo -o \"$FRAMEWORK_EXECUTABLE_PATH-merged\" -create \"${EXTRACTED_ARCHS[@]}\"\nrm \"${EXTRACTED_ARCHS[@]}\"\n\necho \"Replacing original executable with thinned version\"\nrm \"$FRAMEWORK_EXECUTABLE_PATH\"\nmv \"$FRAMEWORK_EXECUTABLE_PATH-merged\" \"$FRAMEWORK_EXECUTABLE_PATH\"\ndone\n```\n以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；\n\n2. 项目有icon不合规定的错误\n```\niTunes Store Operation Failed\nERROR ITMS-90717: \"Invalid App Store Icon. The App Store Icon in the asset catalog in 'LeWaiJiao.app' can't be transparent nor contain an alpha channel.\"\n无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”\n```\n该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；\n解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：\n\n![image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB][3]\n\n用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；\n![image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB][4]\n\n3. 提交上传结束后又出现了一个问题\n\n```\nApp Installation failed, No code signature found.\n```\n真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入\n\n```\nsudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk \n```\n\n修改文件权限，然后修改字段属性，打开：\n\n**/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist**\n\n，修改 **CODE_SIGNING_REQUIRED** 字段为 **YES** ，保存；\n\n\n\n  [1]: http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\n  [2]: http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\n  [3]: http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\n  [4]: http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png","slug":"记一次iOS上线提审","published":1,"updated":"2018-05-04T10:25:11.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucip8002w1v60hwn3tkns","content":"<p>公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。</p>\n<a id=\"more\"></a>\n<p>首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\" alt=\"image_1bu7k3nt22m3cmearq636qua9.png-14.8kB\"></p>\n<p>本人在ios11上做了提交，发现问题进行分类：</p>\n<ol>\n<li>第一个是第三方库存在x86_64,i386的链接库，有以下问题：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;</span><br></pre></td></tr></table></figure>\n<p>PS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90209: &quot;Invalid Segment Alignment. The app binary at &apos;LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers&apos; does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.&quot;</span><br><span class=\"line\">无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90125: &quot;The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple&apos;s linker.&quot;</span><br><span class=\"line\">“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">WARNING ITMS-90080: &quot;The executable &apos;Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework&apos; is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&amp;A QA1788 - Building a Position Independent Executable in the iOS Developer Library.&quot;</span><br><span class=\"line\">“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR ITMS-90362: &quot;Invalid Info.plist value. The value for the key &apos;MinimumOSVersion&apos; in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0&quot;</span><br></pre></td></tr></table></figure>\n<p>后面这个<strong>90362</strong>貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；</p>\n<p>解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：<br><img src=\"http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\" alt=\"image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># This script loops through the frameworks embedded in the application and</span><br><span class=\"line\"># removes unused architectures.</span><br><span class=\"line\">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class=\"line\">do</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">EXTRACTED_ARCHS=()</span><br><span class=\"line\"></span><br><span class=\"line\">for ARCH in $ARCHS</span><br><span class=\"line\">do</span><br><span class=\"line\">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class=\"line\">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class=\"line\">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class=\"line\">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；</p>\n<ol start=\"2\">\n<li>项目有icon不合规定的错误<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90717: &quot;Invalid App Store Icon. The App Store Icon in the asset catalog in &apos;LeWaiJiao.app&apos; can&apos;t be transparent nor contain an alpha channel.&quot;</span><br><span class=\"line\">无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；<br>解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\" alt=\"image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB\"></p>\n<p>用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；<br><img src=\"http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png\" alt=\"image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB\"></p>\n<ol start=\"3\">\n<li>提交上传结束后又出现了一个问题</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App Installation failed, No code signature found.</span><br></pre></td></tr></table></figure>\n<p>真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk</span><br></pre></td></tr></table></figure>\n<p>修改文件权限，然后修改字段属性，打开：</p>\n<p><strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist</strong></p>\n<p>，修改 <strong>CODE_SIGNING_REQUIRED</strong> 字段为 <strong>YES</strong> ，保存；</p>\n","site":{"data":{}},"excerpt":"<p>公司最近的一次App提交过程中遇到的一些问题，现贴在这里，有检索到本篇的朋友们可借鉴。</p>","more":"<p>首先是上传到iTunes Connect构建版本，点击以下蓝色按钮，之后会有苹果为你的代码进行检查：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/n72bt0t4wwh45zw5c0kjcv01/image_1bu7k3nt22m3cmearq636qua9.png\" alt=\"image_1bu7k3nt22m3cmearq636qua9.png-14.8kB\"></p>\n<p>本人在ios11上做了提交，发现问题进行分类：</p>\n<ol>\n<li>第一个是第三方库存在x86_64,i386的链接库，有以下问题：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for LeWaiJiao.app/Frameworks/GCDWebServers.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;</span><br></pre></td></tr></table></figure>\n<p>PS:以下所有翻译来源于欧路词典，粘贴过来的，仅供参考；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90209: &quot;Invalid Segment Alignment. The app binary at &apos;LeWaiJiao.app/Frameworks/GCDWebServers.framework/GCDWebServers&apos; does not have proper segment alignment. Try rebuilding the app with the latest Xcode version.&quot;</span><br><span class=\"line\">无效段对齐。应用程序二进制的“lewaijiao。应用程序/框架/ gcdwebservers。框架/ gcdwebservers”没有正确对齐。尝试用新的Xcode版本重建应用程序。</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90125: &quot;The binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple&apos;s linker.&quot;</span><br><span class=\"line\">“二进制无效。在lc_encryption_info负荷指令加密信息丢失或无效，或是已经加密的二进制。这个二进制文件似乎没有用苹果的链接器构建。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">WARNING ITMS-90080: &quot;The executable &apos;Payload/LeWaiJiao.app/Frameworks/GCDWebServers.framework&apos; is not a Position Independent Executable. Please ensure that your build settings are configured to create PIE executables. For more information refer to Technical Q&amp;A QA1788 - Building a Position Independent Executable in the iOS Developer Library.&quot;</span><br><span class=\"line\">“可执行的有效载荷/ lewaijiao。应用程序/框架/ gcdwebservers。框架”不是一个独立的可执行文件的位置。请确保您的构建设置配置为创建饼可执行文件。更多信息请参阅技术问答qa1788在iOS开发者库位置独立的可执行的建筑。”</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR ITMS-90362: &quot;Invalid Info.plist value. The value for the key &apos;MinimumOSVersion&apos; in bundle ***.app/Frameworks/SDK.framework is invalid. The minimum value is 8.0&quot;</span><br></pre></td></tr></table></figure>\n<p>后面这个<strong>90362</strong>貌似是连带问题，定位的时候发现与最小版本无关，所以一同被解决了；</p>\n<p>解决方法呢是在该工程里添加脚本处理这些被添加进来的第三方库，如下：<br><img src=\"http://static.zybuluo.com/usiege/mqh6ttzi6hsixpddv5nmcu03/image_1bu7kmq06140t1nmhkf11sfq1civm.png\" alt=\"image_1bu7kmq06140t1nmhkf11sfq1civm.png-235.5kB\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># This script loops through the frameworks embedded in the application and</span><br><span class=\"line\"># removes unused architectures.</span><br><span class=\"line\">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class=\"line\">do</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class=\"line\">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">EXTRACTED_ARCHS=()</span><br><span class=\"line\"></span><br><span class=\"line\">for ARCH in $ARCHS</span><br><span class=\"line\">do</span><br><span class=\"line\">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class=\"line\">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class=\"line\">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class=\"line\">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class=\"line\">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>以上代码来源于Google，解决方法经确认iOS11 + Xcode9.0有效；</p>\n<ol start=\"2\">\n<li>项目有icon不合规定的错误<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iTunes Store Operation Failed</span><br><span class=\"line\">ERROR ITMS-90717: &quot;Invalid App Store Icon. The App Store Icon in the asset catalog in &apos;LeWaiJiao.app&apos; can&apos;t be transparent nor contain an alpha channel.&quot;</span><br><span class=\"line\">无效应用程序商店图标。在资产目录中的lewaijiao App Store图标，应用程序不能透明也包含alpha通道。”</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该错误原因是上传的icon不符合苹果规定，公司项目存在的问题是1.使用了圆角；2.有透明alpha通道；<br>解决方法自然容易了，找设计重新做，自己解决的话第二个可以DIY，如下：</p>\n<p><img src=\"http://static.zybuluo.com/usiege/xtde6py269a5m4iusbumms4p/image_1bu7l6vhrvhm51b13pjvrlc0p13.png\" alt=\"image_1bu7l6vhrvhm51b13pjvrlc0p13.png-100.4kB\"></p>\n<p>用系统预览打开icon图片，点掉Alpha的勾，再保存就可以了；<br><img src=\"http://static.zybuluo.com/usiege/yql5tndy4d612fhqfsi9n4l2/image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png\" alt=\"image_1bu7l8bt61p6v1mp11csi15ri1dmg1g.png-128.6kB\"></p>\n<ol start=\"3\">\n<li>提交上传结束后又出现了一个问题</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App Installation failed, No code signature found.</span><br></pre></td></tr></table></figure>\n<p>真机无法运行了！这个问题纯属偶然，所以继续解决；打开终端，输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod -R 777 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk</span><br></pre></td></tr></table></figure>\n<p>修改文件权限，然后修改字段属性，打开：</p>\n<p><strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist</strong></p>\n<p>，修改 <strong>CODE_SIGNING_REQUIRED</strong> 字段为 <strong>YES</strong> ，保存；</p>"},{"title":"艾泽拉斯早期的世界格局","date":"2016-08-14T09:42:00.000Z","_content":"\n\n![早期艾泽拉斯](http://upload-images.jianshu.io/upload_images/1429775-c03ca937f2e8ad28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来，长长的分割线，艾泽拉斯的历史从现在才刚刚开始。\n\n<!-- more -->\n\n\n永恒之井，这个每个魔兽人都耳熟能详的名字，艾泽拉斯的力量源泉，世界格局形成的引子，牵动着每一个魔兽人的命运。它的形成实际上还得从阿曼苏尔搞坏亚煞极说起，话说老阿叔搞亚煞极的时候搞的有点猛，整个血肉模糊，不仅搞出的伤痕处能量外泻，而且亚煞极的好多血肉也四散到艾泽拉斯的很多地方。这烂摊子自然是得有人来收拾，守护者们把伤口搞好就成了“永恒之井”。另外守护者们为守护艾泽拉斯还建造了两个战争机器，意志熔炉和起源熔炉。这两台机器的作用一是用来看管囚禁起来的上古之神们，另外一个作用是建造泰坦造物们。像后来的人类，矮人，侏儒等生物就是这些泰坦造物演变过来的。\n\n![奥杜亚](http://upload-images.jianshu.io/upload_images/1429775-9c8d78c44dccc1cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n魔兽世界北极地区的最上部有一个副本叫做“奥杜尔”，前阶段术士想去单刷来着，结果过不了一片空地上的那个大机器，后来就不了了之了。这个副本应该就是守护者奥丁看守的意志熔炉，它最初的名字叫做奥杜亚堡垒，是泰坦守护者们在艾泽拉斯上的主要阵地，它看守的是上古之神尤格隆萨。这里出产的泰坦商品主要有巨人，土灵，发条机械侏儒，魔古，维库人和托维尔。由此可看巨人，矮人，侏儒，魔古，人类，托维尔当属同一厂商出产“商品”。而在现卡利姆多的南端，大地的裂变之后才逐渐被发现的奥丹姆，则是起源熔炉的所在地，这里也是大守护者莱将亚煞极死后的心脏封印起的地方。而在希利苏斯莱建立起来的安其拉堡垒，则是用来囚禁克苏恩的，即是现今的安其拉神殿。这个副本前些时候术士去单刷过，里面的怪长的都很恐怖，一群怪追着你砍的时候画面会很恶心。\n\n![奥丹姆和安其拉](http://upload-images.jianshu.io/upload_images/1429775-e14f06c60aee8276.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样一来，艾泽拉斯的格局形成的很自然，原有生物、两大熔炉造的生物以及外星来客构成魔兽的生物组成，另外原有大陆以及由守护者芙蕾雅打造的“翡翠梦境”构成魔兽的环境组成。我们再来看看著名的“海加尔山”周边的早期格局，永恒之井爆炸后海山在卡利姆多大陆版块，在魔兽世界中至少有两个版本都有在这块地域的副本。它最初是孕育“荒野众神”的地方，像半神众林守护者也是诞生在这里的。这里其实就是一个动物园（众神有白鹿、小精灵之母，剃刀野猪、百鸟主母、巨熊又王、狼、朱鹤、青龙、白虎、玄牛），魔兽中所有与动物有关的神都师出海山。\n\n![海加尔山﻿](http://upload-images.jianshu.io/upload_images/1429775-761ae17b1342352b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n守护者芙蕾雅还第一个发现了元龙，元龙是一些侥幸从元素位面中逃离的元素生物，定居在艾泽后拥有血肉就成了龙的元始形态。\n\n>普及一个知识，不同文化中龙形态有好多种，这里的元龙指的是西方国家的龙形态，西方的龙，主要是在基督教传播的范围内，作为敌对神（或魔）的形象出现，以强大的肉体力量破坏人类的文明，最后被代表上帝的基督教骑士杀死。有种说法，是说龙的出现和灭亡实际上影射了基督教在原始发展过程中与其他原始宗教之间的冲突，最终这些宗教都倒在了基督教作为官方宗教的强大武力（骑士）上。龙的源头，似乎出自圣经，一只七头十角的红色巨龙，象征神之敌撒旦。而且圣经中说那龙便是古蛇，所以说在西方传说的早期，也是龙蛇不分的。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-d054e15e7c8bd109.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>东方的龙，最早是作为一种有智慧的怪兽出现的，比如黄帝驾六龙，说明龙如马一般可以被驯化，又比如禹治水时有应龙（一种有翅膀的龙，不过从形象上看应该是鸟的翅膀而不是蝙蝠的翅膀）为其开通水路。古代传说中的龙形象也并不确定，有龙生九子一说，九子之中的狴犴、饕餮、赑屃、嘲风等等在后来的建筑装饰中都有体现，并不是现在常见的四脚蛇形象。当然龙的主要形象还是与蛇比较接近，在战国时期的雕刻和挂件设计上体现出来的龙，与红山文化的玉龙相差并不多，只不过多了四只脚而已（当然一说红山文化的玉龙实际上是猪崇拜的衍生产物）。东方比较著名的龙的故事是柳毅传，其中的龙可以变换外形，养一种叫雨工的羊形宠物，而且性情很暴力。此外大家对龙的认识更多的来自西游记，其中龙是各种水体中（连井中也算）的一种强力生物，通常统治着其他水生生物，而且爱好收集闪亮的东西（比如金箍棒）。看起来跟西方的龙有点相像了。不过在西游记里，龙是有职业的，那就是降雨。这一点跟西方以火为主要属性的龙就相去甚远了。熊猫人之迷中所引用的原型是中国龙的形态：\n\n![](http://upload-images.jianshu.io/upload_images/1429775-52457e9dc6657aff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>其实在其他文化圈里也有蛇崇拜（由于这些地方并不管它们叫龙，所以只是蛇崇拜）。南美洲的玛雅文化有一个很重要的神就是羽蛇的形象。（有没有觉得跟中国古代那条挖水沟的应龙有点像？）印度教传说大地的基石是一条蛇，其上是乌龟，乌龟上是大象，大象背上有一个盘子，所以这种世界观就叫碟形世界（特里普拉切特著）。埃及的法老头饰上是秃鹫和昂首的眼镜蛇，而且埃及的猫崇拜也跟蛇有关，原因是古代人睡在地上容易压到蛇被咬死，而养猫能防蛇。北欧的著名不正经神洛基的后裔中就有一条蛇，这条蛇只要醒着就不停地啃食世界树，并且其长度横无际涯（洛基的三个孩子都挺有出息的，但可惜都不是什么正面形象）。","source":"_posts/艾泽拉斯早期的世界格局.md","raw":"title: 艾泽拉斯早期的世界格局\ndate: 2016-08-14 17:42:00\ncategories: Azeroth\n-----------\n\n\n![早期艾泽拉斯](http://upload-images.jianshu.io/upload_images/1429775-c03ca937f2e8ad28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来，长长的分割线，艾泽拉斯的历史从现在才刚刚开始。\n\n<!-- more -->\n\n\n永恒之井，这个每个魔兽人都耳熟能详的名字，艾泽拉斯的力量源泉，世界格局形成的引子，牵动着每一个魔兽人的命运。它的形成实际上还得从阿曼苏尔搞坏亚煞极说起，话说老阿叔搞亚煞极的时候搞的有点猛，整个血肉模糊，不仅搞出的伤痕处能量外泻，而且亚煞极的好多血肉也四散到艾泽拉斯的很多地方。这烂摊子自然是得有人来收拾，守护者们把伤口搞好就成了“永恒之井”。另外守护者们为守护艾泽拉斯还建造了两个战争机器，意志熔炉和起源熔炉。这两台机器的作用一是用来看管囚禁起来的上古之神们，另外一个作用是建造泰坦造物们。像后来的人类，矮人，侏儒等生物就是这些泰坦造物演变过来的。\n\n![奥杜亚](http://upload-images.jianshu.io/upload_images/1429775-9c8d78c44dccc1cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n魔兽世界北极地区的最上部有一个副本叫做“奥杜尔”，前阶段术士想去单刷来着，结果过不了一片空地上的那个大机器，后来就不了了之了。这个副本应该就是守护者奥丁看守的意志熔炉，它最初的名字叫做奥杜亚堡垒，是泰坦守护者们在艾泽拉斯上的主要阵地，它看守的是上古之神尤格隆萨。这里出产的泰坦商品主要有巨人，土灵，发条机械侏儒，魔古，维库人和托维尔。由此可看巨人，矮人，侏儒，魔古，人类，托维尔当属同一厂商出产“商品”。而在现卡利姆多的南端，大地的裂变之后才逐渐被发现的奥丹姆，则是起源熔炉的所在地，这里也是大守护者莱将亚煞极死后的心脏封印起的地方。而在希利苏斯莱建立起来的安其拉堡垒，则是用来囚禁克苏恩的，即是现今的安其拉神殿。这个副本前些时候术士去单刷过，里面的怪长的都很恐怖，一群怪追着你砍的时候画面会很恶心。\n\n![奥丹姆和安其拉](http://upload-images.jianshu.io/upload_images/1429775-e14f06c60aee8276.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样一来，艾泽拉斯的格局形成的很自然，原有生物、两大熔炉造的生物以及外星来客构成魔兽的生物组成，另外原有大陆以及由守护者芙蕾雅打造的“翡翠梦境”构成魔兽的环境组成。我们再来看看著名的“海加尔山”周边的早期格局，永恒之井爆炸后海山在卡利姆多大陆版块，在魔兽世界中至少有两个版本都有在这块地域的副本。它最初是孕育“荒野众神”的地方，像半神众林守护者也是诞生在这里的。这里其实就是一个动物园（众神有白鹿、小精灵之母，剃刀野猪、百鸟主母、巨熊又王、狼、朱鹤、青龙、白虎、玄牛），魔兽中所有与动物有关的神都师出海山。\n\n![海加尔山﻿](http://upload-images.jianshu.io/upload_images/1429775-761ae17b1342352b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n守护者芙蕾雅还第一个发现了元龙，元龙是一些侥幸从元素位面中逃离的元素生物，定居在艾泽后拥有血肉就成了龙的元始形态。\n\n>普及一个知识，不同文化中龙形态有好多种，这里的元龙指的是西方国家的龙形态，西方的龙，主要是在基督教传播的范围内，作为敌对神（或魔）的形象出现，以强大的肉体力量破坏人类的文明，最后被代表上帝的基督教骑士杀死。有种说法，是说龙的出现和灭亡实际上影射了基督教在原始发展过程中与其他原始宗教之间的冲突，最终这些宗教都倒在了基督教作为官方宗教的强大武力（骑士）上。龙的源头，似乎出自圣经，一只七头十角的红色巨龙，象征神之敌撒旦。而且圣经中说那龙便是古蛇，所以说在西方传说的早期，也是龙蛇不分的。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-d054e15e7c8bd109.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>东方的龙，最早是作为一种有智慧的怪兽出现的，比如黄帝驾六龙，说明龙如马一般可以被驯化，又比如禹治水时有应龙（一种有翅膀的龙，不过从形象上看应该是鸟的翅膀而不是蝙蝠的翅膀）为其开通水路。古代传说中的龙形象也并不确定，有龙生九子一说，九子之中的狴犴、饕餮、赑屃、嘲风等等在后来的建筑装饰中都有体现，并不是现在常见的四脚蛇形象。当然龙的主要形象还是与蛇比较接近，在战国时期的雕刻和挂件设计上体现出来的龙，与红山文化的玉龙相差并不多，只不过多了四只脚而已（当然一说红山文化的玉龙实际上是猪崇拜的衍生产物）。东方比较著名的龙的故事是柳毅传，其中的龙可以变换外形，养一种叫雨工的羊形宠物，而且性情很暴力。此外大家对龙的认识更多的来自西游记，其中龙是各种水体中（连井中也算）的一种强力生物，通常统治着其他水生生物，而且爱好收集闪亮的东西（比如金箍棒）。看起来跟西方的龙有点相像了。不过在西游记里，龙是有职业的，那就是降雨。这一点跟西方以火为主要属性的龙就相去甚远了。熊猫人之迷中所引用的原型是中国龙的形态：\n\n![](http://upload-images.jianshu.io/upload_images/1429775-52457e9dc6657aff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>其实在其他文化圈里也有蛇崇拜（由于这些地方并不管它们叫龙，所以只是蛇崇拜）。南美洲的玛雅文化有一个很重要的神就是羽蛇的形象。（有没有觉得跟中国古代那条挖水沟的应龙有点像？）印度教传说大地的基石是一条蛇，其上是乌龟，乌龟上是大象，大象背上有一个盘子，所以这种世界观就叫碟形世界（特里普拉切特著）。埃及的法老头饰上是秃鹫和昂首的眼镜蛇，而且埃及的猫崇拜也跟蛇有关，原因是古代人睡在地上容易压到蛇被咬死，而养猫能防蛇。北欧的著名不正经神洛基的后裔中就有一条蛇，这条蛇只要醒着就不停地啃食世界树，并且其长度横无际涯（洛基的三个孩子都挺有出息的，但可惜都不是什么正面形象）。","slug":"艾泽拉斯早期的世界格局","published":1,"updated":"2018-05-04T10:24:57.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucip9002z1v60gxwse3uf","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-c03ca937f2e8ad28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"早期艾泽拉斯\"></p>\n<p>接下来，长长的分割线，艾泽拉斯的历史从现在才刚刚开始。</p>\n<a id=\"more\"></a>\n<p>永恒之井，这个每个魔兽人都耳熟能详的名字，艾泽拉斯的力量源泉，世界格局形成的引子，牵动着每一个魔兽人的命运。它的形成实际上还得从阿曼苏尔搞坏亚煞极说起，话说老阿叔搞亚煞极的时候搞的有点猛，整个血肉模糊，不仅搞出的伤痕处能量外泻，而且亚煞极的好多血肉也四散到艾泽拉斯的很多地方。这烂摊子自然是得有人来收拾，守护者们把伤口搞好就成了“永恒之井”。另外守护者们为守护艾泽拉斯还建造了两个战争机器，意志熔炉和起源熔炉。这两台机器的作用一是用来看管囚禁起来的上古之神们，另外一个作用是建造泰坦造物们。像后来的人类，矮人，侏儒等生物就是这些泰坦造物演变过来的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-9c8d78c44dccc1cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奥杜亚\"></p>\n<p>魔兽世界北极地区的最上部有一个副本叫做“奥杜尔”，前阶段术士想去单刷来着，结果过不了一片空地上的那个大机器，后来就不了了之了。这个副本应该就是守护者奥丁看守的意志熔炉，它最初的名字叫做奥杜亚堡垒，是泰坦守护者们在艾泽拉斯上的主要阵地，它看守的是上古之神尤格隆萨。这里出产的泰坦商品主要有巨人，土灵，发条机械侏儒，魔古，维库人和托维尔。由此可看巨人，矮人，侏儒，魔古，人类，托维尔当属同一厂商出产“商品”。而在现卡利姆多的南端，大地的裂变之后才逐渐被发现的奥丹姆，则是起源熔炉的所在地，这里也是大守护者莱将亚煞极死后的心脏封印起的地方。而在希利苏斯莱建立起来的安其拉堡垒，则是用来囚禁克苏恩的，即是现今的安其拉神殿。这个副本前些时候术士去单刷过，里面的怪长的都很恐怖，一群怪追着你砍的时候画面会很恶心。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-e14f06c60aee8276.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奥丹姆和安其拉\"></p>\n<p>这样一来，艾泽拉斯的格局形成的很自然，原有生物、两大熔炉造的生物以及外星来客构成魔兽的生物组成，另外原有大陆以及由守护者芙蕾雅打造的“翡翠梦境”构成魔兽的环境组成。我们再来看看著名的“海加尔山”周边的早期格局，永恒之井爆炸后海山在卡利姆多大陆版块，在魔兽世界中至少有两个版本都有在这块地域的副本。它最初是孕育“荒野众神”的地方，像半神众林守护者也是诞生在这里的。这里其实就是一个动物园（众神有白鹿、小精灵之母，剃刀野猪、百鸟主母、巨熊又王、狼、朱鹤、青龙、白虎、玄牛），魔兽中所有与动物有关的神都师出海山。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-761ae17b1342352b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"海加尔山﻿\"></p>\n<p>守护者芙蕾雅还第一个发现了元龙，元龙是一些侥幸从元素位面中逃离的元素生物，定居在艾泽后拥有血肉就成了龙的元始形态。</p>\n<blockquote>\n<p>普及一个知识，不同文化中龙形态有好多种，这里的元龙指的是西方国家的龙形态，西方的龙，主要是在基督教传播的范围内，作为敌对神（或魔）的形象出现，以强大的肉体力量破坏人类的文明，最后被代表上帝的基督教骑士杀死。有种说法，是说龙的出现和灭亡实际上影射了基督教在原始发展过程中与其他原始宗教之间的冲突，最终这些宗教都倒在了基督教作为官方宗教的强大武力（骑士）上。龙的源头，似乎出自圣经，一只七头十角的红色巨龙，象征神之敌撒旦。而且圣经中说那龙便是古蛇，所以说在西方传说的早期，也是龙蛇不分的。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-d054e15e7c8bd109.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>东方的龙，最早是作为一种有智慧的怪兽出现的，比如黄帝驾六龙，说明龙如马一般可以被驯化，又比如禹治水时有应龙（一种有翅膀的龙，不过从形象上看应该是鸟的翅膀而不是蝙蝠的翅膀）为其开通水路。古代传说中的龙形象也并不确定，有龙生九子一说，九子之中的狴犴、饕餮、赑屃、嘲风等等在后来的建筑装饰中都有体现，并不是现在常见的四脚蛇形象。当然龙的主要形象还是与蛇比较接近，在战国时期的雕刻和挂件设计上体现出来的龙，与红山文化的玉龙相差并不多，只不过多了四只脚而已（当然一说红山文化的玉龙实际上是猪崇拜的衍生产物）。东方比较著名的龙的故事是柳毅传，其中的龙可以变换外形，养一种叫雨工的羊形宠物，而且性情很暴力。此外大家对龙的认识更多的来自西游记，其中龙是各种水体中（连井中也算）的一种强力生物，通常统治着其他水生生物，而且爱好收集闪亮的东西（比如金箍棒）。看起来跟西方的龙有点相像了。不过在西游记里，龙是有职业的，那就是降雨。这一点跟西方以火为主要属性的龙就相去甚远了。熊猫人之迷中所引用的原型是中国龙的形态：</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-52457e9dc6657aff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>其实在其他文化圈里也有蛇崇拜（由于这些地方并不管它们叫龙，所以只是蛇崇拜）。南美洲的玛雅文化有一个很重要的神就是羽蛇的形象。（有没有觉得跟中国古代那条挖水沟的应龙有点像？）印度教传说大地的基石是一条蛇，其上是乌龟，乌龟上是大象，大象背上有一个盘子，所以这种世界观就叫碟形世界（特里普拉切特著）。埃及的法老头饰上是秃鹫和昂首的眼镜蛇，而且埃及的猫崇拜也跟蛇有关，原因是古代人睡在地上容易压到蛇被咬死，而养猫能防蛇。北欧的著名不正经神洛基的后裔中就有一条蛇，这条蛇只要醒着就不停地啃食世界树，并且其长度横无际涯（洛基的三个孩子都挺有出息的，但可惜都不是什么正面形象）。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-c03ca937f2e8ad28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"早期艾泽拉斯\"></p>\n<p>接下来，长长的分割线，艾泽拉斯的历史从现在才刚刚开始。</p>","more":"<p>永恒之井，这个每个魔兽人都耳熟能详的名字，艾泽拉斯的力量源泉，世界格局形成的引子，牵动着每一个魔兽人的命运。它的形成实际上还得从阿曼苏尔搞坏亚煞极说起，话说老阿叔搞亚煞极的时候搞的有点猛，整个血肉模糊，不仅搞出的伤痕处能量外泻，而且亚煞极的好多血肉也四散到艾泽拉斯的很多地方。这烂摊子自然是得有人来收拾，守护者们把伤口搞好就成了“永恒之井”。另外守护者们为守护艾泽拉斯还建造了两个战争机器，意志熔炉和起源熔炉。这两台机器的作用一是用来看管囚禁起来的上古之神们，另外一个作用是建造泰坦造物们。像后来的人类，矮人，侏儒等生物就是这些泰坦造物演变过来的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-9c8d78c44dccc1cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奥杜亚\"></p>\n<p>魔兽世界北极地区的最上部有一个副本叫做“奥杜尔”，前阶段术士想去单刷来着，结果过不了一片空地上的那个大机器，后来就不了了之了。这个副本应该就是守护者奥丁看守的意志熔炉，它最初的名字叫做奥杜亚堡垒，是泰坦守护者们在艾泽拉斯上的主要阵地，它看守的是上古之神尤格隆萨。这里出产的泰坦商品主要有巨人，土灵，发条机械侏儒，魔古，维库人和托维尔。由此可看巨人，矮人，侏儒，魔古，人类，托维尔当属同一厂商出产“商品”。而在现卡利姆多的南端，大地的裂变之后才逐渐被发现的奥丹姆，则是起源熔炉的所在地，这里也是大守护者莱将亚煞极死后的心脏封印起的地方。而在希利苏斯莱建立起来的安其拉堡垒，则是用来囚禁克苏恩的，即是现今的安其拉神殿。这个副本前些时候术士去单刷过，里面的怪长的都很恐怖，一群怪追着你砍的时候画面会很恶心。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-e14f06c60aee8276.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"奥丹姆和安其拉\"></p>\n<p>这样一来，艾泽拉斯的格局形成的很自然，原有生物、两大熔炉造的生物以及外星来客构成魔兽的生物组成，另外原有大陆以及由守护者芙蕾雅打造的“翡翠梦境”构成魔兽的环境组成。我们再来看看著名的“海加尔山”周边的早期格局，永恒之井爆炸后海山在卡利姆多大陆版块，在魔兽世界中至少有两个版本都有在这块地域的副本。它最初是孕育“荒野众神”的地方，像半神众林守护者也是诞生在这里的。这里其实就是一个动物园（众神有白鹿、小精灵之母，剃刀野猪、百鸟主母、巨熊又王、狼、朱鹤、青龙、白虎、玄牛），魔兽中所有与动物有关的神都师出海山。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-761ae17b1342352b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"海加尔山﻿\"></p>\n<p>守护者芙蕾雅还第一个发现了元龙，元龙是一些侥幸从元素位面中逃离的元素生物，定居在艾泽后拥有血肉就成了龙的元始形态。</p>\n<blockquote>\n<p>普及一个知识，不同文化中龙形态有好多种，这里的元龙指的是西方国家的龙形态，西方的龙，主要是在基督教传播的范围内，作为敌对神（或魔）的形象出现，以强大的肉体力量破坏人类的文明，最后被代表上帝的基督教骑士杀死。有种说法，是说龙的出现和灭亡实际上影射了基督教在原始发展过程中与其他原始宗教之间的冲突，最终这些宗教都倒在了基督教作为官方宗教的强大武力（骑士）上。龙的源头，似乎出自圣经，一只七头十角的红色巨龙，象征神之敌撒旦。而且圣经中说那龙便是古蛇，所以说在西方传说的早期，也是龙蛇不分的。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-d054e15e7c8bd109.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>东方的龙，最早是作为一种有智慧的怪兽出现的，比如黄帝驾六龙，说明龙如马一般可以被驯化，又比如禹治水时有应龙（一种有翅膀的龙，不过从形象上看应该是鸟的翅膀而不是蝙蝠的翅膀）为其开通水路。古代传说中的龙形象也并不确定，有龙生九子一说，九子之中的狴犴、饕餮、赑屃、嘲风等等在后来的建筑装饰中都有体现，并不是现在常见的四脚蛇形象。当然龙的主要形象还是与蛇比较接近，在战国时期的雕刻和挂件设计上体现出来的龙，与红山文化的玉龙相差并不多，只不过多了四只脚而已（当然一说红山文化的玉龙实际上是猪崇拜的衍生产物）。东方比较著名的龙的故事是柳毅传，其中的龙可以变换外形，养一种叫雨工的羊形宠物，而且性情很暴力。此外大家对龙的认识更多的来自西游记，其中龙是各种水体中（连井中也算）的一种强力生物，通常统治着其他水生生物，而且爱好收集闪亮的东西（比如金箍棒）。看起来跟西方的龙有点相像了。不过在西游记里，龙是有职业的，那就是降雨。这一点跟西方以火为主要属性的龙就相去甚远了。熊猫人之迷中所引用的原型是中国龙的形态：</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-52457e9dc6657aff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>其实在其他文化圈里也有蛇崇拜（由于这些地方并不管它们叫龙，所以只是蛇崇拜）。南美洲的玛雅文化有一个很重要的神就是羽蛇的形象。（有没有觉得跟中国古代那条挖水沟的应龙有点像？）印度教传说大地的基石是一条蛇，其上是乌龟，乌龟上是大象，大象背上有一个盘子，所以这种世界观就叫碟形世界（特里普拉切特著）。埃及的法老头饰上是秃鹫和昂首的眼镜蛇，而且埃及的猫崇拜也跟蛇有关，原因是古代人睡在地上容易压到蛇被咬死，而养猫能防蛇。北欧的著名不正经神洛基的后裔中就有一条蛇，这条蛇只要醒着就不停地啃食世界树，并且其长度横无际涯（洛基的三个孩子都挺有出息的，但可惜都不是什么正面形象）。</p>\n</blockquote>"},{"title":"魔兽宝强的故事：小三与兄弟反目","date":"2016-08-15T01:14:00.000Z","_content":"\n![图文无关](http://upload-images.jianshu.io/upload_images/1429775-2022566bf6385928.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最近我们强哥在娱乐圈的新闻甚是火热，我们也不好说什么，那毕竟是人家的家事，我们带着一种善意的眼光去看好了，希望事情能够得到很好的处理。其实背叛这件事情，在魔兽中也有很多，今天我们就来讲一讲魔兽世界守护者之间的一件关于背叛的故事。\n\n<!-- more -->\n\n很多电视剧都会告诉我们一个道理，孤注一掷的人会自食恶果。今天介绍的两位继承者，都不约而同的证明了这个道理。\n\n奥丁本来是守护者中最为有能力的一个，而且作为守护者的领袖，他本来是可以领导着他的守护者同伴建立一个更加美好的艾泽拉斯。然而作为领袖总是孤独的，没人能真正的理解他，于是这样的情绪在他的内心滋生，造就了他的一意孤行。奥丁决定用他自己的力量创造一个军队来拯救他心目中的艾泽拉斯，来完成泰坦们交给他的任务。\n\n于是奥丁离开了他们同伴，带领着强而有力的维库人，在奥杜亚开始建立起了自己的根据地。他找到了女巫海尔雅（同是泰坦造物）并依靠她的法力在奥杜亚的顶端建立了一座堡垒，起了个好听的名字，英灵殿。这个英灵殿可了不得，在这里可以让死去的维库人重生，转换为瓦格里（大致就是一种鬼魂类的生物）。所以很明显的，奥丁这哥们是入了魔道。貌似新的1.0版本会有英灵殿五人副本哦。\n\n奥丁的这种造物行为最后使他陷入了疯狂，他大肆屠杀维库人将其改造成瓦格里。女巫海尔雅出面阻止，奥丁便将她也变成了瓦格里，并让海尔雅遭受诅咒，领导他的瓦格里大军。但是这支队伍在后来也并没有干什么正事，反倒是为艾泽拉斯的物种丰富度做了点贡献。\n\n奥丁走向堕落的道路一切都是因为他性格中的自负，而守护者洛肯却是因为他的好色。所以，这两个人的故事还告诉我们，无论是来自外界的还是自身的缺陷我们都要时刻警惕，否则不是自取灭亡就是被人利用，结局很惨的。\n\n在魔兽世界中，巫妖王之怒五人副本闪电大厅的最终Boss就是洛肯。不得不说啊，这么一个守护者精英被放在一个五人本里，的确有点屈才。这里吐槽一句，为什么守护者们连个十人副本都没有，看来暴雪是把所有厉害角色都压在了燃烧军团身上了。\n\n之前说到上古之神尤格隆萨（我们称小尤）被守护者们打败并被封印在了奥杜亚监狱里，并受意志熔炉的控制。当然我们的邪神怎么会消停呢，他把目光聚焦在了洛肯的身上。而这个洛肯呢由于好色，搞了他兄弟索林姆的女人希芙，一个维库女人（看来他兄弟是找了一个自己造出来的后代当女朋友，这关系也够乱的）。男人当了小三跟女人是一样的，也是想着上位取代正宫。希芙一看，这不行，哪能让你这么乱来，我的美好生活还没开始呢。于是希芙就立马不跟洛肯联系了，这女人翻起脸来就是快，不过洛肯在希芙这顶多也就算个炮友，踢了就踢了。洛肯面对希芙的背叛很是恼火，我堂堂天神守护者，你把老子当什么？没多久就把希芙给弄死了（这个故事告诫我们，想要找小三，必须得找个实力不行的，否则死的不知道就是谁了）。\n\n希芙是死了，洛肯害怕了。他想，这索林姆知道他兄弟把他女人搞了，搞完还给弄死了，这不论哪件事都够他死一万次。但是洛肯怎么也是一个守护者，索林姆跟他打顶多也就打个平手，只是怎么说也是自己做错事情，所以想着一定不能让他兄弟知道。在这个时候，我们的小尤上场了，他幻化出了希芙的鬼魂，接触洛肯，让洛肯就范。然后顺理成章地洛肯受鬼魂指使抛尸希芙，嫁祸给冰巨人安格里姆，激怒了索林姆屠戮冰巨人，驱逐索林姆，建造军队接管奥杜亚，镇压巨人。这么一系列事情做完后，洛肯被顺利的腐化了。这个故事告诉我们你用一个错误去掩盖另一个错误，你就无法判断是非对错了。\n\n小尤顺利的完成了他的计划，洛肯背叛组织，索林姆离开，奥丁做起了自己天空之国的梦。整个守护者群能战斗的也没几个了。然而更坏的情况是，洛肯这小子心想既然都这样了，那就破罐子破摔吧，他了解到自己是被上古大神利用后反过来染指邪神的力量，企图壮大自己。我们不得不说坏人的脑子其实是好用的，他们会根据自身情况迅速做出最有利自己的反映，这样看来一个人如果太自私了，反倒不是一件好事。\n\n于是洛肯为了消除自己的罪证，彻底开始背叛守护者。首先他先要对付的是在奥杜亚上面的奥丁，方法呢还是利用内部人的嫌隙，他清楚海尔雅被奥丁转化为瓦格里的不满，联合海尔雅将奥丁封印在了英灵殿，这样洛肯进也进不去，奥丁出也出不来，反倒是件好事。在这里说一下影之国的出现，海尔雅帮洛肯封印了奥丁后带领着那些鬼魂建立了影之国，这在魔兽世界中似乎还未曾见过（自己没太注意），她的随从叫做科瓦迪尔，回头可以再去游戏里与奥丁有关的地方找一下。\n\n说回洛肯，接下来他要解决的就是米米隆，过程很顺利，不过有个小插曲就是米米隆的机械侏儒们把主人的灵魂保存了下来，还制造了一个机械模型保存着主人的灵魂，就是我们在游戏里去奥杜亚刷的那个坐骑。洛肯联合小尤在芙蕾雅的生命神殿打败了她，芙蕾雅痴呆，被关在了奥杜亚。下一步，洛肯袭击霍迪尔据点冬日神殿，霍迪尔被俘，被囚禁在了奥杜亚冰封大厅里。\n\n截止到目前，战斗成功四次，俘获或杀死敌将四人，不得不说，洛肯是一个不错的军事家。守护者中唯一逃掉的就是提尔和阿扎达斯，而这两位被盟友女巨人艾隆纳亚所救。守护者莱不知所踪。守护者团体死的死，逃的逃，已经没有了守护艾泽拉斯的能力。上古之神正式开始策划逃亡。洛肯封闭奥杜亚，以此来阻挡逃掉守护者的反击。\n\n洛肯在解决完各守护者后，唯一害怕的就是诺甘农圆盘，说到这个诺甘农圆盘，我们知道它是一个神器，是当初泰坦们为了记录艾泽拉斯上发生的事情布置在艾泽拉斯上的。它就像一个摄影机，守护者们做的所有事都记了下来。洛肯想，万一哪天泰坦大大们回来，调一下诺甘农的监控（不得不说泰坦的科技文明很了得），自己横竖都是个死。但是洛肯还是晚了一步，提尔在他前就想到了这一点，提尔盗取了圆盘并逃跑。洛肯没办法，请了个“黑客”伪造了圆盘（不过这个新造的系统貌似有病毒，总之不稳定），并派刺客追杀提尔残部。\n\n这刺客团可不得了，它们是，上古神克瑟拉基扎卡兹和基希克斯。这里有一点说明，这些上古神的名字好多在炉石传说中也看到过，不过它们的名字出现都不是很多，本来这整个魔兽世界历史在燃烧军团第一次入侵前就不是很详细，人物设定也不是很清晰，所以很多都一笔带过。说回提尔，刺客团与提尔当然是展开了大战，提尔牺牲，扎卡兹死亡，基希克斯重伤之后无战斗力逃往了西方。为了纪念提尔，艾隆纳亚将提尔死的地方命名为“提尔之陨”，就是“提瑞斯法”的意思，地方就是魔兽幽暗城附近的提瑞斯法林地，维库人在此生存了下来，以守护他们心目中英雄的灵魂。而阿扎达斯和艾隆纳亚一直南下，建立了奥达曼，并在内室贮存了诺甘农圆盘，阿扎达斯为了保护这个神器，在内部封印了奥达曼。\n\n最后洛肯要解决的就是阿加隆，未了确保自身的安全，它切断了艾泽拉斯的安全隐患阿加隆与艾泽拉斯的联系，保证不至达到连同自己整个被毁掉。\n\n至此，守护者之战结束。各大守护者相继失去了对抗艾泽拉斯外两大邪恶组织的能力，一旦恶魔们开始入侵，艾泽拉斯的命运，将不再由守护者们守候。接下来一批又一批的种族开始繁衍，艾泽拉斯进入后守护者时期。","source":"_posts/魔兽宝强的故事——小三与兄弟反目.md","raw":"title: 魔兽宝强的故事：小三与兄弟反目\ndate: 2016-08-15 09:14:00\ncategories: Azeroth\n-----------\n\n![图文无关](http://upload-images.jianshu.io/upload_images/1429775-2022566bf6385928.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最近我们强哥在娱乐圈的新闻甚是火热，我们也不好说什么，那毕竟是人家的家事，我们带着一种善意的眼光去看好了，希望事情能够得到很好的处理。其实背叛这件事情，在魔兽中也有很多，今天我们就来讲一讲魔兽世界守护者之间的一件关于背叛的故事。\n\n<!-- more -->\n\n很多电视剧都会告诉我们一个道理，孤注一掷的人会自食恶果。今天介绍的两位继承者，都不约而同的证明了这个道理。\n\n奥丁本来是守护者中最为有能力的一个，而且作为守护者的领袖，他本来是可以领导着他的守护者同伴建立一个更加美好的艾泽拉斯。然而作为领袖总是孤独的，没人能真正的理解他，于是这样的情绪在他的内心滋生，造就了他的一意孤行。奥丁决定用他自己的力量创造一个军队来拯救他心目中的艾泽拉斯，来完成泰坦们交给他的任务。\n\n于是奥丁离开了他们同伴，带领着强而有力的维库人，在奥杜亚开始建立起了自己的根据地。他找到了女巫海尔雅（同是泰坦造物）并依靠她的法力在奥杜亚的顶端建立了一座堡垒，起了个好听的名字，英灵殿。这个英灵殿可了不得，在这里可以让死去的维库人重生，转换为瓦格里（大致就是一种鬼魂类的生物）。所以很明显的，奥丁这哥们是入了魔道。貌似新的1.0版本会有英灵殿五人副本哦。\n\n奥丁的这种造物行为最后使他陷入了疯狂，他大肆屠杀维库人将其改造成瓦格里。女巫海尔雅出面阻止，奥丁便将她也变成了瓦格里，并让海尔雅遭受诅咒，领导他的瓦格里大军。但是这支队伍在后来也并没有干什么正事，反倒是为艾泽拉斯的物种丰富度做了点贡献。\n\n奥丁走向堕落的道路一切都是因为他性格中的自负，而守护者洛肯却是因为他的好色。所以，这两个人的故事还告诉我们，无论是来自外界的还是自身的缺陷我们都要时刻警惕，否则不是自取灭亡就是被人利用，结局很惨的。\n\n在魔兽世界中，巫妖王之怒五人副本闪电大厅的最终Boss就是洛肯。不得不说啊，这么一个守护者精英被放在一个五人本里，的确有点屈才。这里吐槽一句，为什么守护者们连个十人副本都没有，看来暴雪是把所有厉害角色都压在了燃烧军团身上了。\n\n之前说到上古之神尤格隆萨（我们称小尤）被守护者们打败并被封印在了奥杜亚监狱里，并受意志熔炉的控制。当然我们的邪神怎么会消停呢，他把目光聚焦在了洛肯的身上。而这个洛肯呢由于好色，搞了他兄弟索林姆的女人希芙，一个维库女人（看来他兄弟是找了一个自己造出来的后代当女朋友，这关系也够乱的）。男人当了小三跟女人是一样的，也是想着上位取代正宫。希芙一看，这不行，哪能让你这么乱来，我的美好生活还没开始呢。于是希芙就立马不跟洛肯联系了，这女人翻起脸来就是快，不过洛肯在希芙这顶多也就算个炮友，踢了就踢了。洛肯面对希芙的背叛很是恼火，我堂堂天神守护者，你把老子当什么？没多久就把希芙给弄死了（这个故事告诫我们，想要找小三，必须得找个实力不行的，否则死的不知道就是谁了）。\n\n希芙是死了，洛肯害怕了。他想，这索林姆知道他兄弟把他女人搞了，搞完还给弄死了，这不论哪件事都够他死一万次。但是洛肯怎么也是一个守护者，索林姆跟他打顶多也就打个平手，只是怎么说也是自己做错事情，所以想着一定不能让他兄弟知道。在这个时候，我们的小尤上场了，他幻化出了希芙的鬼魂，接触洛肯，让洛肯就范。然后顺理成章地洛肯受鬼魂指使抛尸希芙，嫁祸给冰巨人安格里姆，激怒了索林姆屠戮冰巨人，驱逐索林姆，建造军队接管奥杜亚，镇压巨人。这么一系列事情做完后，洛肯被顺利的腐化了。这个故事告诉我们你用一个错误去掩盖另一个错误，你就无法判断是非对错了。\n\n小尤顺利的完成了他的计划，洛肯背叛组织，索林姆离开，奥丁做起了自己天空之国的梦。整个守护者群能战斗的也没几个了。然而更坏的情况是，洛肯这小子心想既然都这样了，那就破罐子破摔吧，他了解到自己是被上古大神利用后反过来染指邪神的力量，企图壮大自己。我们不得不说坏人的脑子其实是好用的，他们会根据自身情况迅速做出最有利自己的反映，这样看来一个人如果太自私了，反倒不是一件好事。\n\n于是洛肯为了消除自己的罪证，彻底开始背叛守护者。首先他先要对付的是在奥杜亚上面的奥丁，方法呢还是利用内部人的嫌隙，他清楚海尔雅被奥丁转化为瓦格里的不满，联合海尔雅将奥丁封印在了英灵殿，这样洛肯进也进不去，奥丁出也出不来，反倒是件好事。在这里说一下影之国的出现，海尔雅帮洛肯封印了奥丁后带领着那些鬼魂建立了影之国，这在魔兽世界中似乎还未曾见过（自己没太注意），她的随从叫做科瓦迪尔，回头可以再去游戏里与奥丁有关的地方找一下。\n\n说回洛肯，接下来他要解决的就是米米隆，过程很顺利，不过有个小插曲就是米米隆的机械侏儒们把主人的灵魂保存了下来，还制造了一个机械模型保存着主人的灵魂，就是我们在游戏里去奥杜亚刷的那个坐骑。洛肯联合小尤在芙蕾雅的生命神殿打败了她，芙蕾雅痴呆，被关在了奥杜亚。下一步，洛肯袭击霍迪尔据点冬日神殿，霍迪尔被俘，被囚禁在了奥杜亚冰封大厅里。\n\n截止到目前，战斗成功四次，俘获或杀死敌将四人，不得不说，洛肯是一个不错的军事家。守护者中唯一逃掉的就是提尔和阿扎达斯，而这两位被盟友女巨人艾隆纳亚所救。守护者莱不知所踪。守护者团体死的死，逃的逃，已经没有了守护艾泽拉斯的能力。上古之神正式开始策划逃亡。洛肯封闭奥杜亚，以此来阻挡逃掉守护者的反击。\n\n洛肯在解决完各守护者后，唯一害怕的就是诺甘农圆盘，说到这个诺甘农圆盘，我们知道它是一个神器，是当初泰坦们为了记录艾泽拉斯上发生的事情布置在艾泽拉斯上的。它就像一个摄影机，守护者们做的所有事都记了下来。洛肯想，万一哪天泰坦大大们回来，调一下诺甘农的监控（不得不说泰坦的科技文明很了得），自己横竖都是个死。但是洛肯还是晚了一步，提尔在他前就想到了这一点，提尔盗取了圆盘并逃跑。洛肯没办法，请了个“黑客”伪造了圆盘（不过这个新造的系统貌似有病毒，总之不稳定），并派刺客追杀提尔残部。\n\n这刺客团可不得了，它们是，上古神克瑟拉基扎卡兹和基希克斯。这里有一点说明，这些上古神的名字好多在炉石传说中也看到过，不过它们的名字出现都不是很多，本来这整个魔兽世界历史在燃烧军团第一次入侵前就不是很详细，人物设定也不是很清晰，所以很多都一笔带过。说回提尔，刺客团与提尔当然是展开了大战，提尔牺牲，扎卡兹死亡，基希克斯重伤之后无战斗力逃往了西方。为了纪念提尔，艾隆纳亚将提尔死的地方命名为“提尔之陨”，就是“提瑞斯法”的意思，地方就是魔兽幽暗城附近的提瑞斯法林地，维库人在此生存了下来，以守护他们心目中英雄的灵魂。而阿扎达斯和艾隆纳亚一直南下，建立了奥达曼，并在内室贮存了诺甘农圆盘，阿扎达斯为了保护这个神器，在内部封印了奥达曼。\n\n最后洛肯要解决的就是阿加隆，未了确保自身的安全，它切断了艾泽拉斯的安全隐患阿加隆与艾泽拉斯的联系，保证不至达到连同自己整个被毁掉。\n\n至此，守护者之战结束。各大守护者相继失去了对抗艾泽拉斯外两大邪恶组织的能力，一旦恶魔们开始入侵，艾泽拉斯的命运，将不再由守护者们守候。接下来一批又一批的种族开始繁衍，艾泽拉斯进入后守护者时期。","slug":"魔兽宝强的故事——小三与兄弟反目","published":1,"updated":"2018-05-04T10:25:39.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucipb00321v606gxejslo","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-2022566bf6385928.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图文无关\"></p>\n<p>最近我们强哥在娱乐圈的新闻甚是火热，我们也不好说什么，那毕竟是人家的家事，我们带着一种善意的眼光去看好了，希望事情能够得到很好的处理。其实背叛这件事情，在魔兽中也有很多，今天我们就来讲一讲魔兽世界守护者之间的一件关于背叛的故事。</p>\n<a id=\"more\"></a>\n<p>很多电视剧都会告诉我们一个道理，孤注一掷的人会自食恶果。今天介绍的两位继承者，都不约而同的证明了这个道理。</p>\n<p>奥丁本来是守护者中最为有能力的一个，而且作为守护者的领袖，他本来是可以领导着他的守护者同伴建立一个更加美好的艾泽拉斯。然而作为领袖总是孤独的，没人能真正的理解他，于是这样的情绪在他的内心滋生，造就了他的一意孤行。奥丁决定用他自己的力量创造一个军队来拯救他心目中的艾泽拉斯，来完成泰坦们交给他的任务。</p>\n<p>于是奥丁离开了他们同伴，带领着强而有力的维库人，在奥杜亚开始建立起了自己的根据地。他找到了女巫海尔雅（同是泰坦造物）并依靠她的法力在奥杜亚的顶端建立了一座堡垒，起了个好听的名字，英灵殿。这个英灵殿可了不得，在这里可以让死去的维库人重生，转换为瓦格里（大致就是一种鬼魂类的生物）。所以很明显的，奥丁这哥们是入了魔道。貌似新的1.0版本会有英灵殿五人副本哦。</p>\n<p>奥丁的这种造物行为最后使他陷入了疯狂，他大肆屠杀维库人将其改造成瓦格里。女巫海尔雅出面阻止，奥丁便将她也变成了瓦格里，并让海尔雅遭受诅咒，领导他的瓦格里大军。但是这支队伍在后来也并没有干什么正事，反倒是为艾泽拉斯的物种丰富度做了点贡献。</p>\n<p>奥丁走向堕落的道路一切都是因为他性格中的自负，而守护者洛肯却是因为他的好色。所以，这两个人的故事还告诉我们，无论是来自外界的还是自身的缺陷我们都要时刻警惕，否则不是自取灭亡就是被人利用，结局很惨的。</p>\n<p>在魔兽世界中，巫妖王之怒五人副本闪电大厅的最终Boss就是洛肯。不得不说啊，这么一个守护者精英被放在一个五人本里，的确有点屈才。这里吐槽一句，为什么守护者们连个十人副本都没有，看来暴雪是把所有厉害角色都压在了燃烧军团身上了。</p>\n<p>之前说到上古之神尤格隆萨（我们称小尤）被守护者们打败并被封印在了奥杜亚监狱里，并受意志熔炉的控制。当然我们的邪神怎么会消停呢，他把目光聚焦在了洛肯的身上。而这个洛肯呢由于好色，搞了他兄弟索林姆的女人希芙，一个维库女人（看来他兄弟是找了一个自己造出来的后代当女朋友，这关系也够乱的）。男人当了小三跟女人是一样的，也是想着上位取代正宫。希芙一看，这不行，哪能让你这么乱来，我的美好生活还没开始呢。于是希芙就立马不跟洛肯联系了，这女人翻起脸来就是快，不过洛肯在希芙这顶多也就算个炮友，踢了就踢了。洛肯面对希芙的背叛很是恼火，我堂堂天神守护者，你把老子当什么？没多久就把希芙给弄死了（这个故事告诫我们，想要找小三，必须得找个实力不行的，否则死的不知道就是谁了）。</p>\n<p>希芙是死了，洛肯害怕了。他想，这索林姆知道他兄弟把他女人搞了，搞完还给弄死了，这不论哪件事都够他死一万次。但是洛肯怎么也是一个守护者，索林姆跟他打顶多也就打个平手，只是怎么说也是自己做错事情，所以想着一定不能让他兄弟知道。在这个时候，我们的小尤上场了，他幻化出了希芙的鬼魂，接触洛肯，让洛肯就范。然后顺理成章地洛肯受鬼魂指使抛尸希芙，嫁祸给冰巨人安格里姆，激怒了索林姆屠戮冰巨人，驱逐索林姆，建造军队接管奥杜亚，镇压巨人。这么一系列事情做完后，洛肯被顺利的腐化了。这个故事告诉我们你用一个错误去掩盖另一个错误，你就无法判断是非对错了。</p>\n<p>小尤顺利的完成了他的计划，洛肯背叛组织，索林姆离开，奥丁做起了自己天空之国的梦。整个守护者群能战斗的也没几个了。然而更坏的情况是，洛肯这小子心想既然都这样了，那就破罐子破摔吧，他了解到自己是被上古大神利用后反过来染指邪神的力量，企图壮大自己。我们不得不说坏人的脑子其实是好用的，他们会根据自身情况迅速做出最有利自己的反映，这样看来一个人如果太自私了，反倒不是一件好事。</p>\n<p>于是洛肯为了消除自己的罪证，彻底开始背叛守护者。首先他先要对付的是在奥杜亚上面的奥丁，方法呢还是利用内部人的嫌隙，他清楚海尔雅被奥丁转化为瓦格里的不满，联合海尔雅将奥丁封印在了英灵殿，这样洛肯进也进不去，奥丁出也出不来，反倒是件好事。在这里说一下影之国的出现，海尔雅帮洛肯封印了奥丁后带领着那些鬼魂建立了影之国，这在魔兽世界中似乎还未曾见过（自己没太注意），她的随从叫做科瓦迪尔，回头可以再去游戏里与奥丁有关的地方找一下。</p>\n<p>说回洛肯，接下来他要解决的就是米米隆，过程很顺利，不过有个小插曲就是米米隆的机械侏儒们把主人的灵魂保存了下来，还制造了一个机械模型保存着主人的灵魂，就是我们在游戏里去奥杜亚刷的那个坐骑。洛肯联合小尤在芙蕾雅的生命神殿打败了她，芙蕾雅痴呆，被关在了奥杜亚。下一步，洛肯袭击霍迪尔据点冬日神殿，霍迪尔被俘，被囚禁在了奥杜亚冰封大厅里。</p>\n<p>截止到目前，战斗成功四次，俘获或杀死敌将四人，不得不说，洛肯是一个不错的军事家。守护者中唯一逃掉的就是提尔和阿扎达斯，而这两位被盟友女巨人艾隆纳亚所救。守护者莱不知所踪。守护者团体死的死，逃的逃，已经没有了守护艾泽拉斯的能力。上古之神正式开始策划逃亡。洛肯封闭奥杜亚，以此来阻挡逃掉守护者的反击。</p>\n<p>洛肯在解决完各守护者后，唯一害怕的就是诺甘农圆盘，说到这个诺甘农圆盘，我们知道它是一个神器，是当初泰坦们为了记录艾泽拉斯上发生的事情布置在艾泽拉斯上的。它就像一个摄影机，守护者们做的所有事都记了下来。洛肯想，万一哪天泰坦大大们回来，调一下诺甘农的监控（不得不说泰坦的科技文明很了得），自己横竖都是个死。但是洛肯还是晚了一步，提尔在他前就想到了这一点，提尔盗取了圆盘并逃跑。洛肯没办法，请了个“黑客”伪造了圆盘（不过这个新造的系统貌似有病毒，总之不稳定），并派刺客追杀提尔残部。</p>\n<p>这刺客团可不得了，它们是，上古神克瑟拉基扎卡兹和基希克斯。这里有一点说明，这些上古神的名字好多在炉石传说中也看到过，不过它们的名字出现都不是很多，本来这整个魔兽世界历史在燃烧军团第一次入侵前就不是很详细，人物设定也不是很清晰，所以很多都一笔带过。说回提尔，刺客团与提尔当然是展开了大战，提尔牺牲，扎卡兹死亡，基希克斯重伤之后无战斗力逃往了西方。为了纪念提尔，艾隆纳亚将提尔死的地方命名为“提尔之陨”，就是“提瑞斯法”的意思，地方就是魔兽幽暗城附近的提瑞斯法林地，维库人在此生存了下来，以守护他们心目中英雄的灵魂。而阿扎达斯和艾隆纳亚一直南下，建立了奥达曼，并在内室贮存了诺甘农圆盘，阿扎达斯为了保护这个神器，在内部封印了奥达曼。</p>\n<p>最后洛肯要解决的就是阿加隆，未了确保自身的安全，它切断了艾泽拉斯的安全隐患阿加隆与艾泽拉斯的联系，保证不至达到连同自己整个被毁掉。</p>\n<p>至此，守护者之战结束。各大守护者相继失去了对抗艾泽拉斯外两大邪恶组织的能力，一旦恶魔们开始入侵，艾泽拉斯的命运，将不再由守护者们守候。接下来一批又一批的种族开始繁衍，艾泽拉斯进入后守护者时期。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-2022566bf6385928.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图文无关\"></p>\n<p>最近我们强哥在娱乐圈的新闻甚是火热，我们也不好说什么，那毕竟是人家的家事，我们带着一种善意的眼光去看好了，希望事情能够得到很好的处理。其实背叛这件事情，在魔兽中也有很多，今天我们就来讲一讲魔兽世界守护者之间的一件关于背叛的故事。</p>","more":"<p>很多电视剧都会告诉我们一个道理，孤注一掷的人会自食恶果。今天介绍的两位继承者，都不约而同的证明了这个道理。</p>\n<p>奥丁本来是守护者中最为有能力的一个，而且作为守护者的领袖，他本来是可以领导着他的守护者同伴建立一个更加美好的艾泽拉斯。然而作为领袖总是孤独的，没人能真正的理解他，于是这样的情绪在他的内心滋生，造就了他的一意孤行。奥丁决定用他自己的力量创造一个军队来拯救他心目中的艾泽拉斯，来完成泰坦们交给他的任务。</p>\n<p>于是奥丁离开了他们同伴，带领着强而有力的维库人，在奥杜亚开始建立起了自己的根据地。他找到了女巫海尔雅（同是泰坦造物）并依靠她的法力在奥杜亚的顶端建立了一座堡垒，起了个好听的名字，英灵殿。这个英灵殿可了不得，在这里可以让死去的维库人重生，转换为瓦格里（大致就是一种鬼魂类的生物）。所以很明显的，奥丁这哥们是入了魔道。貌似新的1.0版本会有英灵殿五人副本哦。</p>\n<p>奥丁的这种造物行为最后使他陷入了疯狂，他大肆屠杀维库人将其改造成瓦格里。女巫海尔雅出面阻止，奥丁便将她也变成了瓦格里，并让海尔雅遭受诅咒，领导他的瓦格里大军。但是这支队伍在后来也并没有干什么正事，反倒是为艾泽拉斯的物种丰富度做了点贡献。</p>\n<p>奥丁走向堕落的道路一切都是因为他性格中的自负，而守护者洛肯却是因为他的好色。所以，这两个人的故事还告诉我们，无论是来自外界的还是自身的缺陷我们都要时刻警惕，否则不是自取灭亡就是被人利用，结局很惨的。</p>\n<p>在魔兽世界中，巫妖王之怒五人副本闪电大厅的最终Boss就是洛肯。不得不说啊，这么一个守护者精英被放在一个五人本里，的确有点屈才。这里吐槽一句，为什么守护者们连个十人副本都没有，看来暴雪是把所有厉害角色都压在了燃烧军团身上了。</p>\n<p>之前说到上古之神尤格隆萨（我们称小尤）被守护者们打败并被封印在了奥杜亚监狱里，并受意志熔炉的控制。当然我们的邪神怎么会消停呢，他把目光聚焦在了洛肯的身上。而这个洛肯呢由于好色，搞了他兄弟索林姆的女人希芙，一个维库女人（看来他兄弟是找了一个自己造出来的后代当女朋友，这关系也够乱的）。男人当了小三跟女人是一样的，也是想着上位取代正宫。希芙一看，这不行，哪能让你这么乱来，我的美好生活还没开始呢。于是希芙就立马不跟洛肯联系了，这女人翻起脸来就是快，不过洛肯在希芙这顶多也就算个炮友，踢了就踢了。洛肯面对希芙的背叛很是恼火，我堂堂天神守护者，你把老子当什么？没多久就把希芙给弄死了（这个故事告诫我们，想要找小三，必须得找个实力不行的，否则死的不知道就是谁了）。</p>\n<p>希芙是死了，洛肯害怕了。他想，这索林姆知道他兄弟把他女人搞了，搞完还给弄死了，这不论哪件事都够他死一万次。但是洛肯怎么也是一个守护者，索林姆跟他打顶多也就打个平手，只是怎么说也是自己做错事情，所以想着一定不能让他兄弟知道。在这个时候，我们的小尤上场了，他幻化出了希芙的鬼魂，接触洛肯，让洛肯就范。然后顺理成章地洛肯受鬼魂指使抛尸希芙，嫁祸给冰巨人安格里姆，激怒了索林姆屠戮冰巨人，驱逐索林姆，建造军队接管奥杜亚，镇压巨人。这么一系列事情做完后，洛肯被顺利的腐化了。这个故事告诉我们你用一个错误去掩盖另一个错误，你就无法判断是非对错了。</p>\n<p>小尤顺利的完成了他的计划，洛肯背叛组织，索林姆离开，奥丁做起了自己天空之国的梦。整个守护者群能战斗的也没几个了。然而更坏的情况是，洛肯这小子心想既然都这样了，那就破罐子破摔吧，他了解到自己是被上古大神利用后反过来染指邪神的力量，企图壮大自己。我们不得不说坏人的脑子其实是好用的，他们会根据自身情况迅速做出最有利自己的反映，这样看来一个人如果太自私了，反倒不是一件好事。</p>\n<p>于是洛肯为了消除自己的罪证，彻底开始背叛守护者。首先他先要对付的是在奥杜亚上面的奥丁，方法呢还是利用内部人的嫌隙，他清楚海尔雅被奥丁转化为瓦格里的不满，联合海尔雅将奥丁封印在了英灵殿，这样洛肯进也进不去，奥丁出也出不来，反倒是件好事。在这里说一下影之国的出现，海尔雅帮洛肯封印了奥丁后带领着那些鬼魂建立了影之国，这在魔兽世界中似乎还未曾见过（自己没太注意），她的随从叫做科瓦迪尔，回头可以再去游戏里与奥丁有关的地方找一下。</p>\n<p>说回洛肯，接下来他要解决的就是米米隆，过程很顺利，不过有个小插曲就是米米隆的机械侏儒们把主人的灵魂保存了下来，还制造了一个机械模型保存着主人的灵魂，就是我们在游戏里去奥杜亚刷的那个坐骑。洛肯联合小尤在芙蕾雅的生命神殿打败了她，芙蕾雅痴呆，被关在了奥杜亚。下一步，洛肯袭击霍迪尔据点冬日神殿，霍迪尔被俘，被囚禁在了奥杜亚冰封大厅里。</p>\n<p>截止到目前，战斗成功四次，俘获或杀死敌将四人，不得不说，洛肯是一个不错的军事家。守护者中唯一逃掉的就是提尔和阿扎达斯，而这两位被盟友女巨人艾隆纳亚所救。守护者莱不知所踪。守护者团体死的死，逃的逃，已经没有了守护艾泽拉斯的能力。上古之神正式开始策划逃亡。洛肯封闭奥杜亚，以此来阻挡逃掉守护者的反击。</p>\n<p>洛肯在解决完各守护者后，唯一害怕的就是诺甘农圆盘，说到这个诺甘农圆盘，我们知道它是一个神器，是当初泰坦们为了记录艾泽拉斯上发生的事情布置在艾泽拉斯上的。它就像一个摄影机，守护者们做的所有事都记了下来。洛肯想，万一哪天泰坦大大们回来，调一下诺甘农的监控（不得不说泰坦的科技文明很了得），自己横竖都是个死。但是洛肯还是晚了一步，提尔在他前就想到了这一点，提尔盗取了圆盘并逃跑。洛肯没办法，请了个“黑客”伪造了圆盘（不过这个新造的系统貌似有病毒，总之不稳定），并派刺客追杀提尔残部。</p>\n<p>这刺客团可不得了，它们是，上古神克瑟拉基扎卡兹和基希克斯。这里有一点说明，这些上古神的名字好多在炉石传说中也看到过，不过它们的名字出现都不是很多，本来这整个魔兽世界历史在燃烧军团第一次入侵前就不是很详细，人物设定也不是很清晰，所以很多都一笔带过。说回提尔，刺客团与提尔当然是展开了大战，提尔牺牲，扎卡兹死亡，基希克斯重伤之后无战斗力逃往了西方。为了纪念提尔，艾隆纳亚将提尔死的地方命名为“提尔之陨”，就是“提瑞斯法”的意思，地方就是魔兽幽暗城附近的提瑞斯法林地，维库人在此生存了下来，以守护他们心目中英雄的灵魂。而阿扎达斯和艾隆纳亚一直南下，建立了奥达曼，并在内室贮存了诺甘农圆盘，阿扎达斯为了保护这个神器，在内部封印了奥达曼。</p>\n<p>最后洛肯要解决的就是阿加隆，未了确保自身的安全，它切断了艾泽拉斯的安全隐患阿加隆与艾泽拉斯的联系，保证不至达到连同自己整个被毁掉。</p>\n<p>至此，守护者之战结束。各大守护者相继失去了对抗艾泽拉斯外两大邪恶组织的能力，一旦恶魔们开始入侵，艾泽拉斯的命运，将不再由守护者们守候。接下来一批又一批的种族开始繁衍，艾泽拉斯进入后守护者时期。</p>"},{"title":"魔兽世界的历史从这里开始","date":"2016-08-09T07:21:00.000Z","_content":"\n魔兽世界编年史第一卷上市已经有一段时间，买来阅读，于是开始讲故事，故事的名字就叫做“我眼中的魔兽世界”。那么我们就跟着这本书一起来讲述一下魔兽世界的故事。\n\n![魔兽世界观](http://upload-images.jianshu.io/upload_images/1429775-5f02f9f7c5f87fac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n引言的宇宙观我们就暂且放下，我们这里的目的呢是讲故事，大篇的描述性语句是我们所杜绝的，那些华丽的渲染是作家们做的事情。何况魔兽庞大的宇宙观真正写一时半会也描述不完，我们就一边听着故事，一边来领略魔兽宏大的宇宙世界。 \n首先魔兽的起点要从神话讲起，这就像是我们在讲述很多历史故事都要从神话讲起一样，离我们时间越久的故事，越是难以验证，这样一来好多更成了杜撰的，也或者不是，不去计较这些，故事本身不吸引人，真正吸引人的是那些拥有个人魅力的英雄，这里说远了，我们继续。\n\n![图为虚幻4中的虚空](http://upload-images.jianshu.io/upload_images/1429775-15d74344dff9964c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n魔兽的观点是宇宙最初是由光组成的，这里的光我们也不了解是一种什么物质，总之就统称为光。它有一个特点是会无限的增大，基于宇宙平衡的原理，则会有东西会缩小。这里我们称缩小的东西叫做虚空。当然这其中就免不了有矛盾了，基于矛盾分析原理，它们中必将生出新的东西。于是，这两股能量的矛盾催生了爆炸，爆炸催生了一个新的中间物质，称实体宇宙。（发现很多故事里新的东西的出生都能用一次爆炸来完成，爆炸简直就是奇迹诞生器，既合理，又神奇。）\n\n![](http://upload-images.jianshu.io/upload_images/1429775-d4fbfa12c5ec0c07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n爆炸后又生成的又一个空间叫做扭曲虚空，听名字就像是跟虚空是一伙的。那么这时我们的环境被分成了四块，光区，黑暗区（虚空），实体区（宇宙），还有就是黑暗区小弟（扭曲虚空）。在实体区出现了元素，水，火，土，风四系，各个元素进而发展出生物；光区的发展要从光区的小弟说起，这些小地是一些光区的残片，发展成的生物叫做纳鲁（“纳鲁没有忘记我们”原来是出在这，按这个级别来算，纳鲁的确是神一般的存在啊）；然后就是泰坦，这东西不知道是光区还是实体区的，总之是很牛一般的存在，原文的解释是“比纳鲁还要超凡”，而且理解了一下，大致作者想表达泰坦就是宇宙星系里边的行星（像地球一样），他们的特点是大，初生的状态是沉眠着，能量巨大，苏醒时就变成有海有山有树有风的活世界。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-224f58c00b0815cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n这里我们将提到第一个魔兽世界应该熟知的名字，阿曼苏尔。这个人是降生的泰坦的第一号人物，被称为父。这个人从出生来就带着某种使命，他的任务就是发现其他的泰坦初生体，找到他们并培养他们。 阿曼苏尔唤醒了一批自己的同胞，还在宇宙里给自己占了个山头，建立了一个组织，名曰“万神殿”。这样便出现了宇宙中第一个组织，也是神界唯一的一个组织。另外这个组织还对外进行招募，募集到的种族叫做星穹体（听上去像是行星的卫星），这个种族几乎上也没有什么特殊技能，但是绝招比较可怕，就是可以启动自毁程序，不但自己要完蛋，而且它所监视的星体也要完蛋。所以整个魔兽的历史对它还是很少触及的。\n\n\n>![万神殿](http://upload-images.jianshu.io/upload_images/1429775-1db31a66d9227f2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n>在现实生活中，万神殿是真实存在的，上面图片就是罗马万神殿。万神殿又译万神庙、潘提翁神殿，是至今完整保存的唯一一座罗马帝国时期建筑，始建于公元前27-25年，由罗马帝国首任皇帝屋大维的女婿阿格里帕建造，用以供奉奥林匹亚山上诸神，可谓奥古斯都时期的经典建筑。公元80年的火灾，使万神殿的大部分被毁，仅余一长方形的柱廊，有12.5米高的花岗岩石柱16根，这一部分被作为后来重建的万神殿的门廊，门廊顶上刻有初建时期的纪念性文字，从门廊正面的八根巨大圆柱仍可看出万神殿最初的建筑规模。\n公元前27年兴建、公元120年重建的万神殿(pantheon)，被米开朗基罗赞叹为“天使的设计”。万神殿pantheon的pan是指全部，theon是神的意思，指必须供奉罗马全部的神。\n在罗马市中心，有一个中央竖立着高大的尖顶方碑的喷水池，方碑基座雕有古罗马神话场景，这一喷水池所在地就是罗马万神殿的前庭。\n\n>![](http://upload-images.jianshu.io/upload_images/1429775-5ac7692c390670e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>万神殿上面的字样为MAGRIPPALFCOSTERTIVMFECIT的字样，乃拉丁语，其中文含义为：“吕奇乌斯的儿子、三度执政官玛尔库斯阿格里巴建造此庙”。值得注意的是这里的tertivm表示三的意思，拉丁语本应为tertium，但是因为中世纪以前没有“u”，只有“v”。至中世纪v变u。\n\n>![](http://upload-images.jianshu.io/upload_images/1429775-708fe75018dde5d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>万神殿是古罗马精湛建筑技术的典范。它是一个宽度与高度相等的巨大圆柱体，上面覆盖着半圆形的屋顶。拉斐尔等许多著名艺术家就葬在这里，葬在这里的还有意大利君主专制时期的统治者。对面是罗通达广场，广场中央建有美丽的喷泉。万神殿是众神所在的神殿，几个世纪来，这里见证了历史的变迁。\n\n\n泰坦文明就这样出现了，整个魔兽的世界由泰坦一族开始，秩序就此创立（这个秩序就是：一个宇宙诞生怪胎寻找自己同胞，找不着就继续找，否则故事开展不下去）。讲到这里，这是宇宙之初最开端，这里呢只提到了一个名字，我们来回忆一下，阿曼苏尔，神父级别的人物。\n\n知乎上有人说欧洲神话传说，特别是北欧神话，也被直接引用到了魔兽世界观的构建中，主要在创世论的部分，也就是我们现在讨论的部分。\n北欧神话创世中有这么一段：\n>远古的时代，曾经一无所有，没有沙和海，没有汹涌的海浪，没有大地，也没有天空，只有那巨大的，寸草不生的鸿沟。\t（小埃达，第4节）\n\n暴力、野蛮以及死亡，毫无疑问，这几个要素就像一根红线一般贯穿着整个北欧神话，贯穿着古代维京人所想象的创世神话。\n>在世界初开之时，有一个极冷的世界尼弗尔海姆（Niflheim），充满了冰与寒冷。还有一个极热的世界穆斯帕尔海姆（Muspelheim），充满了炽热与火焰。巨人史尔特尔（Surtur）手持燃烧着火焰的宝剑，守卫着两个世界的边境。它们之间有一条金伦加鸿沟（Ginnungapap)，神秘、似乎能吞噬一切的虚无深渊。\n\n不难看出，魔兽中的光与暗之界面以及中间的虚无空间，对比北欧神话中的寒冷与火之境及中间的虚无深渊，有着异曲同工之妙。另外之后会讲到泰坦的一些继承者们，他们的名字好多都是直接照搬北欧创世神的，比方说奥丁，提尔之流，而西芙则直接被定位成了继承者的妻子。不得不佩服魔兽原著作者的脑洞。在现实与虚拟中既有规则可循，又不失创造的自由性。","source":"_posts/魔兽世界的历史从这里开始.md","raw":"title: 魔兽世界的历史从这里开始\ndate: 2016-08-09 15:21:00\ncategories: Azeroth\n-----------\n\n魔兽世界编年史第一卷上市已经有一段时间，买来阅读，于是开始讲故事，故事的名字就叫做“我眼中的魔兽世界”。那么我们就跟着这本书一起来讲述一下魔兽世界的故事。\n\n![魔兽世界观](http://upload-images.jianshu.io/upload_images/1429775-5f02f9f7c5f87fac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n引言的宇宙观我们就暂且放下，我们这里的目的呢是讲故事，大篇的描述性语句是我们所杜绝的，那些华丽的渲染是作家们做的事情。何况魔兽庞大的宇宙观真正写一时半会也描述不完，我们就一边听着故事，一边来领略魔兽宏大的宇宙世界。 \n首先魔兽的起点要从神话讲起，这就像是我们在讲述很多历史故事都要从神话讲起一样，离我们时间越久的故事，越是难以验证，这样一来好多更成了杜撰的，也或者不是，不去计较这些，故事本身不吸引人，真正吸引人的是那些拥有个人魅力的英雄，这里说远了，我们继续。\n\n![图为虚幻4中的虚空](http://upload-images.jianshu.io/upload_images/1429775-15d74344dff9964c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n魔兽的观点是宇宙最初是由光组成的，这里的光我们也不了解是一种什么物质，总之就统称为光。它有一个特点是会无限的增大，基于宇宙平衡的原理，则会有东西会缩小。这里我们称缩小的东西叫做虚空。当然这其中就免不了有矛盾了，基于矛盾分析原理，它们中必将生出新的东西。于是，这两股能量的矛盾催生了爆炸，爆炸催生了一个新的中间物质，称实体宇宙。（发现很多故事里新的东西的出生都能用一次爆炸来完成，爆炸简直就是奇迹诞生器，既合理，又神奇。）\n\n![](http://upload-images.jianshu.io/upload_images/1429775-d4fbfa12c5ec0c07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n爆炸后又生成的又一个空间叫做扭曲虚空，听名字就像是跟虚空是一伙的。那么这时我们的环境被分成了四块，光区，黑暗区（虚空），实体区（宇宙），还有就是黑暗区小弟（扭曲虚空）。在实体区出现了元素，水，火，土，风四系，各个元素进而发展出生物；光区的发展要从光区的小弟说起，这些小地是一些光区的残片，发展成的生物叫做纳鲁（“纳鲁没有忘记我们”原来是出在这，按这个级别来算，纳鲁的确是神一般的存在啊）；然后就是泰坦，这东西不知道是光区还是实体区的，总之是很牛一般的存在，原文的解释是“比纳鲁还要超凡”，而且理解了一下，大致作者想表达泰坦就是宇宙星系里边的行星（像地球一样），他们的特点是大，初生的状态是沉眠着，能量巨大，苏醒时就变成有海有山有树有风的活世界。\n\n![](http://upload-images.jianshu.io/upload_images/1429775-224f58c00b0815cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n这里我们将提到第一个魔兽世界应该熟知的名字，阿曼苏尔。这个人是降生的泰坦的第一号人物，被称为父。这个人从出生来就带着某种使命，他的任务就是发现其他的泰坦初生体，找到他们并培养他们。 阿曼苏尔唤醒了一批自己的同胞，还在宇宙里给自己占了个山头，建立了一个组织，名曰“万神殿”。这样便出现了宇宙中第一个组织，也是神界唯一的一个组织。另外这个组织还对外进行招募，募集到的种族叫做星穹体（听上去像是行星的卫星），这个种族几乎上也没有什么特殊技能，但是绝招比较可怕，就是可以启动自毁程序，不但自己要完蛋，而且它所监视的星体也要完蛋。所以整个魔兽的历史对它还是很少触及的。\n\n\n>![万神殿](http://upload-images.jianshu.io/upload_images/1429775-1db31a66d9227f2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n>在现实生活中，万神殿是真实存在的，上面图片就是罗马万神殿。万神殿又译万神庙、潘提翁神殿，是至今完整保存的唯一一座罗马帝国时期建筑，始建于公元前27-25年，由罗马帝国首任皇帝屋大维的女婿阿格里帕建造，用以供奉奥林匹亚山上诸神，可谓奥古斯都时期的经典建筑。公元80年的火灾，使万神殿的大部分被毁，仅余一长方形的柱廊，有12.5米高的花岗岩石柱16根，这一部分被作为后来重建的万神殿的门廊，门廊顶上刻有初建时期的纪念性文字，从门廊正面的八根巨大圆柱仍可看出万神殿最初的建筑规模。\n公元前27年兴建、公元120年重建的万神殿(pantheon)，被米开朗基罗赞叹为“天使的设计”。万神殿pantheon的pan是指全部，theon是神的意思，指必须供奉罗马全部的神。\n在罗马市中心，有一个中央竖立着高大的尖顶方碑的喷水池，方碑基座雕有古罗马神话场景，这一喷水池所在地就是罗马万神殿的前庭。\n\n>![](http://upload-images.jianshu.io/upload_images/1429775-5ac7692c390670e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>万神殿上面的字样为MAGRIPPALFCOSTERTIVMFECIT的字样，乃拉丁语，其中文含义为：“吕奇乌斯的儿子、三度执政官玛尔库斯阿格里巴建造此庙”。值得注意的是这里的tertivm表示三的意思，拉丁语本应为tertium，但是因为中世纪以前没有“u”，只有“v”。至中世纪v变u。\n\n>![](http://upload-images.jianshu.io/upload_images/1429775-708fe75018dde5d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>万神殿是古罗马精湛建筑技术的典范。它是一个宽度与高度相等的巨大圆柱体，上面覆盖着半圆形的屋顶。拉斐尔等许多著名艺术家就葬在这里，葬在这里的还有意大利君主专制时期的统治者。对面是罗通达广场，广场中央建有美丽的喷泉。万神殿是众神所在的神殿，几个世纪来，这里见证了历史的变迁。\n\n\n泰坦文明就这样出现了，整个魔兽的世界由泰坦一族开始，秩序就此创立（这个秩序就是：一个宇宙诞生怪胎寻找自己同胞，找不着就继续找，否则故事开展不下去）。讲到这里，这是宇宙之初最开端，这里呢只提到了一个名字，我们来回忆一下，阿曼苏尔，神父级别的人物。\n\n知乎上有人说欧洲神话传说，特别是北欧神话，也被直接引用到了魔兽世界观的构建中，主要在创世论的部分，也就是我们现在讨论的部分。\n北欧神话创世中有这么一段：\n>远古的时代，曾经一无所有，没有沙和海，没有汹涌的海浪，没有大地，也没有天空，只有那巨大的，寸草不生的鸿沟。\t（小埃达，第4节）\n\n暴力、野蛮以及死亡，毫无疑问，这几个要素就像一根红线一般贯穿着整个北欧神话，贯穿着古代维京人所想象的创世神话。\n>在世界初开之时，有一个极冷的世界尼弗尔海姆（Niflheim），充满了冰与寒冷。还有一个极热的世界穆斯帕尔海姆（Muspelheim），充满了炽热与火焰。巨人史尔特尔（Surtur）手持燃烧着火焰的宝剑，守卫着两个世界的边境。它们之间有一条金伦加鸿沟（Ginnungapap)，神秘、似乎能吞噬一切的虚无深渊。\n\n不难看出，魔兽中的光与暗之界面以及中间的虚无空间，对比北欧神话中的寒冷与火之境及中间的虚无深渊，有着异曲同工之妙。另外之后会讲到泰坦的一些继承者们，他们的名字好多都是直接照搬北欧创世神的，比方说奥丁，提尔之流，而西芙则直接被定位成了继承者的妻子。不得不佩服魔兽原著作者的脑洞。在现实与虚拟中既有规则可循，又不失创造的自由性。","slug":"魔兽世界的历史从这里开始","published":1,"updated":"2018-05-04T10:25:29.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucipc00361v60c6x2icp5","content":"<p>魔兽世界编年史第一卷上市已经有一段时间，买来阅读，于是开始讲故事，故事的名字就叫做“我眼中的魔兽世界”。那么我们就跟着这本书一起来讲述一下魔兽世界的故事。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5f02f9f7c5f87fac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"魔兽世界观\"></p>\n<a id=\"more\"></a>\n<p>引言的宇宙观我们就暂且放下，我们这里的目的呢是讲故事，大篇的描述性语句是我们所杜绝的，那些华丽的渲染是作家们做的事情。何况魔兽庞大的宇宙观真正写一时半会也描述不完，我们就一边听着故事，一边来领略魔兽宏大的宇宙世界。<br>首先魔兽的起点要从神话讲起，这就像是我们在讲述很多历史故事都要从神话讲起一样，离我们时间越久的故事，越是难以验证，这样一来好多更成了杜撰的，也或者不是，不去计较这些，故事本身不吸引人，真正吸引人的是那些拥有个人魅力的英雄，这里说远了，我们继续。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-15d74344dff9964c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图为虚幻4中的虚空\"></p>\n<p>魔兽的观点是宇宙最初是由光组成的，这里的光我们也不了解是一种什么物质，总之就统称为光。它有一个特点是会无限的增大，基于宇宙平衡的原理，则会有东西会缩小。这里我们称缩小的东西叫做虚空。当然这其中就免不了有矛盾了，基于矛盾分析原理，它们中必将生出新的东西。于是，这两股能量的矛盾催生了爆炸，爆炸催生了一个新的中间物质，称实体宇宙。（发现很多故事里新的东西的出生都能用一次爆炸来完成，爆炸简直就是奇迹诞生器，既合理，又神奇。）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-d4fbfa12c5ec0c07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>爆炸后又生成的又一个空间叫做扭曲虚空，听名字就像是跟虚空是一伙的。那么这时我们的环境被分成了四块，光区，黑暗区（虚空），实体区（宇宙），还有就是黑暗区小弟（扭曲虚空）。在实体区出现了元素，水，火，土，风四系，各个元素进而发展出生物；光区的发展要从光区的小弟说起，这些小地是一些光区的残片，发展成的生物叫做纳鲁（“纳鲁没有忘记我们”原来是出在这，按这个级别来算，纳鲁的确是神一般的存在啊）；然后就是泰坦，这东西不知道是光区还是实体区的，总之是很牛一般的存在，原文的解释是“比纳鲁还要超凡”，而且理解了一下，大致作者想表达泰坦就是宇宙星系里边的行星（像地球一样），他们的特点是大，初生的状态是沉眠着，能量巨大，苏醒时就变成有海有山有树有风的活世界。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-224f58c00b0815cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里我们将提到第一个魔兽世界应该熟知的名字，阿曼苏尔。这个人是降生的泰坦的第一号人物，被称为父。这个人从出生来就带着某种使命，他的任务就是发现其他的泰坦初生体，找到他们并培养他们。 阿曼苏尔唤醒了一批自己的同胞，还在宇宙里给自己占了个山头，建立了一个组织，名曰“万神殿”。这样便出现了宇宙中第一个组织，也是神界唯一的一个组织。另外这个组织还对外进行招募，募集到的种族叫做星穹体（听上去像是行星的卫星），这个种族几乎上也没有什么特殊技能，但是绝招比较可怕，就是可以启动自毁程序，不但自己要完蛋，而且它所监视的星体也要完蛋。所以整个魔兽的历史对它还是很少触及的。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1db31a66d9227f2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"万神殿\"></p>\n</blockquote>\n<blockquote>\n<p>在现实生活中，万神殿是真实存在的，上面图片就是罗马万神殿。万神殿又译万神庙、潘提翁神殿，是至今完整保存的唯一一座罗马帝国时期建筑，始建于公元前27-25年，由罗马帝国首任皇帝屋大维的女婿阿格里帕建造，用以供奉奥林匹亚山上诸神，可谓奥古斯都时期的经典建筑。公元80年的火灾，使万神殿的大部分被毁，仅余一长方形的柱廊，有12.5米高的花岗岩石柱16根，这一部分被作为后来重建的万神殿的门廊，门廊顶上刻有初建时期的纪念性文字，从门廊正面的八根巨大圆柱仍可看出万神殿最初的建筑规模。<br>公元前27年兴建、公元120年重建的万神殿(pantheon)，被米开朗基罗赞叹为“天使的设计”。万神殿pantheon的pan是指全部，theon是神的意思，指必须供奉罗马全部的神。<br>在罗马市中心，有一个中央竖立着高大的尖顶方碑的喷水池，方碑基座雕有古罗马神话场景，这一喷水池所在地就是罗马万神殿的前庭。</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5ac7692c390670e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<blockquote>\n<p>万神殿上面的字样为MAGRIPPALFCOSTERTIVMFECIT的字样，乃拉丁语，其中文含义为：“吕奇乌斯的儿子、三度执政官玛尔库斯阿格里巴建造此庙”。值得注意的是这里的tertivm表示三的意思，拉丁语本应为tertium，但是因为中世纪以前没有“u”，只有“v”。至中世纪v变u。</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-708fe75018dde5d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<blockquote>\n<p>万神殿是古罗马精湛建筑技术的典范。它是一个宽度与高度相等的巨大圆柱体，上面覆盖着半圆形的屋顶。拉斐尔等许多著名艺术家就葬在这里，葬在这里的还有意大利君主专制时期的统治者。对面是罗通达广场，广场中央建有美丽的喷泉。万神殿是众神所在的神殿，几个世纪来，这里见证了历史的变迁。</p>\n</blockquote>\n<p>泰坦文明就这样出现了，整个魔兽的世界由泰坦一族开始，秩序就此创立（这个秩序就是：一个宇宙诞生怪胎寻找自己同胞，找不着就继续找，否则故事开展不下去）。讲到这里，这是宇宙之初最开端，这里呢只提到了一个名字，我们来回忆一下，阿曼苏尔，神父级别的人物。</p>\n<p>知乎上有人说欧洲神话传说，特别是北欧神话，也被直接引用到了魔兽世界观的构建中，主要在创世论的部分，也就是我们现在讨论的部分。<br>北欧神话创世中有这么一段：</p>\n<blockquote>\n<p>远古的时代，曾经一无所有，没有沙和海，没有汹涌的海浪，没有大地，也没有天空，只有那巨大的，寸草不生的鸿沟。    （小埃达，第4节）</p>\n</blockquote>\n<p>暴力、野蛮以及死亡，毫无疑问，这几个要素就像一根红线一般贯穿着整个北欧神话，贯穿着古代维京人所想象的创世神话。</p>\n<blockquote>\n<p>在世界初开之时，有一个极冷的世界尼弗尔海姆（Niflheim），充满了冰与寒冷。还有一个极热的世界穆斯帕尔海姆（Muspelheim），充满了炽热与火焰。巨人史尔特尔（Surtur）手持燃烧着火焰的宝剑，守卫着两个世界的边境。它们之间有一条金伦加鸿沟（Ginnungapap)，神秘、似乎能吞噬一切的虚无深渊。</p>\n</blockquote>\n<p>不难看出，魔兽中的光与暗之界面以及中间的虚无空间，对比北欧神话中的寒冷与火之境及中间的虚无深渊，有着异曲同工之妙。另外之后会讲到泰坦的一些继承者们，他们的名字好多都是直接照搬北欧创世神的，比方说奥丁，提尔之流，而西芙则直接被定位成了继承者的妻子。不得不佩服魔兽原著作者的脑洞。在现实与虚拟中既有规则可循，又不失创造的自由性。</p>\n","site":{"data":{}},"excerpt":"<p>魔兽世界编年史第一卷上市已经有一段时间，买来阅读，于是开始讲故事，故事的名字就叫做“我眼中的魔兽世界”。那么我们就跟着这本书一起来讲述一下魔兽世界的故事。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5f02f9f7c5f87fac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"魔兽世界观\"></p>","more":"<p>引言的宇宙观我们就暂且放下，我们这里的目的呢是讲故事，大篇的描述性语句是我们所杜绝的，那些华丽的渲染是作家们做的事情。何况魔兽庞大的宇宙观真正写一时半会也描述不完，我们就一边听着故事，一边来领略魔兽宏大的宇宙世界。<br>首先魔兽的起点要从神话讲起，这就像是我们在讲述很多历史故事都要从神话讲起一样，离我们时间越久的故事，越是难以验证，这样一来好多更成了杜撰的，也或者不是，不去计较这些，故事本身不吸引人，真正吸引人的是那些拥有个人魅力的英雄，这里说远了，我们继续。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-15d74344dff9964c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图为虚幻4中的虚空\"></p>\n<p>魔兽的观点是宇宙最初是由光组成的，这里的光我们也不了解是一种什么物质，总之就统称为光。它有一个特点是会无限的增大，基于宇宙平衡的原理，则会有东西会缩小。这里我们称缩小的东西叫做虚空。当然这其中就免不了有矛盾了，基于矛盾分析原理，它们中必将生出新的东西。于是，这两股能量的矛盾催生了爆炸，爆炸催生了一个新的中间物质，称实体宇宙。（发现很多故事里新的东西的出生都能用一次爆炸来完成，爆炸简直就是奇迹诞生器，既合理，又神奇。）</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-d4fbfa12c5ec0c07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>爆炸后又生成的又一个空间叫做扭曲虚空，听名字就像是跟虚空是一伙的。那么这时我们的环境被分成了四块，光区，黑暗区（虚空），实体区（宇宙），还有就是黑暗区小弟（扭曲虚空）。在实体区出现了元素，水，火，土，风四系，各个元素进而发展出生物；光区的发展要从光区的小弟说起，这些小地是一些光区的残片，发展成的生物叫做纳鲁（“纳鲁没有忘记我们”原来是出在这，按这个级别来算，纳鲁的确是神一般的存在啊）；然后就是泰坦，这东西不知道是光区还是实体区的，总之是很牛一般的存在，原文的解释是“比纳鲁还要超凡”，而且理解了一下，大致作者想表达泰坦就是宇宙星系里边的行星（像地球一样），他们的特点是大，初生的状态是沉眠着，能量巨大，苏醒时就变成有海有山有树有风的活世界。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-224f58c00b0815cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>这里我们将提到第一个魔兽世界应该熟知的名字，阿曼苏尔。这个人是降生的泰坦的第一号人物，被称为父。这个人从出生来就带着某种使命，他的任务就是发现其他的泰坦初生体，找到他们并培养他们。 阿曼苏尔唤醒了一批自己的同胞，还在宇宙里给自己占了个山头，建立了一个组织，名曰“万神殿”。这样便出现了宇宙中第一个组织，也是神界唯一的一个组织。另外这个组织还对外进行招募，募集到的种族叫做星穹体（听上去像是行星的卫星），这个种族几乎上也没有什么特殊技能，但是绝招比较可怕，就是可以启动自毁程序，不但自己要完蛋，而且它所监视的星体也要完蛋。所以整个魔兽的历史对它还是很少触及的。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1db31a66d9227f2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"万神殿\"></p>\n</blockquote>\n<blockquote>\n<p>在现实生活中，万神殿是真实存在的，上面图片就是罗马万神殿。万神殿又译万神庙、潘提翁神殿，是至今完整保存的唯一一座罗马帝国时期建筑，始建于公元前27-25年，由罗马帝国首任皇帝屋大维的女婿阿格里帕建造，用以供奉奥林匹亚山上诸神，可谓奥古斯都时期的经典建筑。公元80年的火灾，使万神殿的大部分被毁，仅余一长方形的柱廊，有12.5米高的花岗岩石柱16根，这一部分被作为后来重建的万神殿的门廊，门廊顶上刻有初建时期的纪念性文字，从门廊正面的八根巨大圆柱仍可看出万神殿最初的建筑规模。<br>公元前27年兴建、公元120年重建的万神殿(pantheon)，被米开朗基罗赞叹为“天使的设计”。万神殿pantheon的pan是指全部，theon是神的意思，指必须供奉罗马全部的神。<br>在罗马市中心，有一个中央竖立着高大的尖顶方碑的喷水池，方碑基座雕有古罗马神话场景，这一喷水池所在地就是罗马万神殿的前庭。</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-5ac7692c390670e6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<blockquote>\n<p>万神殿上面的字样为MAGRIPPALFCOSTERTIVMFECIT的字样，乃拉丁语，其中文含义为：“吕奇乌斯的儿子、三度执政官玛尔库斯阿格里巴建造此庙”。值得注意的是这里的tertivm表示三的意思，拉丁语本应为tertium，但是因为中世纪以前没有“u”，只有“v”。至中世纪v变u。</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-708fe75018dde5d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<blockquote>\n<p>万神殿是古罗马精湛建筑技术的典范。它是一个宽度与高度相等的巨大圆柱体，上面覆盖着半圆形的屋顶。拉斐尔等许多著名艺术家就葬在这里，葬在这里的还有意大利君主专制时期的统治者。对面是罗通达广场，广场中央建有美丽的喷泉。万神殿是众神所在的神殿，几个世纪来，这里见证了历史的变迁。</p>\n</blockquote>\n<p>泰坦文明就这样出现了，整个魔兽的世界由泰坦一族开始，秩序就此创立（这个秩序就是：一个宇宙诞生怪胎寻找自己同胞，找不着就继续找，否则故事开展不下去）。讲到这里，这是宇宙之初最开端，这里呢只提到了一个名字，我们来回忆一下，阿曼苏尔，神父级别的人物。</p>\n<p>知乎上有人说欧洲神话传说，特别是北欧神话，也被直接引用到了魔兽世界观的构建中，主要在创世论的部分，也就是我们现在讨论的部分。<br>北欧神话创世中有这么一段：</p>\n<blockquote>\n<p>远古的时代，曾经一无所有，没有沙和海，没有汹涌的海浪，没有大地，也没有天空，只有那巨大的，寸草不生的鸿沟。    （小埃达，第4节）</p>\n</blockquote>\n<p>暴力、野蛮以及死亡，毫无疑问，这几个要素就像一根红线一般贯穿着整个北欧神话，贯穿着古代维京人所想象的创世神话。</p>\n<blockquote>\n<p>在世界初开之时，有一个极冷的世界尼弗尔海姆（Niflheim），充满了冰与寒冷。还有一个极热的世界穆斯帕尔海姆（Muspelheim），充满了炽热与火焰。巨人史尔特尔（Surtur）手持燃烧着火焰的宝剑，守卫着两个世界的边境。它们之间有一条金伦加鸿沟（Ginnungapap)，神秘、似乎能吞噬一切的虚无深渊。</p>\n</blockquote>\n<p>不难看出，魔兽中的光与暗之界面以及中间的虚无空间，对比北欧神话中的寒冷与火之境及中间的虚无深渊，有着异曲同工之妙。另外之后会讲到泰坦的一些继承者们，他们的名字好多都是直接照搬北欧创世神的，比方说奥丁，提尔之流，而西芙则直接被定位成了继承者的妻子。不得不佩服魔兽原著作者的脑洞。在现实与虚拟中既有规则可循，又不失创造的自由性。</p>"},{"title":"魔古帝国的形成与始皇帝雷神","date":"2016-08-28T00:38:00.000Z","_content":"\n本篇我们说一说魔古一族。 \n\n![魔古族](http://upload-images.jianshu.io/upload_images/1429775-1a255b2ce111d74f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n在讲魔古一族之前，首先我们先来总结一下魔兽世界的种族形成。截止到目前，我们从最初的泰坦创世，到现在我们所能讲到的各种族，大致可以将魔兽种族体系的形成分为了三个阶段。\n\n第一个阶段是原始物种虚空大君、泰坦、纳鲁等的出现，至于怎么出现的就不要纠结了，这个问题同“女娲是怎么来的？”一样愚蠢；\n第二个阶段是堕落泰坦变节与上古之神腐化初生泰坦，在艾泽拉斯大陆带来了两波黑暗势力，同时泰坦团们创造第一批泰坦造物守护者群，再加上艾泽拉斯原驻元素团体、荒野众神团，将战争引入艾泽拉斯早期大陆；\n第三个阶段是第二阶段艾泽拉斯早期战争后期，双生熔炉创造第二代泰坦造物经过内战与对外战争、血肉诅咒逐渐形成魔兽现代种族的雏形，黑暗势力在各地的变种形成虫族与恶魔等种族，艾泽拉斯原驻物种发展形成龙类、自然神、元素等。\n本篇要讲的魔古一族就是上面说的第三阶段中所说的第二代泰坦造物中的一支。\n\n\n![艾泽拉斯物种](http://upload-images.jianshu.io/upload_images/1429775-39c9660f3e20627e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n 此前我们说到在守护者内乱后，大守护者莱便消失了。魔古一族一直坚守着锦绣谷，履行泰坦们给他们守护大地的任务。因为血肉诅咒的恐慌，造成了魔古内部军阀割剧的局面。\n\n同巨魔族一样，魔古一族同样也面临着对外战争，即螳螂妖虫族的威胁。在魔古的对内对外战争期间，锦绣谷也同时发展起来锦鱼人、猴族以及熊猫人。熊猫一族与荒野众神中的白虎雪怒、青龙玉珑、朱鹤赤精、玄牛砮皂相交甚好，称它们为至尊天神。\n\n\n![至尊天神](http://upload-images.jianshu.io/upload_images/1429775-4b31199991e5f766.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n魔古一族的统一，大抵是借鉴秦始皇一统天下的路子，而且也加入了一些美国大片中的个人英雄主义。首先出现了一个类似秦始皇的人物——雷神。\n早年雷神的父亲被他的谋臣所害，雷神出逃，然而根据编年史的说法说他并没有寻仇也未继续加入魔古军阀战争，而是陷入了自身的思索，这一点上倒是很牵强。似乎魔兽世界观中对于某位英雄的个人转变处理都是通过个人的“思考”，像小萨因为思考得出“存在即是缺陷”，大守护者莱（莱登）的思考带来自己的郁郁而终，以及我们的雷神的思考。雷神我们认为他是带有主角光环的，入地宫，遇莱登。严厉指责守护者的不作为，后被莱登带往雷霆山，在这里，雷神得知泰坦团们的死亡后，夺取了泰坦残存力量，囚禁莱登。终于，一位枭雄诞生。\n\n\n![雷神](http://upload-images.jianshu.io/upload_images/1429775-82a6f74832f79ed6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n凭借着泰坦力量，雷神一统魔古，并且创立了一个强大的魔古帝国。同秦始皇那样，他成为了魔古族的第一代皇帝。\n雷神之后相继对锦鱼人、猴族、熊猫人发动战争，继雷神在昆莱山打败了至尊天神白虎后，这三个族均被雷神打败，熊猫人就此沦为奴隶；\n由于螳螂妖一族族众众多，难以收服，雷神下令修筑“蟠龙脊”（这不就是万里长城么）以抵御敌人；\n雷神还在锦绣谷以北找到泰坦造物纳拉克煞引擎（纳拉克不是一条龙么？），这个机器可以制造出由血肉和岩石塑造的新物种，由这个机器生产的新物种土地精、蜥蜴人诞生；\n\n其实从编年史来看，雷神的确是参照始皇帝来的，他在建立帝国之后的书同文、车同轨、统一度量衡以及颁布第一部成文法典，我们简直不能用像来形容。就这样，雷神开始了他在艾泽拉斯南部的帝国统治。然而他始终无法抵挡血肉诅咒带给他的恐慌，为长生不老，他开始寻求种族逆转血肉的方法……\n\n\n","source":"_posts/魔古帝国的形成与始皇帝雷神.md","raw":"title: 魔古帝国的形成与始皇帝雷神 \ndate: 2016-08-28 08:38:00\ncategories: Azeroth\n-----------\n\n本篇我们说一说魔古一族。 \n\n![魔古族](http://upload-images.jianshu.io/upload_images/1429775-1a255b2ce111d74f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n在讲魔古一族之前，首先我们先来总结一下魔兽世界的种族形成。截止到目前，我们从最初的泰坦创世，到现在我们所能讲到的各种族，大致可以将魔兽种族体系的形成分为了三个阶段。\n\n第一个阶段是原始物种虚空大君、泰坦、纳鲁等的出现，至于怎么出现的就不要纠结了，这个问题同“女娲是怎么来的？”一样愚蠢；\n第二个阶段是堕落泰坦变节与上古之神腐化初生泰坦，在艾泽拉斯大陆带来了两波黑暗势力，同时泰坦团们创造第一批泰坦造物守护者群，再加上艾泽拉斯原驻元素团体、荒野众神团，将战争引入艾泽拉斯早期大陆；\n第三个阶段是第二阶段艾泽拉斯早期战争后期，双生熔炉创造第二代泰坦造物经过内战与对外战争、血肉诅咒逐渐形成魔兽现代种族的雏形，黑暗势力在各地的变种形成虫族与恶魔等种族，艾泽拉斯原驻物种发展形成龙类、自然神、元素等。\n本篇要讲的魔古一族就是上面说的第三阶段中所说的第二代泰坦造物中的一支。\n\n\n![艾泽拉斯物种](http://upload-images.jianshu.io/upload_images/1429775-39c9660f3e20627e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n 此前我们说到在守护者内乱后，大守护者莱便消失了。魔古一族一直坚守着锦绣谷，履行泰坦们给他们守护大地的任务。因为血肉诅咒的恐慌，造成了魔古内部军阀割剧的局面。\n\n同巨魔族一样，魔古一族同样也面临着对外战争，即螳螂妖虫族的威胁。在魔古的对内对外战争期间，锦绣谷也同时发展起来锦鱼人、猴族以及熊猫人。熊猫一族与荒野众神中的白虎雪怒、青龙玉珑、朱鹤赤精、玄牛砮皂相交甚好，称它们为至尊天神。\n\n\n![至尊天神](http://upload-images.jianshu.io/upload_images/1429775-4b31199991e5f766.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n魔古一族的统一，大抵是借鉴秦始皇一统天下的路子，而且也加入了一些美国大片中的个人英雄主义。首先出现了一个类似秦始皇的人物——雷神。\n早年雷神的父亲被他的谋臣所害，雷神出逃，然而根据编年史的说法说他并没有寻仇也未继续加入魔古军阀战争，而是陷入了自身的思索，这一点上倒是很牵强。似乎魔兽世界观中对于某位英雄的个人转变处理都是通过个人的“思考”，像小萨因为思考得出“存在即是缺陷”，大守护者莱（莱登）的思考带来自己的郁郁而终，以及我们的雷神的思考。雷神我们认为他是带有主角光环的，入地宫，遇莱登。严厉指责守护者的不作为，后被莱登带往雷霆山，在这里，雷神得知泰坦团们的死亡后，夺取了泰坦残存力量，囚禁莱登。终于，一位枭雄诞生。\n\n\n![雷神](http://upload-images.jianshu.io/upload_images/1429775-82a6f74832f79ed6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n凭借着泰坦力量，雷神一统魔古，并且创立了一个强大的魔古帝国。同秦始皇那样，他成为了魔古族的第一代皇帝。\n雷神之后相继对锦鱼人、猴族、熊猫人发动战争，继雷神在昆莱山打败了至尊天神白虎后，这三个族均被雷神打败，熊猫人就此沦为奴隶；\n由于螳螂妖一族族众众多，难以收服，雷神下令修筑“蟠龙脊”（这不就是万里长城么）以抵御敌人；\n雷神还在锦绣谷以北找到泰坦造物纳拉克煞引擎（纳拉克不是一条龙么？），这个机器可以制造出由血肉和岩石塑造的新物种，由这个机器生产的新物种土地精、蜥蜴人诞生；\n\n其实从编年史来看，雷神的确是参照始皇帝来的，他在建立帝国之后的书同文、车同轨、统一度量衡以及颁布第一部成文法典，我们简直不能用像来形容。就这样，雷神开始了他在艾泽拉斯南部的帝国统治。然而他始终无法抵挡血肉诅咒带给他的恐慌，为长生不老，他开始寻求种族逆转血肉的方法……\n\n\n","slug":"魔古帝国的形成与始皇帝雷神","published":1,"updated":"2018-05-04T10:25:45.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgrucipe00391v60tlzn9yzk","content":"<p>本篇我们说一说魔古一族。 </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1a255b2ce111d74f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"魔古族\"></p>\n<a id=\"more\"></a>\n<p>在讲魔古一族之前，首先我们先来总结一下魔兽世界的种族形成。截止到目前，我们从最初的泰坦创世，到现在我们所能讲到的各种族，大致可以将魔兽种族体系的形成分为了三个阶段。</p>\n<p>第一个阶段是原始物种虚空大君、泰坦、纳鲁等的出现，至于怎么出现的就不要纠结了，这个问题同“女娲是怎么来的？”一样愚蠢；<br>第二个阶段是堕落泰坦变节与上古之神腐化初生泰坦，在艾泽拉斯大陆带来了两波黑暗势力，同时泰坦团们创造第一批泰坦造物守护者群，再加上艾泽拉斯原驻元素团体、荒野众神团，将战争引入艾泽拉斯早期大陆；<br>第三个阶段是第二阶段艾泽拉斯早期战争后期，双生熔炉创造第二代泰坦造物经过内战与对外战争、血肉诅咒逐渐形成魔兽现代种族的雏形，黑暗势力在各地的变种形成虫族与恶魔等种族，艾泽拉斯原驻物种发展形成龙类、自然神、元素等。<br>本篇要讲的魔古一族就是上面说的第三阶段中所说的第二代泰坦造物中的一支。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-39c9660f3e20627e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"艾泽拉斯物种\"></p>\n<p> 此前我们说到在守护者内乱后，大守护者莱便消失了。魔古一族一直坚守着锦绣谷，履行泰坦们给他们守护大地的任务。因为血肉诅咒的恐慌，造成了魔古内部军阀割剧的局面。</p>\n<p>同巨魔族一样，魔古一族同样也面临着对外战争，即螳螂妖虫族的威胁。在魔古的对内对外战争期间，锦绣谷也同时发展起来锦鱼人、猴族以及熊猫人。熊猫一族与荒野众神中的白虎雪怒、青龙玉珑、朱鹤赤精、玄牛砮皂相交甚好，称它们为至尊天神。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-4b31199991e5f766.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"至尊天神\"></p>\n<p>魔古一族的统一，大抵是借鉴秦始皇一统天下的路子，而且也加入了一些美国大片中的个人英雄主义。首先出现了一个类似秦始皇的人物——雷神。<br>早年雷神的父亲被他的谋臣所害，雷神出逃，然而根据编年史的说法说他并没有寻仇也未继续加入魔古军阀战争，而是陷入了自身的思索，这一点上倒是很牵强。似乎魔兽世界观中对于某位英雄的个人转变处理都是通过个人的“思考”，像小萨因为思考得出“存在即是缺陷”，大守护者莱（莱登）的思考带来自己的郁郁而终，以及我们的雷神的思考。雷神我们认为他是带有主角光环的，入地宫，遇莱登。严厉指责守护者的不作为，后被莱登带往雷霆山，在这里，雷神得知泰坦团们的死亡后，夺取了泰坦残存力量，囚禁莱登。终于，一位枭雄诞生。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-82a6f74832f79ed6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"雷神\"></p>\n<p>凭借着泰坦力量，雷神一统魔古，并且创立了一个强大的魔古帝国。同秦始皇那样，他成为了魔古族的第一代皇帝。<br>雷神之后相继对锦鱼人、猴族、熊猫人发动战争，继雷神在昆莱山打败了至尊天神白虎后，这三个族均被雷神打败，熊猫人就此沦为奴隶；<br>由于螳螂妖一族族众众多，难以收服，雷神下令修筑“蟠龙脊”（这不就是万里长城么）以抵御敌人；<br>雷神还在锦绣谷以北找到泰坦造物纳拉克煞引擎（纳拉克不是一条龙么？），这个机器可以制造出由血肉和岩石塑造的新物种，由这个机器生产的新物种土地精、蜥蜴人诞生；</p>\n<p>其实从编年史来看，雷神的确是参照始皇帝来的，他在建立帝国之后的书同文、车同轨、统一度量衡以及颁布第一部成文法典，我们简直不能用像来形容。就这样，雷神开始了他在艾泽拉斯南部的帝国统治。然而他始终无法抵挡血肉诅咒带给他的恐慌，为长生不老，他开始寻求种族逆转血肉的方法……</p>\n","site":{"data":{}},"excerpt":"<p>本篇我们说一说魔古一族。 </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-1a255b2ce111d74f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"魔古族\"></p>","more":"<p>在讲魔古一族之前，首先我们先来总结一下魔兽世界的种族形成。截止到目前，我们从最初的泰坦创世，到现在我们所能讲到的各种族，大致可以将魔兽种族体系的形成分为了三个阶段。</p>\n<p>第一个阶段是原始物种虚空大君、泰坦、纳鲁等的出现，至于怎么出现的就不要纠结了，这个问题同“女娲是怎么来的？”一样愚蠢；<br>第二个阶段是堕落泰坦变节与上古之神腐化初生泰坦，在艾泽拉斯大陆带来了两波黑暗势力，同时泰坦团们创造第一批泰坦造物守护者群，再加上艾泽拉斯原驻元素团体、荒野众神团，将战争引入艾泽拉斯早期大陆；<br>第三个阶段是第二阶段艾泽拉斯早期战争后期，双生熔炉创造第二代泰坦造物经过内战与对外战争、血肉诅咒逐渐形成魔兽现代种族的雏形，黑暗势力在各地的变种形成虫族与恶魔等种族，艾泽拉斯原驻物种发展形成龙类、自然神、元素等。<br>本篇要讲的魔古一族就是上面说的第三阶段中所说的第二代泰坦造物中的一支。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-39c9660f3e20627e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"艾泽拉斯物种\"></p>\n<p> 此前我们说到在守护者内乱后，大守护者莱便消失了。魔古一族一直坚守着锦绣谷，履行泰坦们给他们守护大地的任务。因为血肉诅咒的恐慌，造成了魔古内部军阀割剧的局面。</p>\n<p>同巨魔族一样，魔古一族同样也面临着对外战争，即螳螂妖虫族的威胁。在魔古的对内对外战争期间，锦绣谷也同时发展起来锦鱼人、猴族以及熊猫人。熊猫一族与荒野众神中的白虎雪怒、青龙玉珑、朱鹤赤精、玄牛砮皂相交甚好，称它们为至尊天神。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-4b31199991e5f766.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"至尊天神\"></p>\n<p>魔古一族的统一，大抵是借鉴秦始皇一统天下的路子，而且也加入了一些美国大片中的个人英雄主义。首先出现了一个类似秦始皇的人物——雷神。<br>早年雷神的父亲被他的谋臣所害，雷神出逃，然而根据编年史的说法说他并没有寻仇也未继续加入魔古军阀战争，而是陷入了自身的思索，这一点上倒是很牵强。似乎魔兽世界观中对于某位英雄的个人转变处理都是通过个人的“思考”，像小萨因为思考得出“存在即是缺陷”，大守护者莱（莱登）的思考带来自己的郁郁而终，以及我们的雷神的思考。雷神我们认为他是带有主角光环的，入地宫，遇莱登。严厉指责守护者的不作为，后被莱登带往雷霆山，在这里，雷神得知泰坦团们的死亡后，夺取了泰坦残存力量，囚禁莱登。终于，一位枭雄诞生。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1429775-82a6f74832f79ed6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"雷神\"></p>\n<p>凭借着泰坦力量，雷神一统魔古，并且创立了一个强大的魔古帝国。同秦始皇那样，他成为了魔古族的第一代皇帝。<br>雷神之后相继对锦鱼人、猴族、熊猫人发动战争，继雷神在昆莱山打败了至尊天神白虎后，这三个族均被雷神打败，熊猫人就此沦为奴隶；<br>由于螳螂妖一族族众众多，难以收服，雷神下令修筑“蟠龙脊”（这不就是万里长城么）以抵御敌人；<br>雷神还在锦绣谷以北找到泰坦造物纳拉克煞引擎（纳拉克不是一条龙么？），这个机器可以制造出由血肉和岩石塑造的新物种，由这个机器生产的新物种土地精、蜥蜴人诞生；</p>\n<p>其实从编年史来看，雷神的确是参照始皇帝来的，他在建立帝国之后的书同文、车同轨、统一度量衡以及颁布第一部成文法典，我们简直不能用像来形容。就这样，雷神开始了他在艾泽拉斯南部的帝国统治。然而他始终无法抵挡血肉诅咒带给他的恐慌，为长生不老，他开始寻求种族逆转血肉的方法……</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjgrucino00081v60ssinzwlu","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciny000e1v60imkj3nq7"},{"post_id":"cjgrucinc00001v60oyhiy9u1","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio0000i1v60mn0xxh8l"},{"post_id":"cjgrucinq00091v60h4p5ig4n","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio3000l1v60bjpex74k"},{"post_id":"cjgrucinu000c1v60lev8bt7l","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio4000p1v60i8skblg7"},{"post_id":"cjgrucinh00021v602syk3hzt","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio6000s1v60jm9knkep"},{"post_id":"cjgrucinx000d1v60fnrq9si2","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio7000v1v60s7magoqg"},{"post_id":"cjgrucinz000h1v60l8caqn0x","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio8000y1v60b3j8x44a"},{"post_id":"cjgrucinm00061v60yd2ajvp0","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucio900111v60ci7fwl8w"},{"post_id":"cjgrucio2000k1v601dj3mi77","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciob00141v60cpxoqeq9"},{"post_id":"cjgrucio4000o1v60iw11n1r7","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucioc00171v60zincvv44"},{"post_id":"cjgrucio5000r1v60qqw8sa82","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucioe001a1v60qa4wn1i8"},{"post_id":"cjgrucio6000u1v60wupdd0xz","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciof001c1v60e6ijc4ep"},{"post_id":"cjgrucio7000x1v604hc9tl4j","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciog001f1v60cqkuwbqv"},{"post_id":"cjgrucio900101v60m3bwjchs","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucioh001h1v60atf3cuc6"},{"post_id":"cjgrucioa00131v60wx7fhzw4","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucioj001k1v60ka8v01wk"},{"post_id":"cjgruciob00161v60svuz4fgq","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciok001o1v60earg68fv"},{"post_id":"cjgrucioe001b1v60jchmsj3s","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciom001s1v602ktiploi"},{"post_id":"cjgruciog001e1v60cz6qvowt","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucion001v1v60rwezxrqx"},{"post_id":"cjgruciok001n1v60l3au0yqd","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucioo001y1v607l9vwknf"},{"post_id":"cjgruciol001r1v60yncbrfqd","category_id":"cjgrucioj001m1v60x7zavhlj","_id":"cjgrucioq00211v60ik3sj6bg"},{"post_id":"cjgrucioh001g1v60qzu3s0kd","category_id":"cjgrucioj001m1v60x7zavhlj","_id":"cjgrucior00241v60uxx7pcqc"},{"post_id":"cjgruciom001t1v60t2cl8zxe","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucios00271v60kl501rtc"},{"post_id":"cjgrucion001x1v601rrdx5tx","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgruciou00291v60r6yfc7ug"},{"post_id":"cjgrucioi001j1v600ei2e27n","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgruciow002c1v60195qqscl"},{"post_id":"cjgruciop00201v605v7y9jg5","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucioy002f1v602febg59t"},{"post_id":"cjgrucioq00231v60wkqup1vg","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucip0002j1v60sg9pujdb"},{"post_id":"cjgrucior00261v60h0kms11s","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucip2002l1v60yx68yswh"},{"post_id":"cjgruciot00281v60ospwga87","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucip4002o1v60njdydtbz"},{"post_id":"cjgruciov002b1v604lvn24mt","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucip6002r1v60wsq2dk0c"},{"post_id":"cjgruciox002e1v60e13n0e05","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucip8002v1v601ing6nzn"},{"post_id":"cjgrucioz002i1v609dpp0ywv","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucip9002x1v60quu1vbpv"},{"post_id":"cjgrucip1002k1v60vt77f9si","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucipa00301v60ndvh17wp"},{"post_id":"cjgrucip3002n1v60mzb0osk9","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipc00331v60s0lcx2ca"},{"post_id":"cjgrucip5002q1v603a59a1dw","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipd00371v606c3ndl9f"},{"post_id":"cjgrucip7002u1v60gme9ul5d","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipf003a1v60rmlbwb8u"},{"post_id":"cjgrucip8002w1v60hwn3tkns","category_id":"cjgrucink00041v60x4yga3ie","_id":"cjgrucipf003c1v60xzg0as33"},{"post_id":"cjgrucip9002z1v60gxwse3uf","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipg003e1v60fa455tor"},{"post_id":"cjgrucipb00321v606gxejslo","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipg003g1v60x3da1f00"},{"post_id":"cjgrucipc00361v60c6x2icp5","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipg003i1v609vrchdpp"},{"post_id":"cjgrucipe00391v60tlzn9yzk","category_id":"cjgrucion001u1v60r4iz3pus","_id":"cjgrucipg003j1v60swf5pkp4"}],"PostTag":[{"post_id":"cjgrucinc00001v60oyhiy9u1","tag_id":"cjgrucinm00051v607lm5xh4q","_id":"cjgrucio1000j1v609wnvkti6"},{"post_id":"cjgrucinc00001v60oyhiy9u1","tag_id":"cjgrucins000b1v60uj1yl14s","_id":"cjgrucio3000m1v60j245wv1q"},{"post_id":"cjgrucinh00021v602syk3hzt","tag_id":"cjgrucinz000g1v603xqehfom","_id":"cjgrucio5000q1v60ro29mo9w"},{"post_id":"cjgrucinm00061v60yd2ajvp0","tag_id":"cjgrucinz000g1v603xqehfom","_id":"cjgrucio7000w1v60oh03wzgq"},{"post_id":"cjgrucino00081v60ssinzwlu","tag_id":"cjgrucio6000t1v60fulgslxn","_id":"cjgrucioa00121v608f9olpeq"},{"post_id":"cjgrucinq00091v60h4p5ig4n","tag_id":"cjgrucinz000g1v603xqehfom","_id":"cjgruciod00181v60s0vuzx2v"},{"post_id":"cjgrucinu000c1v60lev8bt7l","tag_id":"cjgruciob00151v60kjtv7maq","_id":"cjgrucioj001l1v609w8axwsw"},{"post_id":"cjgrucinu000c1v60lev8bt7l","tag_id":"cjgruciof001d1v60lz8puohw","_id":"cjgruciol001p1v60jg1hrx6h"},{"post_id":"cjgrucinx000d1v60fnrq9si2","tag_id":"cjgrucioi001i1v60zwzloc8i","_id":"cjgruciop001z1v608l68qh2z"},{"post_id":"cjgrucinx000d1v60fnrq9si2","tag_id":"cjgruciol001q1v603io9p8rr","_id":"cjgrucioq00221v60ur7l7y7h"},{"post_id":"cjgrucinz000h1v60l8caqn0x","tag_id":"cjgrucion001w1v60rj0543sv","_id":"cjgruciow002d1v60r90kzyz0"},{"post_id":"cjgrucinz000h1v60l8caqn0x","tag_id":"cjgrucior00251v60ai50rjui","_id":"cjgrucioy002g1v60c2mh77r2"},{"post_id":"cjgrucio2000k1v601dj3mi77","tag_id":"cjgrucion001w1v60rj0543sv","_id":"cjgrucip4002p1v605a7c6kl6"},{"post_id":"cjgrucio2000k1v601dj3mi77","tag_id":"cjgrucioy002h1v60egxbwsv2","_id":"cjgrucip6002s1v60kgkvsxuc"},{"post_id":"cjgrucio4000o1v60iw11n1r7","tag_id":"cjgrucion001w1v60rj0543sv","_id":"cjgrucipb00311v605fcnqyef"},{"post_id":"cjgrucio4000o1v60iw11n1r7","tag_id":"cjgrucip6002t1v603ctdh3ux","_id":"cjgrucipc00341v60v79n6wgk"},{"post_id":"cjgrucip8002w1v60hwn3tkns","tag_id":"cjgrucioi001i1v60zwzloc8i","_id":"cjgrucipe00381v608dbvdoo2"},{"post_id":"cjgrucio5000r1v60qqw8sa82","tag_id":"cjgrucio6000t1v60fulgslxn","_id":"cjgrucipf003d1v60wx9iqou0"},{"post_id":"cjgrucio5000r1v60qqw8sa82","tag_id":"cjgrucip6002t1v603ctdh3ux","_id":"cjgrucipg003f1v60fqsso4pc"},{"post_id":"cjgrucio6000u1v60wupdd0xz","tag_id":"cjgrucipf003b1v60eskiqtdk","_id":"cjgruciph003l1v604t010krd"},{"post_id":"cjgrucio6000u1v60wupdd0xz","tag_id":"cjgrucipg003h1v60rope4gay","_id":"cjgruciph003m1v601lljc5gu"},{"post_id":"cjgrucio7000x1v604hc9tl4j","tag_id":"cjgrucipf003b1v60eskiqtdk","_id":"cjgrucipi003q1v60d59ygz18"},{"post_id":"cjgrucio7000x1v604hc9tl4j","tag_id":"cjgruciph003n1v60gywiee82","_id":"cjgrucipi003r1v60blt4g96k"},{"post_id":"cjgrucio7000x1v604hc9tl4j","tag_id":"cjgruciph003o1v60xstb11sh","_id":"cjgrucipj003t1v60ov8oe424"},{"post_id":"cjgrucio900101v60m3bwjchs","tag_id":"cjgruciph003p1v60mt8619q7","_id":"cjgrucipj003u1v6086wu0hss"},{"post_id":"cjgrucioa00131v60wx7fhzw4","tag_id":"cjgrucipf003b1v60eskiqtdk","_id":"cjgrucipk003x1v60rah6607z"},{"post_id":"cjgrucioa00131v60wx7fhzw4","tag_id":"cjgrucipj003v1v60dmlnt1tv","_id":"cjgrucipk003y1v60owrid5rb"},{"post_id":"cjgruciob00161v60svuz4fgq","tag_id":"cjgrucipk003w1v60mnnc6dom","_id":"cjgrucipk00401v60x2t612dc"},{"post_id":"cjgrucioe001b1v60jchmsj3s","tag_id":"cjgrucioi001i1v60zwzloc8i","_id":"cjgrucipl00431v60c4gam20y"},{"post_id":"cjgrucioe001b1v60jchmsj3s","tag_id":"cjgrucipl00411v60fbzdrde9","_id":"cjgrucipl00441v60dw3roqau"},{"post_id":"cjgruciog001e1v60cz6qvowt","tag_id":"cjgrucioi001i1v60zwzloc8i","_id":"cjgrucipm00471v605034uymx"},{"post_id":"cjgruciog001e1v60cz6qvowt","tag_id":"cjgrucipl00411v60fbzdrde9","_id":"cjgrucipm00481v60dz1avcpd"},{"post_id":"cjgrucioh001g1v60qzu3s0kd","tag_id":"cjgrucipm00461v605qjgl3df","_id":"cjgrucipn004c1v60pwkor5m2"},{"post_id":"cjgrucioh001g1v60qzu3s0kd","tag_id":"cjgrucipm00491v60fcn8y6zn","_id":"cjgrucipn004d1v60glz7cfkr"},{"post_id":"cjgrucioh001g1v60qzu3s0kd","tag_id":"cjgrucipm004a1v60a0r24gju","_id":"cjgrucipn004f1v60msa57ezq"},{"post_id":"cjgruciok001n1v60l3au0yqd","tag_id":"cjgruciph003p1v60mt8619q7","_id":"cjgrucipo004h1v60daj5kei1"},{"post_id":"cjgruciok001n1v60l3au0yqd","tag_id":"cjgrucipn004e1v60wyvfu2rs","_id":"cjgrucipo004i1v609390yuij"},{"post_id":"cjgruciol001r1v60yncbrfqd","tag_id":"cjgrucipm00491v60fcn8y6zn","_id":"cjgrucipp004m1v605vtx0l1c"},{"post_id":"cjgruciol001r1v60yncbrfqd","tag_id":"cjgrucipo004j1v60oord1012","_id":"cjgrucipp004n1v60ye11nmry"},{"post_id":"cjgruciol001r1v60yncbrfqd","tag_id":"cjgrucipm00461v605qjgl3df","_id":"cjgrucipp004p1v609f2v81dx"},{"post_id":"cjgruciom001t1v60t2cl8zxe","tag_id":"cjgrucipp004l1v60gb0y3ke1","_id":"cjgrucipq004q1v60klbb1e1m"},{"post_id":"cjgrucion001x1v601rrdx5tx","tag_id":"cjgrucio6000t1v60fulgslxn","_id":"cjgrucipq004s1v60qz3wltaj"},{"post_id":"cjgrucion001x1v601rrdx5tx","tag_id":"cjgrucipp004o1v6058z9voy9","_id":"cjgrucipr004t1v60dphq8yt5"},{"post_id":"cjgrucior00261v60h0kms11s","tag_id":"cjgrucio6000t1v60fulgslxn","_id":"cjgrucipr004v1v60gcopbtjq"},{"post_id":"cjgrucior00261v60h0kms11s","tag_id":"cjgrucipp004o1v6058z9voy9","_id":"cjgrucipr004w1v60gjmob9cj"},{"post_id":"cjgruciox002e1v60e13n0e05","tag_id":"cjgrucipr004u1v60yqn2nd47","_id":"cjgrucips004z1v608566pr5u"},{"post_id":"cjgruciox002e1v60e13n0e05","tag_id":"cjgrucipr004x1v60xjtkhsd5","_id":"cjgrucips00501v60rhnoa5uu"},{"post_id":"cjgrucip1002k1v60vt77f9si","tag_id":"cjgrucioi001i1v60zwzloc8i","_id":"cjgrucips00511v60q443k8lw"},{"post_id":"cjgrucip1002k1v60vt77f9si","tag_id":"cjgrucips004y1v60lfgay3e3","_id":"cjgrucips00521v60cb4arip6"}],"Tag":[{"name":"Android","_id":"cjgrucinm00051v607lm5xh4q"},{"name":"NFC","_id":"cjgrucins000b1v60uj1yl14s"},{"name":"jenkins","_id":"cjgrucinz000g1v603xqehfom"},{"name":"opengles","_id":"cjgrucio6000t1v60fulgslxn"},{"name":"Android Studio","_id":"cjgruciob00151v60kjtv7maq"},{"name":"mac","_id":"cjgruciof001d1v60lz8puohw"},{"name":"iOS","_id":"cjgrucioi001i1v60zwzloc8i"},{"name":"modularization","_id":"cjgruciol001q1v603io9p8rr"},{"name":"opengl","_id":"cjgrucion001w1v60rj0543sv"},{"name":"glut","_id":"cjgrucior00251v60ai50rjui"},{"name":"render","_id":"cjgrucioy002h1v60egxbwsv2"},{"name":"texture","_id":"cjgrucip6002t1v603ctdh3ux"},{"name":"python","_id":"cjgrucipf003b1v60eskiqtdk"},{"name":"django","_id":"cjgrucipg003h1v60rope4gay"},{"name":"request","_id":"cjgruciph003n1v60gywiee82"},{"name":"beautifulsoup4","_id":"cjgruciph003o1v60xstb11sh"},{"name":"swift","_id":"cjgruciph003p1v60mt8619q7"},{"name":"pelican","_id":"cjgrucipj003v1v60dmlnt1tv"},{"name":"git","_id":"cjgrucipk003w1v60mnnc6dom"},{"name":"bluetooth","_id":"cjgrucipl00411v60fbzdrde9"},{"name":"addons","_id":"cjgrucipm00461v605qjgl3df"},{"name":"wow","_id":"cjgrucipm00491v60fcn8y6zn"},{"name":"toc","_id":"cjgrucipm004a1v60a0r24gju"},{"name":"UTC","_id":"cjgrucipn004e1v60wyvfu2rs"},{"name":"lua","_id":"cjgrucipo004j1v60oord1012"},{"name":"CocaoPods","_id":"cjgrucipp004l1v60gb0y3ke1"},{"name":"GLKit","_id":"cjgrucipp004o1v6058z9voy9"},{"name":"Python","_id":"cjgrucipr004u1v60yqn2nd47"},{"name":"Mechine-Learning","_id":"cjgrucipr004x1v60xjtkhsd5"},{"name":"paradigm","_id":"cjgrucips004y1v60lfgay3e3"}]}}